Contenido del archivo ZIP: 1.zip

Carpeta: onzauth/

Carpeta: onzauth/assets/

Archivo: onzauth/assets/banner-1544x500.png
Tipo de archivo: image/png

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/assets/banner-772x250.png
Tipo de archivo: image/png

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/assets/css/

Archivo: onzauth/assets/css/style.css
Tipo de archivo: text/css

Contenido:
.loader {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    align-items: center;
    background-color: rgba(255 255 255 / 0.8);
    background-size: 100px;
    background-position: center 200px;
    background-repeat: no-repeat;
}

.spinner {
    border: 16px solid #f3f3f3; /* Light grey */
    border-top: 16px solid #3498db; /* Blue */
    border-radius: 50%;
    width: 120px;
    height: 120px;
    animation: spin 2s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.onzauth-form {
    display: flex;
    justify-content: center;
    align-items: center;
}

.login .onzauth-form button{
    min-height: 32px;
    line-height: 3;
    padding: 0 32px;
    background: #151b24;
    color: #fff;
    -webkit-appearance: none;
    border-radius: 5px;
    cursor:pointer;
}

.onzauth-title{
    text-align: center;
}



Archivo: onzauth/assets/icon-128x128.png
Tipo de archivo: image/png

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/assets/icon-256x256.png
Tipo de archivo: image/png

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/assets/js/

Archivo: onzauth/assets/js/main.js
Tipo de archivo: text/javascript

Contenido:
// Initialisation
const auth = new onz.Auth({
    clientID: onzauth_wp.client_id, // Option
});
const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);

/* Login Handler */
const handleLogin = async (e) => {
    e.preventDefault();
    document.body.innerHTML += '<div id="loader" class="loader"><div id="spinner" class="spinner"></div></div>';
    auth.showLogin(); // Shows the login popup
};

let logoutLink = "";

jQuery(function ($) {
    var wooLogout = $(".woocommerce-MyAccount-navigation-link--customer-logout a");
    if (wooLogout.length > 0) {
        var wcLink = wooLogout.attr('href');
        wooLogout.click(function (e) {
            e.preventDefault();
            handleLogout(wcLink);

        });
    }
    var wpLogout = $("#wp-admin-bar-logout a");
    if (wpLogout.length > 0) {
        var wpLink = wpLogout.attr('href');
        wpLogout.click(function (e) {
            e.preventDefault();
            handleLogout(wpLink);
        });
    }
    if ($('#onzauth-already-logged').length > 0) {
        document.location.href = onzauth_wp.redirect_uri;
    }
});

/* Logout Handler */
const handleLogout = (link) => {
    if (auth.isAuthenticated()) {
        document.body.innerHTML += '<div id="loader" class="loader"><div id="spinner" class="spinner"></div></div>';
        auth.logout();
        logoutLink = link;
    }
};

// on logged_out event
auth.on("logged_out", () => {
    if (logoutLink) {
        document.location.href = logoutLink;
    }
    logoutLink = "";
    var el = document.getElementById('loader');
    if (el) el.remove();
});

// Authenticated event, after log in successful, contains accessToken, idToken, refreshToken, expiry
auth.on("authenticated", (authResult) => {
    var el = document.getElementById('loader');
    validateToken(authResult.idToken);
    if (el) el.remove();
});

// Error message
auth.on("error", (errorMessage) => {
    var el = document.getElementById('loader');
    console.error('authentication error', errorMessage);
    alert(errorMessage);
    if (el) el.remove();
});

// On popup or iframe closed
auth.on("closed", () => {
    console.log('iframe or popup is closed'); 
    var el = document.getElementById('loader');
    if (el) el.remove();
});

// Validate Token default
const validateToken = async (didToken) => {
    var el = document.getElementById('loader');
    fetch(onzauth_wp.api_uri + 'onzauth/v1/auth/', {
        headers: {
            Authorization: 'Bearer ' + didToken
        }
    })
    .then(response => {
        if (response.status !== 200) {
            if (el) el.remove();
            alert('Error validating token');
            throw new Error('An error has occured while validating token!  Status Code: ' + response.status);
        }
        response.text().then(function (text) {
            var link = text.replace(/"/g, "");
            document.location.href = link;
        });
    })
    .catch(function (err) {
        if (el) el.remove();
        alert('Error validating token');
        console.log('Error: ', err);
        auth.logout();
    });
};

Carpeta: onzauth/assets/libs/

Archivo: onzauth/assets/libs/onz-auth-js-sdk.min.js
Tipo de archivo: text/javascript

Contenido:
!function (e, n) { "object" == typeof exports && "object" == typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define("onz", [], n) : "object" == typeof exports ? exports.onz = n() : e.onz = n() }(self, (function () { return function () { var e = { 669: function (e, n, r) { e.exports = r(609) }, 448: function (e, n, r) { "use strict"; var t = r(867), o = r(26), i = r(372), a = r(327), u = r(97), c = r(109), s = r(985), f = r(61), d = r(655), l = r(263); e.exports = function (e) { return new Promise((function (n, r) { var h, p = e.data, w = e.headers, m = e.responseType; function v() { e.cancelToken && e.cancelToken.unsubscribe(h), e.signal && e.signal.removeEventListener("abort", h) } t.isFormData(p) && delete w["Content-Type"]; var y = new XMLHttpRequest; if (e.auth) { var g = e.auth.username || "", b = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : ""; w.Authorization = "Basic " + btoa(g + ":" + b) } var E = u(e.baseURL, e.url); function _() { if (y) { var t = "getAllResponseHeaders" in y ? c(y.getAllResponseHeaders()) : null, i = { data: m && "text" !== m && "json" !== m ? y.response : y.responseText, status: y.status, statusText: y.statusText, headers: t, config: e, request: y }; o((function (e) { n(e), v() }), (function (e) { r(e), v() }), i), y = null } } if (y.open(e.method.toUpperCase(), a(E, e.params, e.paramsSerializer), !0), y.timeout = e.timeout, "onloadend" in y ? y.onloadend = _ : y.onreadystatechange = function () { y && 4 === y.readyState && (0 !== y.status || y.responseURL && 0 === y.responseURL.indexOf("file:")) && setTimeout(_) }, y.onabort = function () { y && (r(f("Request aborted", e, "ECONNABORTED", y)), y = null) }, y.onerror = function () { r(f("Network Error", e, null, y)), y = null }, y.ontimeout = function () { var n = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded", t = e.transitional || d.transitional; e.timeoutErrorMessage && (n = e.timeoutErrorMessage), r(f(n, e, t.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", y)), y = null }, t.isStandardBrowserEnv()) { var x = (e.withCredentials || s(E)) && e.xsrfCookieName ? i.read(e.xsrfCookieName) : void 0; x && (w[e.xsrfHeaderName] = x) } "setRequestHeader" in y && t.forEach(w, (function (e, n) { void 0 === p && "content-type" === n.toLowerCase() ? delete w[n] : y.setRequestHeader(n, e) })), t.isUndefined(e.withCredentials) || (y.withCredentials = !!e.withCredentials), m && "json" !== m && (y.responseType = e.responseType), "function" == typeof e.onDownloadProgress && y.addEventListener("progress", e.onDownloadProgress), "function" == typeof e.onUploadProgress && y.upload && y.upload.addEventListener("progress", e.onUploadProgress), (e.cancelToken || e.signal) && (h = function (e) { y && (r(!e || e && e.type ? new l("canceled") : e), y.abort(), y = null) }, e.cancelToken && e.cancelToken.subscribe(h), e.signal && (e.signal.aborted ? h() : e.signal.addEventListener("abort", h))), p || (p = null), y.send(p) })) } }, 609: function (e, n, r) { "use strict"; var t = r(867), o = r(849), i = r(321), a = r(185); var u = function e(n) { var r = new i(n), u = o(i.prototype.request, r); return t.extend(u, i.prototype, r), t.extend(u, r), u.create = function (r) { return e(a(n, r)) }, u }(r(655)); u.Axios = i, u.Cancel = r(263), u.CancelToken = r(972), u.isCancel = r(502), u.VERSION = r(288).version, u.all = function (e) { return Promise.all(e) }, u.spread = r(713), u.isAxiosError = r(268), e.exports = u, e.exports.default = u }, 263: function (e) { "use strict"; function n(e) { this.message = e } n.prototype.toString = function () { return "Cancel" + (this.message ? ": " + this.message : "") }, n.prototype.__CANCEL__ = !0, e.exports = n }, 972: function (e, n, r) { "use strict"; var t = r(263); function o(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); var n; this.promise = new Promise((function (e) { n = e })); var r = this; this.promise.then((function (e) { if (r._listeners) { var n, t = r._listeners.length; for (n = 0; n < t; n++)r._listeners[n](e); r._listeners = null } })), this.promise.then = function (e) { var n, t = new Promise((function (e) { r.subscribe(e), n = e })).then(e); return t.cancel = function () { r.unsubscribe(n) }, t }, e((function (e) { r.reason || (r.reason = new t(e), n(r.reason)) })) } o.prototype.throwIfRequested = function () { if (this.reason) throw this.reason }, o.prototype.subscribe = function (e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] }, o.prototype.unsubscribe = function (e) { if (this._listeners) { var n = this._listeners.indexOf(e); -1 !== n && this._listeners.splice(n, 1) } }, o.source = function () { var e; return { token: new o((function (n) { e = n })), cancel: e } }, e.exports = o }, 502: function (e) { "use strict"; e.exports = function (e) { return !(!e || !e.__CANCEL__) } }, 321: function (e, n, r) { "use strict"; var t = r(867), o = r(327), i = r(782), a = r(572), u = r(185), c = r(875), s = c.validators; function f(e) { this.defaults = e, this.interceptors = { request: new i, response: new i } } f.prototype.request = function (e) { "string" == typeof e ? (e = arguments[1] || {}).url = arguments[0] : e = e || {}, (e = u(this.defaults, e)).method ? e.method = e.method.toLowerCase() : this.defaults.method ? e.method = this.defaults.method.toLowerCase() : e.method = "get"; var n = e.transitional; void 0 !== n && c.assertOptions(n, { silentJSONParsing: s.transitional(s.boolean), forcedJSONParsing: s.transitional(s.boolean), clarifyTimeoutError: s.transitional(s.boolean) }, !1); var r = [], t = !0; this.interceptors.request.forEach((function (n) { "function" == typeof n.runWhen && !1 === n.runWhen(e) || (t = t && n.synchronous, r.unshift(n.fulfilled, n.rejected)) })); var o, i = []; if (this.interceptors.response.forEach((function (e) { i.push(e.fulfilled, e.rejected) })), !t) { var f = [a, void 0]; for (Array.prototype.unshift.apply(f, r), f = f.concat(i), o = Promise.resolve(e); f.length;)o = o.then(f.shift(), f.shift()); return o } for (var d = e; r.length;) { var l = r.shift(), h = r.shift(); try { d = l(d) } catch (e) { h(e); break } } try { o = a(d) } catch (e) { return Promise.reject(e) } for (; i.length;)o = o.then(i.shift(), i.shift()); return o }, f.prototype.getUri = function (e) { return e = u(this.defaults, e), o(e.url, e.params, e.paramsSerializer).replace(/^\?/, "") }, t.forEach(["delete", "get", "head", "options"], (function (e) { f.prototype[e] = function (n, r) { return this.request(u(r || {}, { method: e, url: n, data: (r || {}).data })) } })), t.forEach(["post", "put", "patch"], (function (e) { f.prototype[e] = function (n, r, t) { return this.request(u(t || {}, { method: e, url: n, data: r })) } })), e.exports = f }, 782: function (e, n, r) { "use strict"; var t = r(867); function o() { this.handlers = [] } o.prototype.use = function (e, n, r) { return this.handlers.push({ fulfilled: e, rejected: n, synchronous: !!r && r.synchronous, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 }, o.prototype.eject = function (e) { this.handlers[e] && (this.handlers[e] = null) }, o.prototype.forEach = function (e) { t.forEach(this.handlers, (function (n) { null !== n && e(n) })) }, e.exports = o }, 97: function (e, n, r) { "use strict"; var t = r(793), o = r(303); e.exports = function (e, n) { return e && !t(n) ? o(e, n) : n } }, 61: function (e, n, r) { "use strict"; var t = r(481); e.exports = function (e, n, r, o, i) { var a = new Error(e); return t(a, n, r, o, i) } }, 572: function (e, n, r) { "use strict"; var t = r(867), o = r(527), i = r(502), a = r(655), u = r(263); function c(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new u("canceled") } e.exports = function (e) { return c(e), e.headers = e.headers || {}, e.data = o.call(e, e.data, e.headers, e.transformRequest), e.headers = t.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), t.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (function (n) { delete e.headers[n] })), (e.adapter || a.adapter)(e).then((function (n) { return c(e), n.data = o.call(e, n.data, n.headers, e.transformResponse), n }), (function (n) { return i(n) || (c(e), n && n.response && (n.response.data = o.call(e, n.response.data, n.response.headers, e.transformResponse))), Promise.reject(n) })) } }, 481: function (e) { "use strict"; e.exports = function (e, n, r, t, o) { return e.config = n, r && (e.code = r), e.request = t, e.response = o, e.isAxiosError = !0, e.toJSON = function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null } }, e } }, 185: function (e, n, r) { "use strict"; var t = r(867); e.exports = function (e, n) { n = n || {}; var r = {}; function o(e, n) { return t.isPlainObject(e) && t.isPlainObject(n) ? t.merge(e, n) : t.isPlainObject(n) ? t.merge({}, n) : t.isArray(n) ? n.slice() : n } function i(r) { return t.isUndefined(n[r]) ? t.isUndefined(e[r]) ? void 0 : o(void 0, e[r]) : o(e[r], n[r]) } function a(e) { if (!t.isUndefined(n[e])) return o(void 0, n[e]) } function u(r) { return t.isUndefined(n[r]) ? t.isUndefined(e[r]) ? void 0 : o(void 0, e[r]) : o(void 0, n[r]) } function c(r) { return r in n ? o(e[r], n[r]) : r in e ? o(void 0, e[r]) : void 0 } var s = { url: a, method: a, data: a, baseURL: u, transformRequest: u, transformResponse: u, paramsSerializer: u, timeout: u, timeoutMessage: u, withCredentials: u, adapter: u, responseType: u, xsrfCookieName: u, xsrfHeaderName: u, onUploadProgress: u, onDownloadProgress: u, decompress: u, maxContentLength: u, maxBodyLength: u, transport: u, httpAgent: u, httpsAgent: u, cancelToken: u, socketPath: u, responseEncoding: u, validateStatus: c }; return t.forEach(Object.keys(e).concat(Object.keys(n)), (function (e) { var n = s[e] || i, o = n(e); t.isUndefined(o) && n !== c || (r[e] = o) })), r } }, 26: function (e, n, r) { "use strict"; var t = r(61); e.exports = function (e, n, r) { var o = r.config.validateStatus; r.status && o && !o(r.status) ? n(t("Request failed with status code " + r.status, r.config, null, r.request, r)) : e(r) } }, 527: function (e, n, r) { "use strict"; var t = r(867), o = r(655); e.exports = function (e, n, r) { var i = this || o; return t.forEach(r, (function (r) { e = r.call(i, e, n) })), e } }, 655: function (e, n, r) { "use strict"; var t = r(155), o = r(867), i = r(16), a = r(481), u = { "Content-Type": "application/x-www-form-urlencoded" }; function c(e, n) { !o.isUndefined(e) && o.isUndefined(e["Content-Type"]) && (e["Content-Type"] = n) } var s, f = { transitional: { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, adapter: (("undefined" != typeof XMLHttpRequest || void 0 !== t && "[object process]" === Object.prototype.toString.call(t)) && (s = r(448)), s), transformRequest: [function (e, n) { return i(n, "Accept"), i(n, "Content-Type"), o.isFormData(e) || o.isArrayBuffer(e) || o.isBuffer(e) || o.isStream(e) || o.isFile(e) || o.isBlob(e) ? e : o.isArrayBufferView(e) ? e.buffer : o.isURLSearchParams(e) ? (c(n, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : o.isObject(e) || n && "application/json" === n["Content-Type"] ? (c(n, "application/json"), function (e, n, r) { if (o.isString(e)) try { return (n || JSON.parse)(e), o.trim(e) } catch (e) { if ("SyntaxError" !== e.name) throw e } return (r || JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { var n = this.transitional || f.transitional, r = n && n.silentJSONParsing, t = n && n.forcedJSONParsing, i = !r && "json" === this.responseType; if (i || t && o.isString(e) && e.length) try { return JSON.parse(e) } catch (e) { if (i) { if ("SyntaxError" === e.name) throw a(e, this, "E_JSON_PARSE"); throw e } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*" } } }; o.forEach(["delete", "get", "head"], (function (e) { f.headers[e] = {} })), o.forEach(["post", "put", "patch"], (function (e) { f.headers[e] = o.merge(u) })), e.exports = f }, 288: function (e) { e.exports = { version: "0.24.0" } }, 849: function (e) { "use strict"; e.exports = function (e, n) { return function () { for (var r = new Array(arguments.length), t = 0; t < r.length; t++)r[t] = arguments[t]; return e.apply(n, r) } } }, 327: function (e, n, r) { "use strict"; var t = r(867); function o(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } e.exports = function (e, n, r) { if (!n) return e; var i; if (r) i = r(n); else if (t.isURLSearchParams(n)) i = n.toString(); else { var a = []; t.forEach(n, (function (e, n) { null != e && (t.isArray(e) ? n += "[]" : e = [e], t.forEach(e, (function (e) { t.isDate(e) ? e = e.toISOString() : t.isObject(e) && (e = JSON.stringify(e)), a.push(o(n) + "=" + o(e)) }))) })), i = a.join("&") } if (i) { var u = e.indexOf("#"); -1 !== u && (e = e.slice(0, u)), e += (-1 === e.indexOf("?") ? "?" : "&") + i } return e } }, 303: function (e) { "use strict"; e.exports = function (e, n) { return n ? e.replace(/\/+$/, "") + "/" + n.replace(/^\/+/, "") : e } }, 372: function (e, n, r) { "use strict"; var t = r(867); e.exports = t.isStandardBrowserEnv() ? { write: function (e, n, r, o, i, a) { var u = []; u.push(e + "=" + encodeURIComponent(n)), t.isNumber(r) && u.push("expires=" + new Date(r).toGMTString()), t.isString(o) && u.push("path=" + o), t.isString(i) && u.push("domain=" + i), !0 === a && u.push("secure"), document.cookie = u.join("; ") }, read: function (e) { var n = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return n ? decodeURIComponent(n[3]) : null }, remove: function (e) { this.write(e, "", Date.now() - 864e5) } } : { write: function () { }, read: function () { return null }, remove: function () { } } }, 793: function (e) { "use strict"; e.exports = function (e) { return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e) } }, 268: function (e) { "use strict"; e.exports = function (e) { return "object" == typeof e && !0 === e.isAxiosError } }, 985: function (e, n, r) { "use strict"; var t = r(867); e.exports = t.isStandardBrowserEnv() ? function () { var e, n = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a"); function o(e) { var t = e; return n && (r.setAttribute("href", t), t = r.href), r.setAttribute("href", t), { href: r.href, protocol: r.protocol ? r.protocol.replace(/:$/, "") : "", host: r.host, search: r.search ? r.search.replace(/^\?/, "") : "", hash: r.hash ? r.hash.replace(/^#/, "") : "", hostname: r.hostname, port: r.port, pathname: "/" === r.pathname.charAt(0) ? r.pathname : "/" + r.pathname } } return e = o(window.location.href), function (n) { var r = t.isString(n) ? o(n) : n; return r.protocol === e.protocol && r.host === e.host } }() : function () { return !0 } }, 16: function (e, n, r) { "use strict"; var t = r(867); e.exports = function (e, n) { t.forEach(e, (function (r, t) { t !== n && t.toUpperCase() === n.toUpperCase() && (e[n] = r, delete e[t]) })) } }, 109: function (e, n, r) { "use strict"; var t = r(867), o = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]; e.exports = function (e) { var n, r, i, a = {}; return e ? (t.forEach(e.split("\n"), (function (e) { if (i = e.indexOf(":"), n = t.trim(e.substr(0, i)).toLowerCase(), r = t.trim(e.substr(i + 1)), n) { if (a[n] && o.indexOf(n) >= 0) return; a[n] = "set-cookie" === n ? (a[n] ? a[n] : []).concat([r]) : a[n] ? a[n] + ", " + r : r } })), a) : a } }, 713: function (e) { "use strict"; e.exports = function (e) { return function (n) { return e.apply(null, n) } } }, 875: function (e, n, r) { "use strict"; var t = r(288).version, o = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((function (e, n) { o[e] = function (r) { return typeof r === e || "a" + (n < 1 ? "n " : " ") + e } })); var i = {}; o.transitional = function (e, n, r) { function o(e, n) { return "[Axios v" + t + "] Transitional option '" + e + "'" + n + (r ? ". " + r : "") } return function (r, t, a) { if (!1 === e) throw new Error(o(t, " has been removed" + (n ? " in " + n : ""))); return n && !i[t] && (i[t] = !0, console.warn(o(t, " has been deprecated since v" + n + " and will be removed in the near future"))), !e || e(r, t, a) } }, e.exports = { assertOptions: function (e, n, r) { if ("object" != typeof e) throw new TypeError("options must be an object"); for (var t = Object.keys(e), o = t.length; o-- > 0;) { var i = t[o], a = n[i]; if (a) { var u = e[i], c = void 0 === u || a(u, i, e); if (!0 !== c) throw new TypeError("option " + i + " must be " + c) } else if (!0 !== r) throw Error("Unknown option " + i) } }, validators: o } }, 867: function (e, n, r) { "use strict"; var t = r(849), o = Object.prototype.toString; function i(e) { return "[object Array]" === o.call(e) } function a(e) { return void 0 === e } function u(e) { return null !== e && "object" == typeof e } function c(e) { if ("[object Object]" !== o.call(e)) return !1; var n = Object.getPrototypeOf(e); return null === n || n === Object.prototype } function s(e) { return "[object Function]" === o.call(e) } function f(e, n) { if (null != e) if ("object" != typeof e && (e = [e]), i(e)) for (var r = 0, t = e.length; r < t; r++)n.call(null, e[r], r, e); else for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && n.call(null, e[o], o, e) } e.exports = { isArray: i, isArrayBuffer: function (e) { return "[object ArrayBuffer]" === o.call(e) }, isBuffer: function (e) { return null !== e && !a(e) && null !== e.constructor && !a(e.constructor) && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e) }, isFormData: function (e) { return "undefined" != typeof FormData && e instanceof FormData }, isArrayBufferView: function (e) { return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && e.buffer instanceof ArrayBuffer }, isString: function (e) { return "string" == typeof e }, isNumber: function (e) { return "number" == typeof e }, isObject: u, isPlainObject: c, isUndefined: a, isDate: function (e) { return "[object Date]" === o.call(e) }, isFile: function (e) { return "[object File]" === o.call(e) }, isBlob: function (e) { return "[object Blob]" === o.call(e) }, isFunction: s, isStream: function (e) { return u(e) && s(e.pipe) }, isURLSearchParams: function (e) { return "undefined" != typeof URLSearchParams && e instanceof URLSearchParams }, isStandardBrowserEnv: function () { return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document) }, forEach: f, merge: function e() { var n = {}; function r(r, t) { c(n[t]) && c(r) ? n[t] = e(n[t], r) : c(r) ? n[t] = e({}, r) : i(r) ? n[t] = r.slice() : n[t] = r } for (var t = 0, o = arguments.length; t < o; t++)f(arguments[t], r); return n }, extend: function (e, n, r) { return f(n, (function (n, o) { e[o] = r && "function" == typeof n ? t(n, r) : n })), e }, trim: function (e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "") }, stripBOM: function (e) { return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e } } }, 155: function (e) { var n, r, t = e.exports = {}; function o() { throw new Error("setTimeout has not been defined") } function i() { throw new Error("clearTimeout has not been defined") } function a(e) { if (n === setTimeout) return setTimeout(e, 0); if ((n === o || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0); try { return n(e, 0) } catch (r) { try { return n.call(null, e, 0) } catch (r) { return n.call(this, e, 0) } } } !function () { try { n = "function" == typeof setTimeout ? setTimeout : o } catch (e) { n = o } try { r = "function" == typeof clearTimeout ? clearTimeout : i } catch (e) { r = i } }(); var u, c = [], s = !1, f = -1; function d() { s && u && (s = !1, u.length ? c = u.concat(c) : f = -1, c.length && l()) } function l() { if (!s) { var e = a(d); s = !0; for (var n = c.length; n;) { for (u = c, c = []; ++f < n;)u && u[f].run(); f = -1, n = c.length } u = null, s = !1, function (e) { if (r === clearTimeout) return clearTimeout(e); if ((r === i || !r) && clearTimeout) return r = clearTimeout, clearTimeout(e); try { r(e) } catch (n) { try { return r.call(null, e) } catch (n) { return r.call(this, e) } } }(e) } } function h(e, n) { this.fun = e, this.array = n } function p() { } t.nextTick = function (e) { var n = new Array(arguments.length - 1); if (arguments.length > 1) for (var r = 1; r < arguments.length; r++)n[r - 1] = arguments[r]; c.push(new h(e, n)), 1 !== c.length || s || a(l) }, h.prototype.run = function () { this.fun.apply(null, this.array) }, t.title = "browser", t.browser = !0, t.env = {}, t.argv = [], t.version = "", t.versions = {}, t.on = p, t.addListener = p, t.once = p, t.off = p, t.removeListener = p, t.removeAllListeners = p, t.emit = p, t.prependListener = p, t.prependOnceListener = p, t.listeners = function (e) { return [] }, t.binding = function (e) { throw new Error("process.binding is not supported") }, t.cwd = function () { return "/" }, t.chdir = function (e) { throw new Error("process.chdir is not supported") }, t.umask = function () { return 0 } }, 145: function (e) { "undefined" != typeof self && self, e.exports = function (e) { var n = {}; function r(t) { if (n[t]) return n[t].exports; var o = n[t] = { i: t, l: !1, exports: {} }; return e[t].call(o.exports, o, o.exports, r), o.l = !0, o.exports } return r.m = e, r.c = n, r.d = function (e, n, t) { r.o(e, n) || Object.defineProperty(e, n, { enumerable: !0, get: t }) }, r.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, r.t = function (e, n) { if (1 & n && (e = r(e)), 8 & n) return e; if (4 & n && "object" == typeof e && e && e.__esModule) return e; var t = Object.create(null); if (r.r(t), Object.defineProperty(t, "default", { enumerable: !0, value: e }), 2 & n && "string" != typeof e) for (var o in e) r.d(t, o, function (n) { return e[n] }.bind(null, o)); return t }, r.n = function (e) { var n = e && e.__esModule ? function () { return e.default } : function () { return e }; return r.d(n, "a", n), n }, r.o = function (e, n) { return {}.hasOwnProperty.call(e, n) }, r.p = "", r(r.s = 0) }([function (e, n, r) { "use strict"; function t(e, n) { return (t = Object.setPrototypeOf || function (e, n) { return e.__proto__ = n, e })(e, n) } function o(e, n) { e.prototype = Object.create(n.prototype), e.prototype.constructor = e, t(e, n) } function i() { return (i = Object.assign || function (e) { for (var n = 1; n < arguments.length; n++) { var r = arguments[n]; for (var t in r) ({}).hasOwnProperty.call(r, t) && (e[t] = r[t]) } return e }).apply(this, arguments) } function a(e) { try { if (!e) return !1; if ("undefined" != typeof Promise && e instanceof Promise) return !0; if ("undefined" != typeof window && "function" == typeof window.Window && e instanceof window.Window) return !1; if ("undefined" != typeof window && "function" == typeof window.constructor && e instanceof window.constructor) return !1; var n = {}.toString; if (n) { var r = n.call(e); if ("[object Window]" === r || "[object global]" === r || "[object DOMWindow]" === r) return !1 } if ("function" == typeof e.then) return !0 } catch (e) { return !1 } return !1 } r.r(n), r.d(n, "PopupOpenError", (function () { return Ie })), r.d(n, "create", (function () { return hr })), r.d(n, "destroy", (function () { return mr })), r.d(n, "destroyComponents", (function () { return pr })), r.d(n, "destroyAll", (function () { return wr })), r.d(n, "PROP_TYPE", (function () { return Yn })), r.d(n, "PROP_SERIALIZATION", (function () { return Vn })), r.d(n, "CONTEXT", (function () { return Zn })), r.d(n, "EVENT", (function () { return Gn })); var u, c = [], s = [], f = 0; function d() { if (!f && u) { var e = u; u = null, e.resolve() } } function l() { f += 1 } function h() { f -= 1, d() } var p = function () { function e(e) { var n = this; if (this.resolved = void 0, this.rejected = void 0, this.errorHandled = void 0, this.value = void 0, this.error = void 0, this.handlers = void 0, this.dispatching = void 0, this.stack = void 0, this.resolved = !1, this.rejected = !1, this.errorHandled = !1, this.handlers = [], e) { var r, t, o = !1, i = !1, a = !1; l(); try { e((function (e) { a ? n.resolve(e) : (o = !0, r = e) }), (function (e) { a ? n.reject(e) : (i = !0, t = e) })) } catch (e) { return h(), void this.reject(e) } h(), a = !0, o ? this.resolve(r) : i && this.reject(t) } } var n = e.prototype; return n.resolve = function (e) { if (this.resolved || this.rejected) return this; if (a(e)) throw new Error("Can not resolve promise with another promise"); return this.resolved = !0, this.value = e, this.dispatch(), this }, n.reject = function (e) { var n = this; if (this.resolved || this.rejected) return this; if (a(e)) throw new Error("Can not reject promise with another promise"); if (!e) { var r = e && "function" == typeof e.toString ? e.toString() : {}.toString.call(e); e = new Error("Expected reject to be called with Error, got " + r) } return this.rejected = !0, this.error = e, this.errorHandled || setTimeout((function () { n.errorHandled || function (e, n) { if (-1 === c.indexOf(e)) { c.push(e), setTimeout((function () { throw e }), 1); for (var r = 0; r < s.length; r++)s[r](e, n) } }(e, n) }), 1), this.dispatch(), this }, n.asyncReject = function (e) { return this.errorHandled = !0, this.reject(e), this }, n.dispatch = function () { var n = this.resolved, r = this.rejected, t = this.handlers; if (!this.dispatching && (n || r)) { this.dispatching = !0, l(); for (var o = function (e, n) { return e.then((function (e) { n.resolve(e) }), (function (e) { n.reject(e) })) }, i = 0; i < t.length; i++) { var u = t[i], c = u.onSuccess, s = u.onError, f = u.promise, d = void 0; if (n) try { d = c ? c(this.value) : this.value } catch (e) { f.reject(e); continue } else if (r) { if (!s) { f.reject(this.error); continue } try { d = s(this.error) } catch (e) { f.reject(e); continue } } if (d instanceof e && (d.resolved || d.rejected)) { var p = d; p.resolved ? f.resolve(p.value) : f.reject(p.error), p.errorHandled = !0 } else a(d) ? d instanceof e && (d.resolved || d.rejected) ? d.resolved ? f.resolve(d.value) : f.reject(d.error) : o(d, f) : f.resolve(d) } t.length = 0, this.dispatching = !1, h() } }, n.then = function (n, r) { if (n && "function" != typeof n && !n.call) throw new Error("Promise.then expected a function for success handler"); if (r && "function" != typeof r && !r.call) throw new Error("Promise.then expected a function for error handler"); var t = new e; return this.handlers.push({ promise: t, onSuccess: n, onError: r }), this.errorHandled = !0, this.dispatch(), t }, n.catch = function (e) { return this.then(void 0, e) }, n.finally = function (n) { if (n && "function" != typeof n && !n.call) throw new Error("Promise.finally expected a function"); return this.then((function (r) { return e.try(n).then((function () { return r })) }), (function (r) { return e.try(n).then((function () { throw r })) })) }, n.timeout = function (e, n) { var r = this; if (this.resolved || this.rejected) return this; var t = setTimeout((function () { r.resolved || r.rejected || r.reject(n || new Error("Promise timed out after " + e + "ms")) }), e); return this.then((function (e) { return clearTimeout(t), e })) }, n.toPromise = function () { if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise"); return Promise.resolve(this) }, n.lazy = function () { return this.errorHandled = !0, this }, e.resolve = function (n) { return n instanceof e ? n : a(n) ? new e((function (e, r) { return n.then(e, r) })) : (new e).resolve(n) }, e.reject = function (n) { return (new e).reject(n) }, e.asyncReject = function (n) { return (new e).asyncReject(n) }, e.all = function (n) { var r = new e, t = n.length, o = [].slice(); if (!t) return r.resolve(o), r; for (var i = function (e, n, i) { return n.then((function (n) { o[e] = n, 0 == (t -= 1) && r.resolve(o) }), (function (e) { i.reject(e) })) }, u = 0; u < n.length; u++) { var c = n[u]; if (c instanceof e) { if (c.resolved) { o[u] = c.value, t -= 1; continue } } else if (!a(c)) { o[u] = c, t -= 1; continue } i(u, e.resolve(c), r) } return 0 === t && r.resolve(o), r }, e.hash = function (n) { var r = {}, t = [], o = function (e) { if (n.hasOwnProperty(e)) { var o = n[e]; a(o) ? t.push(o.then((function (n) { r[e] = n }))) : r[e] = o } }; for (var i in n) o(i); return e.all(t).then((function () { return r })) }, e.map = function (n, r) { return e.all(n.map(r)) }, e.onPossiblyUnhandledException = function (e) { return function (e) { return s.push(e), { cancel: function () { s.splice(s.indexOf(e), 1) } } }(e) }, e.try = function (n, r, t) { if (n && "function" != typeof n && !n.call) throw new Error("Promise.try expected a function"); var o; l(); try { o = n.apply(r, t || []) } catch (n) { return h(), e.reject(n) } return h(), e.resolve(o) }, e.delay = function (n) { return new e((function (e) { setTimeout(e, n) })) }, e.isPromise = function (n) { return !!(n && n instanceof e) || a(n) }, e.flush = function () { return n = e, r = u = u || new n, d(), r; var n, r }, e }(); function w(e) { return "[object RegExp]" === {}.toString.call(e) } var m = { IFRAME: "iframe", POPUP: "popup" }, v = "Call was rejected by callee.\r\n"; function y(e) { return void 0 === e && (e = window), e.location.protocol } function g(e) { if (void 0 === e && (e = window), e.mockDomain) { var n = e.mockDomain.split("//")[0]; if (n) return n } return y(e) } function b(e) { return void 0 === e && (e = window), "about:" === g(e) } function E(e) { if (void 0 === e && (e = window), e) try { if (e.parent && e.parent !== e) return e.parent } catch (e) { } } function _(e) { if (void 0 === e && (e = window), e && !E(e)) try { return e.opener } catch (e) { } } function x(e) { try { return !0 } catch (e) { } return !1 } function O(e) { void 0 === e && (e = window); var n = e.location; if (!n) throw new Error("Can not read window location"); var r = y(e); if (!r) throw new Error("Can not read window protocol"); if ("file:" === r) return "file://"; if ("about:" === r) { var t = E(e); return t && x() ? O(t) : "about://" } var o = n.host; if (!o) throw new Error("Can not read window host"); return r + "//" + o } function P(e) { void 0 === e && (e = window); var n = O(e); return n && e.mockDomain && 0 === e.mockDomain.indexOf("mock:") ? e.mockDomain : n } function C(e) { if (!function (e) { try { if (e === window) return !0 } catch (e) { } try { var n = Object.getOwnPropertyDescriptor(e, "location"); if (n && !1 === n.enumerable) return !1 } catch (e) { } try { if (b(e) && x()) return !0 } catch (e) { } try { if (function (e) { return void 0 === e && (e = window), "mock:" === g(e) }(e) && x()) return !0 } catch (e) { } try { if (O(e) === O(window)) return !0 } catch (e) { } return !1 }(e)) return !1; try { if (e === window) return !0; if (b(e) && x()) return !0; if (P(window) === P(e)) return !0 } catch (e) { } return !1 } function S(e) { if (!C(e)) throw new Error("Expected window to be same domain"); return e } function D(e, n) { if (!e || !n) return !1; var r = E(n); return r ? r === e : -1 !== function (e) { var n = []; try { for (; e.parent !== e;)n.push(e.parent), e = e.parent } catch (e) { } return n }(n).indexOf(e) } function T(e) { var n, r, t = []; try { n = e.frames } catch (r) { n = e } try { r = n.length } catch (e) { } if (0 === r) return t; if (r) { for (var o = 0; o < r; o++) { var i = void 0; try { i = n[o] } catch (e) { continue } t.push(i) } return t } for (var a = 0; a < 100; a++) { var u = void 0; try { u = n[a] } catch (e) { return t } if (!u) return t; t.push(u) } return t } function W(e) { for (var n = [], r = 0, t = T(e); r < t.length; r++) { var o = t[r]; n.push(o); for (var i = 0, a = W(o); i < a.length; i++)n.push(a[i]) } return n } function k(e) { void 0 === e && (e = window); try { if (e.top) return e.top } catch (e) { } if (E(e) === e) return e; try { if (D(window, e) && window.top) return window.top } catch (e) { } try { if (D(e, window) && window.top) return window.top } catch (e) { } for (var n = 0, r = W(e); n < r.length; n++) { var t = r[n]; try { if (t.top) return t.top } catch (e) { } if (E(t) === t) return t } } function N(e) { var n = k(e); if (!n) throw new Error("Can not determine top window"); var r = [].concat(W(n), [n]); return -1 === r.indexOf(e) && (r = [].concat(r, [e], W(e))), r } var R = [], j = []; function I(e, n) { void 0 === n && (n = !0); try { if (e === window) return !1 } catch (e) { return !0 } try { if (!e) return !0 } catch (e) { return !0 } try { if (e.closed) return !0 } catch (e) { return !e || e.message !== v } if (n && C(e)) try { if (e.mockclosed) return !0 } catch (e) { } try { if (!e.parent || !e.top) return !0 } catch (e) { } var r = function (e, n) { for (var r = 0; r < e.length; r++)try { if (e[r] === n) return r } catch (e) { } return -1 }(R, e); if (-1 !== r) { var t = j[r]; if (t && function (e) { if (!e.contentWindow) return !0; if (!e.parentNode) return !0; var n = e.ownerDocument; if (n && n.documentElement && !n.documentElement.contains(e)) { for (var r = e; r.parentNode && r.parentNode !== r;)r = r.parentNode; if (!r.host || !n.documentElement.contains(r.host)) return !0 } return !1 }(t)) return !0 } return !1 } function A(e, n) { for (var r = T(e), t = 0; t < r.length; t++) { var o = r[t]; try { if (C(o) && o.name === n && -1 !== r.indexOf(o)) return o } catch (e) { } } try { if (-1 !== r.indexOf(e.frames[n])) return e.frames[n] } catch (e) { } try { if (-1 !== r.indexOf(e[n])) return e[n] } catch (e) { } } function z(e) { return void 0 === e && (e = window), _(e = e || window) || E(e) || void 0 } function F(e, n) { for (var r = 0; r < e.length; r++)for (var t = e[r], o = 0; o < n.length; o++)if (t === n[o]) return !0; return !1 } function L(e) { void 0 === e && (e = window); for (var n = 0, r = e; r;)(r = E(r)) && (n += 1); return n } function M(e, n) { var r = k(e) || e, t = k(n) || n; try { if (r && t) return r === t } catch (e) { } var o = N(e), i = N(n); if (F(o, i)) return !0; var a = _(r), u = _(t); return a && F(N(a), i) || u && F(N(u), o), !1 } function U(e, n) { if ("string" == typeof e) { if ("string" == typeof n) return "*" === e || n === e; if (w(n)) return !1; if (Array.isArray(n)) return !1 } return w(e) ? w(n) ? e.toString() === n.toString() : !Array.isArray(n) && Boolean(n.match(e)) : !!Array.isArray(e) && (Array.isArray(n) ? JSON.stringify(e) === JSON.stringify(n) : !w(n) && e.some((function (e) { return U(e, n) }))) } function q(e) { return e.match(/^(https?|mock|file):\/\//) ? e.split("/").slice(0, 3).join("/") : P() } function B(e, n, r, t) { var o; return void 0 === r && (r = 1e3), void 0 === t && (t = 1 / 0), function i() { if (I(e)) return o && clearTimeout(o), n(); t <= 0 ? clearTimeout(o) : (t -= r, o = setTimeout(i, r)) }(), { cancel: function () { o && clearTimeout(o) } } } function J(e) { try { if (e === window) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if ("[object Window]" === {}.toString.call(e)) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (window.Window && e instanceof window.Window) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (e && e.self === e) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (e && e.parent === e) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (e && e.top === e) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (e && "__unlikely_value__" === e.__cross_domain_utils_window_check__) return !1 } catch (e) { return !0 } try { if ("postMessage" in e && "self" in e && "location" in e) return !0 } catch (e) { } return !1 } function H(e) { if (C(e)) return S(e).frameElement; for (var n = 0, r = document.querySelectorAll("iframe"); n < r.length; n++) { var t = r[n]; if (t && t.contentWindow && t.contentWindow === e) return t } } function Y(e) { if (function (e) { return void 0 === e && (e = window), Boolean(E(e)) }(e)) { var n = H(e); if (n && n.parentElement) return void n.parentElement.removeChild(n) } try { e.close() } catch (e) { } } function V(e, n) { for (var r = 0; r < e.length; r++)try { if (e[r] === n) return r } catch (e) { } return -1 } var Z, G = function () { function e() { if (this.name = void 0, this.weakmap = void 0, this.keys = void 0, this.values = void 0, this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__", function () { if ("undefined" == typeof WeakMap) return !1; if (void 0 === Object.freeze) return !1; try { var e = new WeakMap, n = {}; return Object.freeze(n), e.set(n, "__testvalue__"), "__testvalue__" === e.get(n) } catch (e) { return !1 } }()) try { this.weakmap = new WeakMap } catch (e) { } this.keys = [], this.values = [] } var n = e.prototype; return n._cleanupClosedWindows = function () { for (var e = this.weakmap, n = this.keys, r = 0; r < n.length; r++) { var t = n[r]; if (J(t) && I(t)) { if (e) try { e.delete(t) } catch (e) { } n.splice(r, 1), this.values.splice(r, 1), r -= 1 } } }, n.isSafeToReadWrite = function (e) { return !J(e) }, n.set = function (e, n) { if (!e) throw new Error("WeakMap expected key"); var r = this.weakmap; if (r) try { r.set(e, n) } catch (e) { delete this.weakmap } if (this.isSafeToReadWrite(e)) try { var t = this.name, o = e[t]; return void (o && o[0] === e ? o[1] = n : Object.defineProperty(e, t, { value: [e, n], writable: !0 })) } catch (e) { } this._cleanupClosedWindows(); var i = this.keys, a = this.values, u = V(i, e); -1 === u ? (i.push(e), a.push(n)) : a[u] = n }, n.get = function (e) { if (!e) throw new Error("WeakMap expected key"); var n = this.weakmap; if (n) try { if (n.has(e)) return n.get(e) } catch (e) { delete this.weakmap } if (this.isSafeToReadWrite(e)) try { var r = e[this.name]; return r && r[0] === e ? r[1] : void 0 } catch (e) { } this._cleanupClosedWindows(); var t = V(this.keys, e); if (-1 !== t) return this.values[t] }, n.delete = function (e) { if (!e) throw new Error("WeakMap expected key"); var n = this.weakmap; if (n) try { n.delete(e) } catch (e) { delete this.weakmap } if (this.isSafeToReadWrite(e)) try { var r = e[this.name]; r && r[0] === e && (r[0] = r[1] = void 0) } catch (e) { } this._cleanupClosedWindows(); var t = this.keys, o = V(t, e); -1 !== o && (t.splice(o, 1), this.values.splice(o, 1)) }, n.has = function (e) { if (!e) throw new Error("WeakMap expected key"); var n = this.weakmap; if (n) try { if (n.has(e)) return !0 } catch (e) { delete this.weakmap } if (this.isSafeToReadWrite(e)) try { var r = e[this.name]; return !(!r || r[0] !== e) } catch (e) { } return this._cleanupClosedWindows(), -1 !== V(this.keys, e) }, n.getOrSet = function (e, n) { if (this.has(e)) return this.get(e); var r = n(); return this.set(e, r), r }, e }(); function $(e) { return ($ = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function X() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (e) { return !1 } } function K(e, n, r) { return (K = X() ? Reflect.construct : function (e, n, r) { var o = [null]; o.push.apply(o, n); var i = new (Function.bind.apply(e, o)); return r && t(i, r.prototype), i }).apply(null, arguments) } function Q(e) { var n = "function" == typeof Map ? new Map : void 0; return (Q = function (e) { if (null === e || (r = e, -1 === Function.toString.call(r).indexOf("[native code]"))) return e; var r; if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== n) { if (n.has(e)) return n.get(e); n.set(e, o) } function o() { return K(e, arguments, $(this).constructor) } return o.prototype = Object.create(e.prototype, { constructor: { value: o, enumerable: !1, writable: !0, configurable: !0 } }), t(o, e) })(e) } function ee(e) { return e.name || e.__name__ || e.displayName || "anonymous" } function ne(e, n) { try { delete e.name, e.name = n } catch (e) { } return e.__name__ = e.displayName = n, e } function re(e) { if ("function" == typeof btoa) return btoa(encodeURIComponent(e).replace(/%([0-9A-F]{2})/g, (function (e, n) { return String.fromCharCode(parseInt(n, 16)) }))).replace(/[=]/g, ""); if ("undefined" != typeof Buffer) return Buffer.from(e, "utf8").toString("base64").replace(/[=]/g, ""); throw new Error("Can not find window.btoa or Buffer") } function te() { var e = "0123456789abcdef"; return "uid_" + "xxxxxxxxxx".replace(/./g, (function () { return e.charAt(Math.floor(Math.random() * e.length)) })) + "_" + re((new Date).toISOString().slice(11, 19).replace("T", ".")).replace(/[^a-zA-Z0-9]/g, "").toLowerCase() } function oe(e) { try { return JSON.stringify([].slice.call(e), (function (e, n) { return "function" == typeof n ? "memoize[" + function (e) { if (Z = Z || new G, null == e || "object" != typeof e && "function" != typeof e) throw new Error("Invalid object"); var n = Z.get(e); return n || (n = typeof e + ":" + te(), Z.set(e, n)), n }(n) + "]" : n })) } catch (e) { throw new Error("Arguments not serializable -- can not be used to memoize") } } function ie() { return {} } var ae = 0, ue = 0; function ce(e, n) { void 0 === n && (n = {}); var r, t, o = n.thisNamespace, i = void 0 !== o && o, a = n.time, u = ae; ae += 1; var c = function () { for (var n = arguments.length, o = new Array(n), c = 0; c < n; c++)o[c] = arguments[c]; var s; u < ue && (r = null, t = null, u = ae, ae += 1), s = i ? (t = t || new G).getOrSet(this, ie) : r = r || {}; var f = oe(o), d = s[f]; if (d && a && Date.now() - d.time < a && (delete s[f], d = null), d) return d.value; var l = Date.now(), h = e.apply(this, arguments); return s[f] = { time: l, value: h }, h }; return c.reset = function () { r = null, t = null }, ne(c, (n.name || ee(e)) + "::memoized") } function se(e) { var n = {}; function r() { for (var r = arguments, t = this, o = arguments.length, i = new Array(o), a = 0; a < o; a++)i[a] = arguments[a]; var u = oe(i); return n.hasOwnProperty(u) || (n[u] = p.try((function () { return e.apply(t, r) })).finally((function () { delete n[u] }))), n[u] } return r.reset = function () { n = {} }, ne(r, ee(e) + "::promiseMemoized") } function fe() { } function de(e) { var n = !1; return ne((function () { if (!n) return n = !0, e.apply(this, arguments) }), ee(e) + "::once") } function le(e, n) { if (void 0 === n && (n = 1), n >= 3) return "stringifyError stack overflow"; try { if (!e) return "<unknown error: " + {}.toString.call(e) + ">"; if ("string" == typeof e) return e; if (e instanceof Error) { var r = e && e.stack, t = e && e.message; if (r && t) return -1 !== r.indexOf(t) ? r : t + "\n" + r; if (r) return r; if (t) return t } return e && e.toString && "function" == typeof e.toString ? e.toString() : {}.toString.call(e) } catch (e) { return "Error while stringifying error: " + le(e, n + 1) } } function he(e) { return "string" == typeof e ? e : e && e.toString && "function" == typeof e.toString ? e.toString() : {}.toString.call(e) } function pe(e, n) { if (!n) return e; if (Object.assign) return Object.assign(e, n); for (var r in n) n.hasOwnProperty(r) && (e[r] = n[r]); return e } function we(e) { return e } function me(e, n) { var r; return function t() { r = setTimeout((function () { e(), t() }), n) }(), { cancel: function () { clearTimeout(r) } } } function ve(e) { return [].slice.call(e) } function ye(e) { return null != e } function ge(e) { return "[object RegExp]" === {}.toString.call(e) } function be(e, n, r) { if (e.hasOwnProperty(n)) return e[n]; var t = r(); return e[n] = t, t } function Ee(e) { var n, r = [], t = !1, o = { set: function (n, r) { return t || (e[n] = r, o.register((function () { delete e[n] }))), r }, register: function (e) { var o = de((function () { return e(n) })); return t ? e(n) : r.push(o), { cancel: function () { var e = r.indexOf(o); -1 !== e && r.splice(e, 1) } } }, all: function (e) { n = e; var o = []; for (t = !0; r.length;) { var i = r.shift(); o.push(i()) } return p.all(o).then(fe) } }; return o } function _e(e, n) { if (null == n) throw new Error("Expected " + e + " to be present"); return n } ce.clear = function () { ue = ae }, ce((function (e) { if (Object.values) return Object.values(e); var n = []; for (var r in e) e.hasOwnProperty(r) && n.push(e[r]); return n })); var xe = function (e) { function n(n) { var r; return (r = e.call(this, n) || this).name = r.constructor.name, "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(r), r.constructor) : r.stack = new Error(n).stack, r } return o(n, e), n }(Q(Error)); function Oe() { var e = document.body; if (!e) throw new Error("Body element not found"); return e } function Pe() { return Boolean(document.body) && "complete" === document.readyState } function Ce() { return Boolean(document.body) && "interactive" === document.readyState } function Se(e) { return encodeURIComponent(e) } function De(e) { return function (n, r, t) { void 0 === t && (t = []); var o = n.__inline_memoize_cache__ = n.__inline_memoize_cache__ || {}, i = oe(t); return o.hasOwnProperty(i) ? o[i] : o[i] = function () { var n = {}; if (!e) return n; if (-1 === e.indexOf("=")) return n; for (var r = 0, t = e.split("&"); r < t.length; r++) { var o = t[r]; (o = o.split("="))[0] && o[1] && (n[decodeURIComponent(o[0])] = decodeURIComponent(o[1])) } return n }.apply(void 0, t) }(De, 0, [e]) } function Te(e, n) { return void 0 === n && (n = {}), n && Object.keys(n).length ? (void 0 === (r = i({}, De(e), n)) && (r = {}), Object.keys(r).filter((function (e) { return "string" == typeof r[e] || "boolean" == typeof r[e] })).map((function (e) { var n = r[e]; if ("string" != typeof n && "boolean" != typeof n) throw new TypeError("Invalid type for query"); return Se(e) + "=" + Se(n.toString()) })).join("&")) : e; var r } function We(e, n) { e.appendChild(n) } function ke(e) { return e instanceof window.Element || null !== e && "object" == typeof e && 1 === e.nodeType && "object" == typeof e.style && "object" == typeof e.ownerDocument } function Ne(e, n) { return void 0 === n && (n = document), ke(e) ? e : "string" == typeof e ? n.querySelector(e) : void 0 } function Re(e) { return new p((function (n, r) { var t = he(e), o = Ne(e); if (o) return n(o); if (Pe()) return r(new Error("Document is ready and element " + t + " does not exist")); var i = setInterval((function () { if (o = Ne(e)) n(o), clearInterval(i); else if (Pe()) return clearInterval(i), r(new Error("Document is ready and element " + t + " does not exist")) }), 10) })) } ce((function () { return new p((function (e) { if (Pe() || Ce()) return e(); var n = setInterval((function () { if (Pe() || Ce()) return clearInterval(n), e() }), 10) })) })); var je, Ie = function (e) { function n() { return e.apply(this, arguments) || this } return o(n, e), n }(xe); function Ae(e) { if ((je = je || new G).has(e)) { var n = je.get(e); if (n) return n } var r = new p((function (n, r) { e.addEventListener("load", (function () { !function (e) { if (function () { for (var e = 0; e < R.length; e++) { var n = !1; try { n = R[e].closed } catch (e) { } n && (j.splice(e, 1), R.splice(e, 1)) } }(), e && e.contentWindow) try { R.push(e.contentWindow), j.push(e) } catch (e) { } }(e), n(e) })), e.addEventListener("error", (function (t) { e.contentWindow ? n(e) : r(t) })) })); return je.set(e, r), r } function ze(e) { return Ae(e).then((function (e) { if (!e.contentWindow) throw new Error("Could not find window in iframe"); return e.contentWindow })) } function Fe(e, n) { void 0 === e && (e = {}); var r = e.style || {}, t = function (e, n, r) { void 0 === e && (e = "div"), void 0 === n && (n = {}), e = e.toLowerCase(); var t, o, i, a = document.createElement(e); if (n.style && pe(a.style, n.style), n.class && (a.className = n.class.join(" ")), n.id && a.setAttribute("id", n.id), n.attributes) for (var u = 0, c = Object.keys(n.attributes); u < c.length; u++) { var s = c[u]; a.setAttribute(s, n.attributes[s]) } if (n.styleSheet && (t = a, o = n.styleSheet, void 0 === i && (i = window.document), t.styleSheet ? t.styleSheet.cssText = o : t.appendChild(i.createTextNode(o))), n.html) { if ("iframe" === e) throw new Error("Iframe html can not be written unless container provided and iframe in DOM"); a.innerHTML = n.html } return a }("iframe", { attributes: i({ allowTransparency: "true" }, e.attributes || {}), style: i({ backgroundColor: "transparent", border: "none" }, r), html: e.html, class: e.class }), o = window.navigator.userAgent.match(/MSIE|Edge/i); return t.hasAttribute("id") || t.setAttribute("id", te()), Ae(t), n && function (e, n) { void 0 === n && (n = document); var r = Ne(e, n); if (r) return r; throw new Error("Can not find element: " + he(e)) }(n).appendChild(t), (e.url || o) && t.setAttribute("src", e.url || "about:blank"), t } function Le(e, n, r) { return e.addEventListener(n, r), { cancel: function () { e.removeEventListener(n, r) } } } function Me(e) { e.style.setProperty("display", "") } function Ue(e) { e.style.setProperty("display", "none", "important") } function qe(e) { e && e.parentNode && e.parentNode.removeChild(e) } function Be(e) { return !(e && e.parentNode && e.ownerDocument && e.ownerDocument.documentElement && e.ownerDocument.documentElement.contains(e)) } function Je(e, n, r) { var t = void 0 === r ? {} : r, o = t.width, i = void 0 === o || o, a = t.height, u = void 0 === a || a, c = t.interval, s = void 0 === c ? 100 : c, f = t.win, d = void 0 === f ? window : f, l = e.offsetWidth, h = e.offsetHeight, p = !1; n({ width: l, height: h }); var w, m, v = function () { if (!p && function (e) { return Boolean(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }(e)) { var r = e.offsetWidth, t = e.offsetHeight; (i && r !== l || u && t !== h) && n({ width: r, height: t }), l = r, h = t } }; return d.addEventListener("resize", v), void 0 !== d.ResizeObserver ? ((w = new d.ResizeObserver(v)).observe(e), m = me(v, 10 * s)) : void 0 !== d.MutationObserver ? ((w = new d.MutationObserver(v)).observe(e, { attributes: !0, childList: !0, subtree: !0, characterData: !1 }), m = me(v, 10 * s)) : m = me(v, s), { cancel: function () { p = !0, w.disconnect(), window.removeEventListener("resize", v), m.cancel() } } } function He(e) { for (; e.parentNode;)e = e.parentNode; return "[object ShadowRoot]" === e.toString() } var Ye = "undefined" != typeof document ? document.currentScript : null, Ve = ce((function () { if (Ye) return Ye; if (Ye = function () { try { var e = function () { try { throw new Error("_") } catch (e) { return e.stack || "" } }(), n = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(e), r = n && n[1]; if (!r) return; for (var t = 0, o = [].slice.call(document.getElementsByTagName("script")).reverse(); t < o.length; t++) { var i = o[t]; if (i.src && i.src === r) return i } } catch (e) { } }()) return Ye; throw new Error("Can not determine current script") })), Ze = te(); function Ge(e) { return function (e) { if ("number" == typeof e) return e; var n = e.match(/^([0-9]+)(px|%)$/); if (!n) throw new Error("Could not match css value from " + e); return parseInt(n[1], 10) }(e) + "px" } function $e(e) { return "number" == typeof e ? Ge(e) : "string" == typeof (n = e) && /^[0-9]+%$/.test(n) ? e : Ge(e); var n } function Xe(e) { void 0 === e && (e = window); var n = "__post_robot_10_0_44__"; return e !== window ? e[n] : e[n] = e[n] || {} } ce((function () { var e; try { e = Ve() } catch (e) { return Ze } var n = e.getAttribute("data-uid"); if (n && "string" == typeof n) return n; if ((n = e.getAttribute("data-uid-auto")) && "string" == typeof n) return n; if (e.src) { var r = function (e) { for (var n = "", r = 0; r < e.length; r++) { var t = e[r].charCodeAt(0) * r; e[r + 1] && (t += e[r + 1].charCodeAt(0) * (r - 1)), n += String.fromCharCode(97 + Math.abs(t) % 26) } return n }(JSON.stringify({ src: e.src, dataset: e.dataset })); n = "uid_" + r.slice(r.length - 30) } else n = te(); return e.setAttribute("data-uid-auto", n), n })); var Ke = function () { return {} }; function Qe(e, n) { return void 0 === e && (e = "store"), void 0 === n && (n = Ke), be(Xe(), e, (function () { var e = n(); return { has: function (n) { return e.hasOwnProperty(n) }, get: function (n, r) { return e.hasOwnProperty(n) ? e[n] : r }, set: function (n, r) { return e[n] = r, r }, del: function (n) { delete e[n] }, getOrSet: function (n, r) { return be(e, n, r) }, reset: function () { e = n() }, keys: function () { return Object.keys(e) } } })) } var en, nn = function () { }; function rn() { var e = Xe(); return e.WINDOW_WILDCARD = e.WINDOW_WILDCARD || new nn, e.WINDOW_WILDCARD } function tn(e, n) { return void 0 === e && (e = "store"), void 0 === n && (n = Ke), Qe("windowStore").getOrSet(e, (function () { var r = new G, t = function (e) { return r.getOrSet(e, n) }; return { has: function (n) { return t(n).hasOwnProperty(e) }, get: function (n, r) { var o = t(n); return o.hasOwnProperty(e) ? o[e] : r }, set: function (n, r) { return t(n)[e] = r, r }, del: function (n) { delete t(n)[e] }, getOrSet: function (n, r) { return be(t(n), e, r) } } })) } function on() { return Qe("instance").getOrSet("instanceID", te) } function an(e, n) { var r = n.domain, t = tn("helloPromises"), o = t.get(e); o && o.resolve({ domain: r }); var i = p.resolve({ domain: r }); return t.set(e, i), i } function un(e, n) { return (0, n.send)(e, "postrobot_hello", { instanceID: on() }, { domain: "*", timeout: -1 }).then((function (n) { var r = n.origin, t = n.data.instanceID; return an(e, { domain: r }), { win: e, domain: r, instanceID: t } })) } function cn(e, n) { var r = n.send; return tn("windowInstanceIDPromises").getOrSet(e, (function () { return un(e, { send: r }).then((function (e) { return e.instanceID })) })) } function sn(e) { tn("knownWindows").set(e, !0) } function fn(e) { return "object" == typeof e && null !== e && "string" == typeof e.__type__ } function dn(e) { return void 0 === e ? "undefined" : null === e ? "null" : Array.isArray(e) ? "array" : "function" == typeof e ? "function" : "object" == typeof e ? e instanceof Error ? "error" : "function" == typeof e.then ? "promise" : "[object RegExp]" === {}.toString.call(e) ? "regex" : "[object Date]" === {}.toString.call(e) ? "date" : "object" : "string" == typeof e ? "string" : "number" == typeof e ? "number" : "boolean" == typeof e ? "boolean" : void 0 } function ln(e, n) { return { __type__: e, __val__: n } } var hn, pn = ((en = {}).function = function () { }, en.error = function (e) { return ln("error", { message: e.message, stack: e.stack, code: e.code, data: e.data }) }, en.promise = function () { }, en.regex = function (e) { return ln("regex", e.source) }, en.date = function (e) { return ln("date", e.toJSON()) }, en.array = function (e) { return e }, en.object = function (e) { return e }, en.string = function (e) { return e }, en.number = function (e) { return e }, en.boolean = function (e) { return e }, en.null = function (e) { return e }, en[void 0] = function (e) { return ln("undefined", e) }, en), wn = {}, mn = ((hn = {}).function = function () { throw new Error("Function serialization is not implemented; nothing to deserialize") }, hn.error = function (e) { var n = e.stack, r = e.code, t = e.data, o = new Error(e.message); return o.code = r, t && (o.data = t), o.stack = n + "\n\n" + o.stack, o }, hn.promise = function () { throw new Error("Promise serialization is not implemented; nothing to deserialize") }, hn.regex = function (e) { return new RegExp(e) }, hn.date = function (e) { return new Date(e) }, hn.array = function (e) { return e }, hn.object = function (e) { return e }, hn.string = function (e) { return e }, hn.number = function (e) { return e }, hn.boolean = function (e) { return e }, hn.null = function (e) { return e }, hn[void 0] = function () { }, hn), vn = {}; function yn() { for (var e = Qe("idToProxyWindow"), n = 0, r = e.keys(); n < r.length; n++) { var t = r[n]; e.get(t).shouldClean() && e.del(t) } } function gn(e, n) { var r = n.send, t = n.id, o = void 0 === t ? te() : t, i = e.then((function (e) { if (C(e)) return S(e).name })), a = e.then((function (e) { if (I(e)) throw new Error("Window is closed, can not determine type"); return _(e) ? m.POPUP : m.IFRAME })); i.catch(fe), a.catch(fe); var u = function () { return e.then((function (e) { if (!I(e)) return C(e) ? S(e).name : i })) }; return { id: o, getType: function () { return a }, getInstanceID: se((function () { return e.then((function (e) { return cn(e, { send: r }) })) })), close: function () { return e.then(Y) }, getName: u, focus: function () { return e.then((function (e) { e.focus() })) }, isClosed: function () { return e.then((function (e) { return I(e) })) }, setLocation: function (n, r) { return void 0 === r && (r = {}), e.then((function (e) { var t = window.location.protocol + "//" + window.location.host, o = r.method, i = void 0 === o ? "get" : o, a = r.body; if (0 === n.indexOf("/")) n = "" + t + n; else if (!n.match(/^https?:\/\//) && 0 !== n.indexOf(t)) throw new Error("Expected url to be http or https url, or absolute path, got " + JSON.stringify(n)); if ("post" === i) return u().then((function (e) { if (!e) throw new Error("Can not post to window without target name"); !function (e) { var n = e.url, r = e.target, t = e.body, o = e.method, i = void 0 === o ? "post" : o, a = document.createElement("form"); if (a.setAttribute("target", r), a.setAttribute("method", i), a.setAttribute("action", n), a.style.display = "none", t) for (var u = 0, c = Object.keys(t); u < c.length; u++) { var s, f = c[u], d = document.createElement("input"); d.setAttribute("name", f), d.setAttribute("value", null == (s = t[f]) ? void 0 : s.toString()), a.appendChild(d) } Oe().appendChild(a), a.submit(), Oe().removeChild(a) }({ url: n, target: e, method: i, body: a }) })); if ("get" !== i) throw new Error("Unsupported method: " + i); if (C(e)) try { if (e.location && "function" == typeof e.location.replace) return void e.location.replace(n) } catch (e) { } e.location = n })) }, setName: function (n) { return e.then((function (e) { var r = C(e), t = H(e); if (!r) throw new Error("Can not set name for cross-domain window: " + n); S(e).name = n, t && t.setAttribute("name", n), i = p.resolve(n) })) } } } new p((function (e) { if (window.document && window.document.body) return e(window.document.body); var n = setInterval((function () { if (window.document && window.document.body) return clearInterval(n), e(window.document.body) }), 10) })); var bn = function () { function e(e) { var n = e.send, r = e.win, t = e.serializedWindow; this.id = void 0, this.isProxyWindow = !0, this.serializedWindow = void 0, this.actualWindow = void 0, this.actualWindowPromise = void 0, this.send = void 0, this.name = void 0, this.actualWindowPromise = new p, this.serializedWindow = t || gn(this.actualWindowPromise, { send: n }), Qe("idToProxyWindow").set(this.getID(), this), r && this.setWindow(r, { send: n }) } var n = e.prototype; return n.getID = function () { return this.serializedWindow.id }, n.getType = function () { return this.serializedWindow.getType() }, n.isPopup = function () { return this.getType().then((function (e) { return e === m.POPUP })) }, n.setLocation = function (e, n) { var r = this; return this.serializedWindow.setLocation(e, n).then((function () { return r })) }, n.getName = function () { return this.serializedWindow.getName() }, n.setName = function (e) { var n = this; return this.serializedWindow.setName(e).then((function () { return n })) }, n.close = function () { var e = this; return this.serializedWindow.close().then((function () { return e })) }, n.focus = function () { var e = this, n = this.isPopup(), r = this.getName(), t = p.hash({ isPopup: n, name: r }).then((function (e) { var n = e.name; e.isPopup && n && window.open("", n) })), o = this.serializedWindow.focus(); return p.all([t, o]).then((function () { return e })) }, n.isClosed = function () { return this.serializedWindow.isClosed() }, n.getWindow = function () { return this.actualWindow }, n.setWindow = function (e, n) { var r = n.send; this.actualWindow = e, this.actualWindowPromise.resolve(this.actualWindow), this.serializedWindow = gn(this.actualWindowPromise, { send: r, id: this.getID() }), tn("winToProxyWindow").set(e, this) }, n.awaitWindow = function () { return this.actualWindowPromise }, n.matchWindow = function (e, n) { var r = this, t = n.send; return p.try((function () { return r.actualWindow ? e === r.actualWindow : p.hash({ proxyInstanceID: r.getInstanceID(), knownWindowInstanceID: cn(e, { send: t }) }).then((function (n) { var o = n.proxyInstanceID === n.knownWindowInstanceID; return o && r.setWindow(e, { send: t }), o })) })) }, n.unwrap = function () { return this.actualWindow || this }, n.getInstanceID = function () { return this.serializedWindow.getInstanceID() }, n.shouldClean = function () { return Boolean(this.actualWindow && I(this.actualWindow)) }, n.serialize = function () { return this.serializedWindow }, e.unwrap = function (n) { return e.isProxyWindow(n) ? n.unwrap() : n }, e.serialize = function (n, r) { var t = r.send; return yn(), e.toProxyWindow(n, { send: t }).serialize() }, e.deserialize = function (n, r) { var t = r.send; return yn(), Qe("idToProxyWindow").get(n.id) || new e({ serializedWindow: n, send: t }) }, e.isProxyWindow = function (e) { return Boolean(e && !J(e) && e.isProxyWindow) }, e.toProxyWindow = function (n, r) { var t = r.send; if (yn(), e.isProxyWindow(n)) return n; var o = n; return tn("winToProxyWindow").get(o) || new e({ win: o, send: t }) }, e }(); function En(e, n, r, t, o) { var i = tn("methodStore"), a = Qe("proxyWindowMethods"); bn.isProxyWindow(t) ? a.set(e, { val: n, name: r, domain: o, source: t }) : (a.del(e), i.getOrSet(t, (function () { return {} }))[e] = { domain: o, name: r, val: n, source: t }) } function _n(e, n) { var r = tn("methodStore"), t = Qe("proxyWindowMethods"); return r.getOrSet(e, (function () { return {} }))[n] || t.get(n) } function xn(e, n, r, t, o) { var i, a, u; a = (i = { on: o.on, send: o.send }).on, u = i.send, Qe("builtinListeners").getOrSet("functionCalls", (function () { return a("postrobot_method", { domain: "*" }, (function (e) { var n = e.source, r = e.origin, t = e.data, o = t.id, i = t.name, a = _n(n, o); if (!a) throw new Error("Could not find method '" + i + "' with id: " + t.id + " in " + P(window)); var c = a.source, s = a.domain, f = a.val; return p.try((function () { if (!U(s, r)) throw new Error("Method '" + t.name + "' domain " + JSON.stringify(ge(a.domain) ? a.domain.source : a.domain) + " does not match origin " + r + " in " + P(window)); if (bn.isProxyWindow(c)) return c.matchWindow(n, { send: u }).then((function (e) { if (!e) throw new Error("Method call '" + t.name + "' failed - proxy window does not match source in " + P(window)) })) })).then((function () { return f.apply({ source: n, origin: r }, t.args) }), (function (e) { return p.try((function () { if (f.onError) return f.onError(e) })).then((function () { var n; throw e.stack && (e.stack = "Remote call to " + i + "(" + (void 0 === (n = t.args) && (n = []), ve(n).map((function (e) { return "string" == typeof e ? "'" + e + "'" : void 0 === e ? "undefined" : null === e ? "null" : "boolean" == typeof e ? e.toString() : Array.isArray(e) ? "[ ... ]" : "object" == typeof e ? "{ ... }" : "function" == typeof e ? "() => { ... }" : "<" + typeof e + ">" })).join(", ") + ") failed\n\n") + e.stack), e })) })).then((function (e) { return { result: e, id: o, name: i } })) })) })); var c = r.__id__ || te(); e = bn.unwrap(e); var s = r.__name__ || r.name || t; return "string" == typeof s && "function" == typeof s.indexOf && 0 === s.indexOf("anonymous::") && (s = s.replace("anonymous::", t + "::")), bn.isProxyWindow(e) ? (En(c, r, s, e, n), e.awaitWindow().then((function (e) { En(c, r, s, e, n) }))) : En(c, r, s, e, n), ln("cross_domain_function", { id: c, name: s }) } function On(e, n, r, t) { var o, i = t.on, a = t.send; return function (e, n) { void 0 === n && (n = wn); var r = JSON.stringify(e, (function (e) { var r = this[e]; if (fn(this)) return r; var t = dn(r); if (!t) return r; var o = n[t] || pn[t]; return o ? o(r, e) : r })); return void 0 === r ? "undefined" : r }(r, ((o = {}).promise = function (r, t) { return function (e, n, r, t, o) { return ln("cross_domain_zalgo_promise", { then: xn(e, n, (function (e, n) { return r.then(e, n) }), t, { on: o.on, send: o.send }) }) }(e, n, r, t, { on: i, send: a }) }, o.function = function (r, t) { return xn(e, n, r, t, { on: i, send: a }) }, o.object = function (e) { return J(e) || bn.isProxyWindow(e) ? ln("cross_domain_window", bn.serialize(e, { send: a })) : e }, o)) } function Pn(e, n, r, t) { var o, i = t.send; return function (e, n) { if (void 0 === n && (n = vn), "undefined" !== e) return JSON.parse(e, (function (e, r) { if (fn(this)) return r; var t, o; if (fn(r) ? (t = r.__type__, o = r.__val__) : (t = dn(r), o = r), !t) return o; var i = n[t] || mn[t]; return i ? i(o, e) : o })) }(r, ((o = {}).cross_domain_zalgo_promise = function (e) { return function (e, n, r) { return new p(r.then) }(0, 0, e) }, o.cross_domain_function = function (r) { return function (e, n, r, t) { var o = r.id, i = r.name, a = t.send, u = function (r) { function t() { var u = arguments; return bn.toProxyWindow(e, { send: a }).awaitWindow().then((function (e) { var c = _n(e, o); if (c && c.val !== t) return c.val.apply({ source: window, origin: P() }, u); var s = [].slice.call(u); return r.fireAndForget ? a(e, "postrobot_method", { id: o, name: i, args: s }, { domain: n, fireAndForget: !0 }) : a(e, "postrobot_method", { id: o, name: i, args: s }, { domain: n, fireAndForget: !1 }).then((function (e) { return e.data.result })) })).catch((function (e) { throw e })) } return void 0 === r && (r = {}), t.__name__ = i, t.__origin__ = n, t.__source__ = e, t.__id__ = o, t.origin = n, t }, c = u(); return c.fireAndForget = u({ fireAndForget: !0 }), c }(e, n, r, { send: i }) }, o.cross_domain_window = function (e) { return bn.deserialize(e, { send: i }) }, o)) } var Cn = {}; function Sn(e, n, r, t) { var o = t.on, i = t.send; return p.try((function () { var t = tn().getOrSet(e, (function () { return {} })); return t.buffer = t.buffer || [], t.buffer.push(r), t.flush = t.flush || p.flush().then((function () { if (I(e)) throw new Error("Window is closed"); var r, a = On(e, n, ((r = {}).__post_robot_10_0_44__ = t.buffer || [], r), { on: o, send: i }); delete t.buffer; for (var u = Object.keys(Cn), c = [], s = 0; s < u.length; s++) { var f = u[s]; try { Cn[f](e, a, n) } catch (e) { c.push(e) } } if (c.length === u.length) throw new Error("All post-robot messaging strategies failed:\n\n" + c.map((function (e, n) { return n + ". " + le(e) })).join("\n\n")) })), t.flush.then((function () { delete t.flush })) })).then(fe) } function Dn(e) { return Qe("responseListeners").get(e) } function Tn(e) { Qe("responseListeners").del(e) } function Wn(e) { return Qe("erroredResponseListeners").has(e) } function kn(e) { var n = e.name, r = e.win, t = e.domain, o = tn("requestListeners"); if ("*" === r && (r = null), "*" === t && (t = null), !n) throw new Error("Name required to get request listener"); for (var i = 0, a = [r, rn()]; i < a.length; i++) { var u = a[i]; if (u) { var c = o.get(u); if (c) { var s = c[n]; if (s) { if (t && "string" == typeof t) { if (s[t]) return s[t]; if (s.__domain_regex__) for (var f = 0, d = s.__domain_regex__; f < d.length; f++) { var l = d[f], h = l.listener; if (U(l.regex, t)) return h } } if (s["*"]) return s["*"] } } } } } function Nn(e, n, r, t) { var o = t.on, i = t.send, a = kn({ name: r.name, win: e, domain: n }), u = "postrobot_method" === r.name && r.data && "string" == typeof r.data.name ? r.data.name + "()" : r.name; function c(t, a, c) { return p.flush().then((function () { if (!r.fireAndForget && !I(e)) try { return Sn(e, n, { id: te(), origin: P(window), type: "postrobot_message_response", hash: r.hash, name: r.name, ack: t, data: a, error: c }, { on: o, send: i }) } catch (e) { throw new Error("Send response message failed for " + u + " in " + P() + "\n\n" + le(e)) } })) } return p.all([p.flush().then((function () { if (!r.fireAndForget && !I(e)) try { return Sn(e, n, { id: te(), origin: P(window), type: "postrobot_message_ack", hash: r.hash, name: r.name }, { on: o, send: i }) } catch (e) { throw new Error("Send ack message failed for " + u + " in " + P() + "\n\n" + le(e)) } })), p.try((function () { if (!a) throw new Error("No handler found for post message: " + r.name + " from " + n + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname); if (!U(a.domain, n)) throw new Error("Request origin " + n + " does not match domain " + a.domain.toString()); return a.handler({ source: e, origin: n, data: r.data }) })).then((function (e) { return c("success", e) }), (function (e) { return c("error", null, e) }))]).then(fe).catch((function (e) { if (a && a.handleError) return a.handleError(e); throw e })) } function Rn(e, n, r) { if (!Wn(r.hash)) { var t = Dn(r.hash); if (!t) throw new Error("No handler found for post message ack for message: " + r.name + " from " + n + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname); try { if (!U(t.domain, n)) throw new Error("Ack origin " + n + " does not match domain " + t.domain.toString()); if (e !== t.win) throw new Error("Ack source does not match registered window") } catch (e) { t.promise.reject(e) } t.ack = !0 } } function jn(e, n, r) { if (!Wn(r.hash)) { var t, o = Dn(r.hash); if (!o) throw new Error("No handler found for post message response for message: " + r.name + " from " + n + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname); if (!U(o.domain, n)) throw new Error("Response origin " + n + " does not match domain " + (t = o.domain, Array.isArray(t) ? "(" + t.join(" | ") + ")" : w(t) ? "RegExp(" + t.toString() + ")" : t.toString())); if (e !== o.win) throw new Error("Response source does not match registered window"); Tn(r.hash), "error" === r.ack ? o.promise.reject(r.error) : "success" === r.ack && o.promise.resolve({ source: e, origin: n, data: r.data }) } } function In(e, n) { var r = n.on, t = n.send, o = Qe("receivedMessages"); try { if (!window || window.closed || !e.source) return } catch (e) { return } var i = e.source, a = e.origin, u = function (e, n, r, t) { var o, i = t.on, a = t.send; try { o = Pn(n, r, e, { on: i, send: a }) } catch (e) { return } if (o && "object" == typeof o && null !== o) { var u = o.__post_robot_10_0_44__; if (Array.isArray(u)) return u } }(e.data, i, a, { on: r, send: t }); if (u) { sn(i); for (var c = 0; c < u.length; c++) { var s = u[c]; if (o.has(s.id)) return; if (o.set(s.id, !0), I(i) && !s.fireAndForget) return; 0 === s.origin.indexOf("file:") && (a = "file://"); try { "postrobot_message_request" === s.type ? Nn(i, a, s, { on: r, send: t }) : "postrobot_message_response" === s.type ? jn(i, a, s) : "postrobot_message_ack" === s.type && Rn(i, a, s) } catch (e) { setTimeout((function () { throw e }), 0) } } } } function An(e, n, r) { if (!e) throw new Error("Expected name"); if ("function" == typeof (n = n || {}) && (r = n, n = {}), !r) throw new Error("Expected handler"); (n = n || {}).name = e, n.handler = r || n.handler; var t = n.window, o = n.domain, i = function e(n, r) { var t = n.name, o = n.win, i = n.domain, a = tn("requestListeners"); if (!t || "string" != typeof t) throw new Error("Name required to add request listener"); if (Array.isArray(o)) { for (var u = [], c = 0, s = o; c < s.length; c++)u.push(e({ name: t, domain: i, win: s[c] }, r)); return { cancel: function () { for (var e = 0; e < u.length; e++)u[e].cancel() } } } if (Array.isArray(i)) { for (var f = [], d = 0, l = i; d < l.length; d++)f.push(e({ name: t, win: o, domain: l[d] }, r)); return { cancel: function () { for (var e = 0; e < f.length; e++)f[e].cancel() } } } var h = kn({ name: t, win: o, domain: i }); if (o && "*" !== o || (o = rn()), i = i || "*", h) throw o && i ? new Error("Request listener already exists for " + t + " on domain " + i.toString() + " for " + (o === rn() ? "wildcard" : "specified") + " window") : o ? new Error("Request listener already exists for " + t + " for " + (o === rn() ? "wildcard" : "specified") + " window") : i ? new Error("Request listener already exists for " + t + " on domain " + i.toString()) : new Error("Request listener already exists for " + t); var p, w, m = a.getOrSet(o, (function () { return {} })), v = be(m, t, (function () { return {} })), y = i.toString(); return ge(i) ? (p = be(v, "__domain_regex__", (function () { return [] }))).push(w = { regex: i, listener: r }) : v[y] = r, { cancel: function () { delete v[y], w && (p.splice(p.indexOf(w, 1)), p.length || delete v.__domain_regex__), Object.keys(v).length || delete m[t], o && !Object.keys(m).length && a.del(o) } } }({ name: e, win: t, domain: o }, { handler: n.handler, handleError: n.errorHandler || function (e) { throw e }, window: t, domain: o || "*", name: e }); return { cancel: function () { i.cancel() } } } Cn.postrobot_post_message = function (e, n, r) { 0 === r.indexOf("file:") && (r = "*"), e.postMessage(n, r) }, Cn.postrobot_global = function (e, n) { if (!function (e) { return (e = e || window).navigator.mockUserAgent || e.navigator.userAgent }(window).match(/MSIE|rv:11|trident|edge\/12|edge\/13/i)) throw new Error("Global messaging not needed for browser"); if (!C(e)) throw new Error("Post message through global disabled between different domain windows"); if (!1 !== M(window, e)) throw new Error("Can only use global to communicate between two different windows, not between frames"); var r = Xe(e); if (!r) throw new Error("Can not find postRobot global on foreign window"); r.receiveMessage({ source: window, origin: P(), data: n }) }; var zn = function e(n, r, t, o) { var i = (o = o || {}).domain || "*", a = o.timeout || -1, u = o.timeout || 5e3, c = o.fireAndForget || !1; return p.try((function () { if (function (e, n, r) { if (!e) throw new Error("Expected name"); if (r && "string" != typeof r && !Array.isArray(r) && !ge(r)) throw new TypeError("Can not send " + e + ". Expected domain " + JSON.stringify(r) + " to be a string, array, or regex"); if (I(n)) throw new Error("Can not send " + e + ". Target window is closed") }(r, n, i), function (e, n) { var r = z(n); if (r) return r === e; if (n === e) return !1; if (k(n) === n) return !1; for (var t = 0, o = T(e); t < o.length; t++)if (o[t] === n) return !0; return !1 }(window, n)) return function (e, n, r) { void 0 === n && (n = 5e3), void 0 === r && (r = "Window"); var t = function (e) { return tn("helloPromises").getOrSet(e, (function () { return new p })) }(e); return -1 !== n && (t = t.timeout(n, new Error(r + " did not load after " + n + "ms"))), t }(n, u) })).then((function (r) { return function (e, n, r, t) { var o = t.send; return p.try((function () { return "string" == typeof n ? n : p.try((function () { return r || un(e, { send: o }).then((function (e) { return e.domain })) })).then((function (e) { if (!U(n, n)) throw new Error("Domain " + he(n) + " does not match " + he(n)); return e })) })) }(n, i, (void 0 === r ? {} : r).domain, { send: e }) })).then((function (o) { var i = o, u = "postrobot_method" === r && t && "string" == typeof t.name ? t.name + "()" : r, s = new p, f = r + "_" + te(); if (!c) { var d = { name: r, win: n, domain: i, promise: s }; !function (e, n) { Qe("responseListeners").set(e, n) }(f, d); var l = tn("requestPromises").getOrSet(n, (function () { return [] })); l.push(s), s.catch((function () { !function (e) { Qe("erroredResponseListeners").set(e, !0) }(f), Tn(f) })); var h = function (e) { return tn("knownWindows").get(e, !1) }(n) ? 1e4 : 2e3, w = a, m = h, v = w, y = me((function () { return I(n) ? s.reject(new Error("Window closed for " + r + " before " + (d.ack ? "response" : "ack"))) : d.cancelled ? s.reject(new Error("Response listener was cancelled for " + r)) : (m = Math.max(m - 500, 0), -1 !== v && (v = Math.max(v - 500, 0)), d.ack || 0 !== m ? 0 === v ? s.reject(new Error("No response for postMessage " + u + " in " + P() + " in " + w + "ms")) : void 0 : s.reject(new Error("No ack for postMessage " + u + " in " + P() + " in " + h + "ms"))) }), 500); s.finally((function () { y.cancel(), l.splice(l.indexOf(s, 1)) })).catch(fe) } return Sn(n, i, { id: te(), origin: P(window), type: "postrobot_message_request", hash: f, name: r, data: t, fireAndForget: c }, { on: An, send: e }).then((function () { return c ? s.resolve() : s }), (function (e) { throw new Error("Send request message failed for " + u + " in " + P() + "\n\n" + le(e)) })) })) }; function Fn(e) { return bn.toProxyWindow(e, { send: zn }) } function Ln(e) { if (!C(e)) throw new Error("Can not get global for window on different domain"); return e.__zoid_9_0_82__ || (e.__zoid_9_0_82__ = {}), e.__zoid_9_0_82__ } function Mn(e, n) { try { return n(Ln(e)) } catch (e) { } } function Un(e) { return { get: function () { var n = this; return p.try((function () { if (n.source && n.source !== window) throw new Error("Can not call get on proxy object from a remote window"); return e })) } } } function qn(e) { return re(JSON.stringify(e)) } function Bn(e) { var n = Ln(e); return n.references = n.references || {}, n.references } function Jn(e) { var n, r, t = e.data, o = e.metaData, i = e.sender, a = e.receiver, u = e.passByReference, c = void 0 !== u && u, s = e.basic, f = void 0 !== s && s, d = Fn(a.win), l = f ? JSON.stringify(t) : On(d, a.domain, t, { on: An, send: zn }), h = c ? (n = l, r = te(), Bn(window)[r] = n, { type: "uid", uid: r }) : { type: "raw", val: l }; return { serializedData: qn({ sender: { domain: i.domain }, metaData: o, reference: h }), cleanReference: function () { var e, n; e = window, "uid" === (n = h).type && delete Bn(e)[n.uid] } } } function Hn(e) { var n, r, t = e.sender, o = e.basic, i = void 0 !== o && o, a = function (e) { return JSON.parse(function (e) { if ("function" == typeof atob) return decodeURIComponent([].map.call(atob(e), (function (e) { return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2) })).join("")); if ("undefined" != typeof Buffer) return Buffer.from(e, "base64").toString("utf8"); throw new Error("Can not find window.atob or Buffer") }(e)) }(e.data), u = a.reference, c = a.metaData; n = "function" == typeof t.win ? t.win({ metaData: c }) : t.win, r = "function" == typeof t.domain ? t.domain({ metaData: c }) : "string" == typeof t.domain ? t.domain : a.sender.domain; var s = function (e, n) { if ("raw" === n.type) return n.val; if ("uid" === n.type) return Bn(e)[n.uid]; throw new Error("Unsupported ref type: " + n.type) }(n, u); return { data: i ? JSON.parse(s) : function (e, n, r) { return Pn(e, n, r, { on: An, send: zn }) }(n, r, s), metaData: c, sender: { win: n, domain: r }, reference: u } } var Yn = { STRING: "string", OBJECT: "object", FUNCTION: "function", BOOLEAN: "boolean", NUMBER: "number", ARRAY: "array" }, Vn = { JSON: "json", DOTIFY: "dotify", BASE64: "base64" }, Zn = m, Gn = { RENDER: "zoid-render", RENDERED: "zoid-rendered", DISPLAY: "zoid-display", ERROR: "zoid-error", CLOSE: "zoid-close", DESTROY: "zoid-destroy", PROPS: "zoid-props", RESIZE: "zoid-resize", FOCUS: "zoid-focus" }; function $n(e) { return "__zoid__" + e.name + "__" + e.serializedPayload + "__" } function Xn(e) { if (!e) throw new Error("No window name"); var n = e.split("__"), r = n[1], t = n[2], o = n[3]; if ("zoid" !== r) throw new Error("Window not rendered by zoid - got " + r); if (!t) throw new Error("Expected component name"); if (!o) throw new Error("Expected serialized payload ref"); return { name: t, serializedInitialPayload: o } } var Kn = ce((function (e) { var n = Hn({ data: Xn(e).serializedInitialPayload, sender: { win: function (e) { return function (e) { if ("opener" === e.type) return _e("opener", _(window)); if ("parent" === e.type && "number" == typeof e.distance) return _e("parent", (n = window, void 0 === (r = e.distance) && (r = 1), function (e, n) { void 0 === n && (n = 1); for (var r = e, t = 0; t < n; t++) { if (!r) return; r = E(r) } return r }(n, L(n) - r))); var n, r; if ("global" === e.type && e.uid && "string" == typeof e.uid) { var t = function () { var n = e.uid, r = z(window); if (!r) throw new Error("Can not find ancestor window"); for (var t = 0, o = N(r); t < o.length; t++) { var i = o[t]; if (C(i)) { var a = Mn(i, (function (e) { return e.windows && e.windows[n] })); if (a) return { v: a } } } }(); if ("object" == typeof t) return t.v } else if ("name" === e.type) { var o = e.name; return _e("namedWindow", function (e, n) { return A(e, n) || function e(n, r) { var t = A(n, r); if (t) return t; for (var o = 0, i = T(n); o < i.length; o++) { var a = e(i[o], r); if (a) return a } }(k(e) || e, n) }(_e("ancestor", z(window)), o)) } throw new Error("Unable to find " + e.type + " parent component window") }(e.metaData.windowRef) } } }); return { parent: n.sender, payload: n.data, reference: n.reference } })); function Qn() { return Kn(window.name) } function er(e, n) { if (void 0 === n && (n = window), e === E(n)) return { type: "parent", distance: L(e) }; if (e === _(n)) return { type: "opener" }; if (C(e) && (t = e) !== k(t)) { var r = S(e).name; if (r) return { type: "name", name: r } } var t } function nr(e, n, r, t, o) { if (!e.hasOwnProperty(r)) return t; var i = e[r]; return "function" == typeof i.childDecorate ? i.childDecorate({ value: t, uid: o.uid, tag: o.tag, close: o.close, focus: o.focus, onError: o.onError, onProps: o.onProps, resize: o.resize, getParent: o.getParent, getParentDomain: o.getParentDomain, show: o.show, hide: o.hide, export: o.export, getSiblings: o.getSiblings }) : t } function rr() { return p.try((function () { window.focus() })) } function tr() { return p.try((function () { window.close() })) } var or = function () { return fe }, ir = function (e) { return de(e.value) }; function ar(e, n, r) { for (var t = 0, o = Object.keys(e); t < o.length; t++) { var i = o[t], a = n[i]; a && r(i, a, e[i]) } } function ur(e, n, r) { var t = {}; return p.all(function (e, n, o) { var i = []; return ar(e, n, (function (e, n, o) { var a = function (e, n, o) { return p.resolve().then((function () { var i, a; if (null != o) { var u = (i = {}, i.get = n.queryParam, i.post = n.bodyParam, i)[r], c = (a = {}, a.get = n.queryValue, a.post = n.bodyValue, a)[r]; if (u) return p.hash({ finalParam: p.try((function () { return "function" == typeof u ? u({ value: o }) : "string" == typeof u ? u : e })), finalValue: p.try((function () { return "function" == typeof c && ye(o) ? c({ value: o }) : o })) }).then((function (r) { var o, i = r.finalParam, a = r.finalValue; if ("boolean" == typeof a) o = a.toString(); else if ("string" == typeof a) o = a.toString(); else if ("object" == typeof a && null !== a) { if (n.serialization === Vn.JSON) o = JSON.stringify(a); else if (n.serialization === Vn.BASE64) o = re(JSON.stringify(a)); else if (n.serialization === Vn.DOTIFY || !n.serialization) { o = function e(n, r, t) { for (var o in void 0 === r && (r = ""), void 0 === t && (t = {}), r = r ? r + "." : r, n) n.hasOwnProperty(o) && null != n[o] && "function" != typeof n[o] && (n[o] && Array.isArray(n[o]) && n[o].length && n[o].every((function (e) { return "object" != typeof e })) ? t["" + r + o + "[]"] = n[o].join(",") : n[o] && "object" == typeof n[o] ? t = e(n[o], "" + r + o, t) : t["" + r + o] = n[o].toString()); return t }(a, e); for (var u = 0, c = Object.keys(o); u < c.length; u++) { var s = c[u]; t[s] = o[s] } return } } else "number" == typeof a && (o = a.toString()); t[i] = o })) } })) }(e, n, o); i.push(a) })), i }(n, e)).then((function () { return t })) } function cr(e) { var n, r, t, o, a, u, c, s = e.uid, f = e.options, d = e.overrides, l = void 0 === d ? {} : d, h = e.parentWin, w = void 0 === h ? window : h, m = f.propsDef, v = f.containerTemplate, y = f.prerenderTemplate, g = f.tag, b = f.name, E = f.attributes, _ = f.dimensions, x = f.autoResize, O = f.url, D = f.domain, T = f.exports, W = new p, k = [], N = Ee(), R = {}, j = { visible: !0 }, A = l.event ? l.event : (n = {}, r = {}, t = { on: function (e, n) { var t = r[e] = r[e] || []; t.push(n); var o = !1; return { cancel: function () { o || (o = !0, t.splice(t.indexOf(n), 1)) } } }, once: function (e, n) { var r = t.on(e, (function () { r.cancel(), n() })); return r }, trigger: function (e) { for (var n = arguments.length, t = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)t[o - 1] = arguments[o]; var i = r[e], a = []; if (i) for (var u = function (e) { var n = i[e]; a.push(p.try((function () { return n.apply(void 0, t) }))) }, c = 0; c < i.length; c++)u(c); return p.all(a).then(fe) }, triggerOnce: function (e) { if (n[e]) return p.resolve(); n[e] = !0; for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)o[i - 1] = arguments[i]; return t.trigger.apply(t, [e].concat(o)) }, reset: function () { r = {} } }), F = l.props ? l.props : {}, J = l.onError, H = l.getProxyContainer, Y = l.show, V = l.hide, Z = l.close, G = l.renderContainer, $ = l.getProxyWindow, X = l.setProxyWin, K = l.openFrame, Q = l.openPrerenderFrame, ee = l.prerender, ne = l.open, re = l.openPrerender, oe = l.watchForUnload, ie = l.getInternalState, ae = l.setInternalState, ue = function () { return p.try((function () { return l.resolveInitPromise ? l.resolveInitPromise() : W.resolve() })) }, se = function (e) { return p.try((function () { return l.rejectInitPromise ? l.rejectInitPromise(e) : W.reject(e) })) }, he = function (e) { for (var n = {}, r = 0, t = Object.keys(F); r < t.length; r++) { var o = t[r], i = m[o]; i && !1 === i.sendToChild || i && i.sameDomain && !U(e, P(window)) || (n[o] = F[o]) } return p.hash(n) }, we = function () { return p.try((function () { return ie ? ie() : j })) }, ge = function (e) { return p.try((function () { return ae ? ae(e) : j = i({}, j, e) })) }, be = function () { return $ ? $() : p.try((function () { var e = F.window; if (e) { var n = Fn(e); return N.register((function () { return e.close() })), n } return new bn({ send: zn }) })) }, _e = function (e) { return H ? H(e) : p.try((function () { return Re(e) })).then((function (e) { return He(e) && (e = function e(n) { var r = function (e) { var n = function (e) { for (; e.parentNode;)e = e.parentNode; if (He(e)) return e }(e); if (n && n.host) return n.host }(n); if (!r) throw new Error("Element is not in shadow dom"); var t = "shadow-slot-" + te(), o = document.createElement("slot"); o.setAttribute("name", t), n.appendChild(o); var i = document.createElement("div"); return i.setAttribute("slot", t), r.appendChild(i), He(r) ? e(i) : i }(e)), Un(e) })) }, xe = function (e) { return X ? X(e) : p.try((function () { o = e })) }, Oe = function () { return Y ? Y() : p.hash({ setState: ge({ visible: !0 }), showElement: a ? a.get().then(Me) : null }).then(fe) }, Pe = function () { return V ? V() : p.hash({ setState: ge({ visible: !1 }), showElement: a ? a.get().then(Ue) : null }).then(fe) }, Ce = function () { return "function" == typeof O ? O({ props: F }) : O }, Se = function () { return "function" == typeof E ? E({ props: F }) : E }, De = function () { return q(Ce()) }, ke = function (e, n) { var r = n.windowName; return K ? K(e, { windowName: r }) : p.try((function () { if (e === Zn.IFRAME) return Un(Fe({ attributes: i({ name: r, title: b }, Se().iframe) })) })) }, je = function (e) { return Q ? Q(e) : p.try((function () { if (e === Zn.IFRAME) return Un(Fe({ attributes: i({ name: "__zoid_prerender_frame__" + b + "_" + te() + "__", title: "prerender__" + b }, Se().iframe) })) })) }, Ie = function (e, n, r) { return re ? re(e, n, r) : p.try((function () { if (e === Zn.IFRAME) { if (!r) throw new Error("Expected proxy frame to be passed"); return r.get().then((function (e) { return N.register((function () { return qe(e) })), ze(e).then((function (e) { return S(e) })).then((function (e) { return Fn(e) })) })) } throw new Error("No render context available for " + e) })) }, Ae = function () { return p.try((function () { if (o) return p.all([A.trigger(Gn.FOCUS), o.focus()]).then(fe) })) }, Ye = function () { var e = Ln(window); return e.windows = e.windows || {}, e.windows[s] = window, N.register((function () { delete e.windows[s] })), s }, Ve = function (e, n, r, t) { if (n === P(window)) return { type: "global", uid: Ye() }; if (e !== window) throw new Error("Can not construct cross-domain window reference for different target window"); if (F.window) { var o = t.getWindow(); if (!o) throw new Error("Can not construct cross-domain window reference for lazy window prop"); if (z(o) !== window) throw new Error("Can not construct cross-domain window reference for window prop with different ancestor") } if (r === Zn.POPUP) return { type: "opener" }; if (r === Zn.IFRAME) return { type: "parent", distance: L(window) }; throw new Error("Can not construct window reference for child") }, Ze = function (e, n) { return p.try((function () { c = e, u = n, ue(), N.register((function () { return n.close.fireAndForget().catch(fe) })) })) }, Ge = function (e) { var n = e.width, r = e.height; return p.try((function () { A.trigger(Gn.RESIZE, { width: n, height: r }) })) }, $e = function (e) { return p.try((function () { return A.trigger(Gn.DESTROY) })).catch(fe).then((function () { return N.all(e) })).then((function () { W.asyncReject(e || new Error("Component destroyed")) })) }, Xe = ce((function (e) { return p.try((function () { if (Z) { if (I(Z.__source__)) return; return Z() } return p.try((function () { return A.trigger(Gn.CLOSE) })).then((function () { return $e(e || new Error("Component closed")) })) })) })), Ke = function (e, n) { var r = n.proxyWin, t = n.proxyFrame, o = n.windowName; return ne ? ne(e, { proxyWin: r, proxyFrame: t, windowName: o }) : p.try((function () { if (e === Zn.IFRAME) { if (!t) throw new Error("Expected proxy frame to be passed"); return t.get().then((function (e) { return ze(e).then((function (n) { return N.register((function () { return qe(e) })), N.register((function () { return function (e) { for (var n = 0, r = tn("requestPromises").get(e, []); n < r.length; n++)r[n].reject(new Error("Window " + (I(e) ? "closed" : "cleaned up") + " before response")).catch(fe) }(n) })), n })) })) } throw new Error("No render context available for " + e) })).then((function (e) { return r.setWindow(e, { send: zn }), r.setName(o).then((function () { return r })) })) }, Qe = function () { return p.try((function () { var e = Le(window, "unload", de((function () { $e(new Error("Window navigated away")) }))), n = B(w, $e, 3e3); if (N.register(n.cancel), N.register(e.cancel), oe) return oe() })) }, en = function (e) { var n = !1; return e.isClosed().then((function (r) { return r ? (n = !0, Xe(new Error("Detected component window close"))) : p.delay(200).then((function () { return e.isClosed() })).then((function (e) { if (e) return n = !0, Xe(new Error("Detected component window close")) })) })).then((function () { return n })) }, nn = function (e) { return J ? J(e) : p.try((function () { if (-1 === k.indexOf(e)) return k.push(e), W.asyncReject(e), A.trigger(Gn.ERROR, e) })) }, rn = new p, on = function (e) { return p.try((function () { rn.resolve(e) })) }; Ze.onError = nn; var an = function (e, n) { return e({ uid: s, container: n.container, context: n.context, doc: n.doc, frame: n.frame, prerenderFrame: n.prerenderFrame, focus: Ae, close: Xe, state: R, props: F, tag: g, dimensions: "function" == typeof _ ? _({ props: F }) : _, event: A }) }, un = function (e, n) { var r = n.context; return ee ? ee(e, { context: r }) : p.try((function () { if (y) { var n = e.getWindow(); if (n && C(n) && function (e) { try { if (!e.location.href) return !0; if ("about:blank" === e.location.href) return !0 } catch (e) { } return !1 }(n)) { var t = (n = S(n)).document, o = an(y, { context: r, doc: t }); if (o) { if (o.ownerDocument !== t) throw new Error("Expected prerender template to have been created with document from child window"); !function (e, n) { var r = n.tagName.toLowerCase(); if ("html" !== r) throw new Error("Expected element to be html, got " + r); for (var t = e.document.documentElement, o = 0, i = ve(t.children); o < i.length; o++)t.removeChild(i[o]); for (var a = 0, u = ve(n.children); a < u.length; a++)t.appendChild(u[a]) }(n, o); var i = x.width, a = void 0 !== i && i, u = x.height, c = void 0 !== u && u, s = x.element, f = void 0 === s ? "body" : s; if ((f = Ne(f, t)) && (a || c)) { var d = Je(f, (function (e) { Ge({ width: a ? e.width : void 0, height: c ? e.height : void 0 }) }), { width: a, height: c, win: n }); A.on(Gn.RENDERED, d.cancel) } } } } })) }, cn = function (e, n) { var r = n.proxyFrame, t = n.proxyPrerenderFrame, o = n.context, i = n.rerender; return G ? G(e, { proxyFrame: r, proxyPrerenderFrame: t, context: o, rerender: i }) : p.hash({ container: e.get(), frame: r ? r.get() : null, prerenderFrame: t ? t.get() : null, internalState: we() }).then((function (e) { var n = e.container, r = e.internalState.visible, t = an(v, { context: o, container: n, frame: e.frame, prerenderFrame: e.prerenderFrame, doc: document }); if (t) { r || Ue(t), We(n, t); var u = function (e, n) { n = de(n); var r, t, o, i = !1, a = [], u = function () { i = !0; for (var e = 0; e < a.length; e++)a[e].disconnect(); r && r.cancel(), o && o.removeEventListener("unload", c), t && qe(t) }, c = function () { i || (n(), u()) }; if (Be(e)) return c(), { cancel: u }; if (window.MutationObserver) for (var s = e.parentElement; s;) { var f = new window.MutationObserver((function () { Be(e) && c() })); f.observe(s, { childList: !0 }), a.push(f), s = s.parentElement } return (t = document.createElement("iframe")).setAttribute("name", "__detect_close_" + te() + "__"), t.style.display = "none", ze(t).then((function (e) { (o = S(e)).addEventListener("unload", c) })), e.appendChild(t), r = me((function () { Be(e) && c() }), 1e3), { cancel: u } }(t, (function () { var e = new Error("Detected container element removed from DOM"); return p.delay(1).then((function () { if (!Be(t)) return N.all(e), i().then(ue, se); Xe(e) })) })); return N.register((function () { return u.cancel() })), N.register((function () { return qe(t) })), a = Un(t) } })) }, sn = function () { return { state: R, event: A, close: Xe, focus: Ae, resize: Ge, onError: nn, updateProps: dn, show: Oe, hide: Pe } }, fn = function (e, n) { void 0 === n && (n = !1); var r = sn(); !function (e, n, r, t, o) { void 0 === o && (o = !1), pe(n, r = r || {}); for (var i = o ? [] : [].concat(Object.keys(e)), a = 0, u = Object.keys(r); a < u.length; a++) { var c = u[a]; -1 === i.indexOf(c) && i.push(c) } for (var s = [], f = t.state, d = t.close, l = t.focus, h = t.event, p = t.onError, w = 0; w < i.length; w++) { var m = i[w], v = e[m], y = r[m]; if (v) { var g = v.alias; if (g && (!ye(y) && ye(r[g]) && (y = r[g]), s.push(g)), v.value && (y = v.value({ props: n, state: f, close: d, focus: l, event: h, onError: p })), !ye(y) && v.default && (y = v.default({ props: n, state: f, close: d, focus: l, event: h, onError: p })), ye(y) && ("array" === v.type ? !Array.isArray(y) : typeof y !== v.type)) throw new TypeError("Prop is not of type " + v.type + ": " + m); n[m] = y } } for (var b = 0; b < s.length; b++)delete n[s[b]]; ar(n, e, (function (e, r, t) { if (r && ye(t) && r.decorate) { var o = r.decorate({ value: t, props: n, state: f, close: d, focus: l, event: h, onError: p }); n[e] = o } })); for (var E = 0, _ = Object.keys(e); E < _.length; E++) { var x = _[E]; if (!1 !== e[x].required && !ye(n[x])) throw new Error('Expected prop "' + x + '" to be defined') } }(m, F, e, r, n) }, dn = function (e) { return fn(e, !0), W.then((function () { var e = u, n = o; if (e && n && c) return he(c).then((function (r) { return e.updateProps(r).catch((function (e) { return en(n).then((function (n) { if (!n) throw e })) })) })) })) }; return { init: function () { A.on(Gn.RENDER, (function () { return F.onRender() })), A.on(Gn.DISPLAY, (function () { return F.onDisplay() })), A.on(Gn.RENDERED, (function () { return F.onRendered() })), A.on(Gn.CLOSE, (function () { return F.onClose() })), A.on(Gn.DESTROY, (function () { return F.onDestroy() })), A.on(Gn.RESIZE, (function () { return F.onResize() })), A.on(Gn.FOCUS, (function () { return F.onFocus() })), A.on(Gn.PROPS, (function (e) { return F.onProps(e) })), A.on(Gn.ERROR, (function (e) { return F && F.onError ? F.onError(e) : se(e).then((function () { setTimeout((function () { throw e }), 1) })) })), N.register(A.reset) }, render: function (e) { var n = e.target, r = e.container, t = e.context, i = e.rerender; return p.try((function () { var e = De(), a = D || De(); !function (e, n, r) { if (e !== window) { if (!M(window, e)) throw new Error("Can only renderTo an adjacent frame"); var t = P(); if (!U(n, t) && !C(e)) throw new Error("Can not render remotely to " + n.toString() + " - can only render to " + t); if (r && "string" != typeof r) throw new Error("Container passed to renderTo must be a string selector, got " + typeof r + " }") } }(n, a, r); var u = p.try((function () { if (n !== window) return function (e, n) { for (var r = {}, t = 0, o = Object.keys(F); t < o.length; t++) { var i = o[t], a = m[i]; a && a.allowDelegate && (r[i] = F[i]) } var u = zn(n, "zoid_delegate_" + b, { uid: s, overrides: { props: r, event: A, close: Xe, onError: nn, getInternalState: we, setInternalState: ge, resolveInitPromise: ue, rejectInitPromise: se } }).then((function (e) { var r = e.data.parent; return N.register((function (e) { if (!I(n)) return r.destroy(e) })), r.getDelegateOverrides() })).catch((function (e) { throw new Error("Unable to delegate rendering. Possibly the component is not loaded in the target window.\n\n" + le(e)) })); return H = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.getProxyContainer.apply(e, n) })) }, G = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.renderContainer.apply(e, n) })) }, Y = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.show.apply(e, n) })) }, V = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.hide.apply(e, n) })) }, oe = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.watchForUnload.apply(e, n) })) }, e === Zn.IFRAME && ($ = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.getProxyWindow.apply(e, n) })) }, K = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.openFrame.apply(e, n) })) }, Q = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.openPrerenderFrame.apply(e, n) })) }, ee = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.prerender.apply(e, n) })) }, ne = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.open.apply(e, n) })) }, re = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.openPrerender.apply(e, n) })) }), u }(t, n) })), c = F.window, d = Qe(), l = ur(m, F, "get").then((function (e) { return function (e, n) { var r, t, o = n.query || {}, i = n.hash || {}, a = e.split("#"); t = a[1]; var u = (r = a[0]).split("?"); r = u[0]; var c = Te(u[1], o), s = Te(t, i); return c && (r = r + "?" + c), s && (r = r + "#" + s), r }(function (e) { if (0 !== q(e).indexOf("mock:")) return e; throw new Error("Mock urls not supported out of test mode") }(Ce()), { query: e }) })), h = ur(m, F, "post"), w = A.trigger(Gn.RENDER), v = _e(r), y = be(), E = y.then((function (r) { return function (e) { var n = void 0 === e ? {} : e, r = n.proxyWin, t = n.initialChildDomain, o = n.childDomainMatch, i = n.target, a = void 0 === i ? window : i, u = n.context; return function (e) { var n = void 0 === e ? {} : e, r = n.proxyWin, t = n.childDomainMatch, o = n.context; return he(n.initialChildDomain).then((function (e) { return { uid: s, context: o, tag: g, childDomainMatch: t, version: "9_0_82", props: e, exports: (n = r, { init: function (e) { return Ze(this.origin, e) }, close: Xe, checkClose: function () { return en(n) }, resize: Ge, onError: nn, show: Oe, hide: Pe, export: on }) }; var n })) }({ proxyWin: r, initialChildDomain: t, childDomainMatch: o, context: u }).then((function (e) { var n = Jn({ data: e, metaData: { windowRef: Ve(a, t, u, r) }, sender: { domain: P(window) }, receiver: { win: r, domain: o }, passByReference: t === P() }), i = n.serializedData; return N.register(n.cleanReference), i })) }({ proxyWin: (o = { proxyWin: r, initialChildDomain: e, childDomainMatch: a, target: n, context: t }).proxyWin, initialChildDomain: o.initialChildDomain, childDomainMatch: o.childDomainMatch, target: o.target, context: o.context }).then((function (e) { return $n({ name: b, serializedPayload: e }) })); var o })), _ = E.then((function (e) { return ke(t, { windowName: e }) })), x = je(t), O = p.hash({ proxyContainer: v, proxyFrame: _, proxyPrerenderFrame: x }).then((function (e) { return cn(e.proxyContainer, { context: t, proxyFrame: e.proxyFrame, proxyPrerenderFrame: e.proxyPrerenderFrame, rerender: i }) })).then((function (e) { return e })), S = p.hash({ windowName: E, proxyFrame: _, proxyWin: y }).then((function (e) { var n = e.proxyWin; return c ? n : Ke(t, { windowName: e.windowName, proxyWin: n, proxyFrame: e.proxyFrame }) })), T = p.hash({ proxyWin: S, proxyPrerenderFrame: x }).then((function (e) { return Ie(t, e.proxyWin, e.proxyPrerenderFrame) })), k = S.then((function (e) { return o = e, xe(e) })), R = p.hash({ proxyPrerenderWin: T, state: k }).then((function (e) { return un(e.proxyPrerenderWin, { context: t }) })), j = p.hash({ proxyWin: S, windowName: E }).then((function (e) { if (c) return e.proxyWin.setName(e.windowName) })), z = p.hash({ body: h }).then((function (e) { return f.method ? f.method : Object.keys(e.body).length ? "post" : "get" })), L = p.hash({ proxyWin: S, windowUrl: l, body: h, method: z, windowName: j, prerender: R }).then((function (e) { return e.proxyWin.setLocation(e.windowUrl, { method: e.method, body: e.body }) })), B = S.then((function (e) { !function e(n, r) { var t = !1; return N.register((function () { t = !0 })), p.delay(2e3).then((function () { return n.isClosed() })).then((function (o) { if (!t) return o ? Xe(new Error("Detected " + r + " close")) : e(n, r) })) }(e, t) })), J = p.hash({ container: O, prerender: R }).then((function () { return A.trigger(Gn.DISPLAY) })), Z = S.then((function (e) { })), X = L.then((function () { return p.try((function () { var e = F.timeout; if (e) return W.timeout(e, new Error("Loading component timed out after " + e + " milliseconds")) })) })), te = W.then((function () { return A.trigger(Gn.RENDERED) })); return p.hash({ initPromise: W, buildUrlPromise: l, onRenderPromise: w, getProxyContainerPromise: v, openFramePromise: _, openPrerenderFramePromise: x, renderContainerPromise: O, openPromise: S, openPrerenderPromise: T, setStatePromise: k, prerenderPromise: R, loadUrlPromise: L, buildWindowNamePromise: E, setWindowNamePromise: j, watchForClosePromise: B, onDisplayPromise: J, openBridgePromise: Z, runTimeoutPromise: X, onRenderedPromise: te, delegatePromise: u, watchForUnloadPromise: d }) })).catch((function (e) { return p.all([nn(e), $e(e)]).then((function () { throw e }), (function () { throw e })) })).then(fe) }, destroy: $e, getProps: function () { return F }, setProps: fn, export: on, getHelpers: sn, getDelegateOverrides: function () { return p.try((function () { return { getProxyContainer: _e, show: Oe, hide: Pe, renderContainer: cn, getProxyWindow: be, watchForUnload: Qe, openFrame: ke, openPrerenderFrame: je, prerender: un, open: Ke, openPrerender: Ie, setProxyWin: xe } })) }, getExports: function () { return T({ getExports: function () { return rn } }) } } } function sr(e) { var n = e.uid, r = e.frame, t = e.prerenderFrame, o = e.doc, i = e.props, a = e.event, u = e.dimensions, c = u.width, s = u.height; if (r && t) { var f = o.createElement("div"); f.setAttribute("id", n); var d = o.createElement("style"); return i.cspNonce && d.setAttribute("nonce", i.cspNonce), d.appendChild(o.createTextNode("\n            #" + n + " {\n                display: inline-block;\n                position: relative;\n                width: " + c + ";\n                height: " + s + ";\n            }\n\n            #" + n + " > iframe {\n                display: inline-block;\n                position: absolute;\n                width: 100%;\n                height: 100%;\n                top: 0;\n                left: 0;\n                transition: opacity .2s ease-in-out;\n            }\n\n            #" + n + " > iframe.zoid-invisible {\n                opacity: 0;\n            }\n\n            #" + n + " > iframe.zoid-visible {\n                opacity: 1;\n        }\n        ")), f.appendChild(r), f.appendChild(t), f.appendChild(d), t.classList.add("zoid-visible"), r.classList.add("zoid-invisible"), a.on(Gn.RENDERED, (function () { t.classList.remove("zoid-visible"), t.classList.add("zoid-invisible"), r.classList.remove("zoid-invisible"), r.classList.add("zoid-visible"), setTimeout((function () { qe(t) }), 1) })), a.on(Gn.RESIZE, (function (e) { var n = e.width, r = e.height; "number" == typeof n && (f.style.width = $e(n)), "number" == typeof r && (f.style.height = $e(r)) })), f } } var fr = Ee(), dr = Ee(); function lr(e) { var n, r, t = function (e) { var n = e.tag, r = e.url, t = e.domain, o = e.bridgeUrl, a = e.props, u = void 0 === a ? {} : a, c = e.dimensions, s = void 0 === c ? {} : c, f = e.autoResize, d = void 0 === f ? {} : f, l = e.allowedParentDomains, h = void 0 === l ? "*" : l, p = e.attributes, w = void 0 === p ? {} : p, m = e.defaultContext, v = void 0 === m ? Zn.IFRAME : m, y = e.containerTemplate, g = void 0 === y ? sr : y, b = e.prerenderTemplate, E = void 0 === b ? null : b, _ = e.validate, x = e.eligible, O = void 0 === x ? function () { return { eligible: !0 } } : x, P = e.logger, S = void 0 === P ? { info: fe } : P, D = e.exports, T = void 0 === D ? fe : D, W = e.method, k = e.children, N = void 0 === k ? function () { return {} } : k, R = n.replace(/-/g, "_"), j = i({}, { window: { type: Yn.OBJECT, sendToChild: !1, required: !1, allowDelegate: !0, validate: function (e) { var n = e.value; if (!J(n) && !bn.isProxyWindow(n)) throw new Error("Expected Window or ProxyWindow"); if (J(n)) { if (I(n)) throw new Error("Window is closed"); if (!C(n)) throw new Error("Window is not same domain") } }, decorate: function (e) { return Fn(e.value) } }, timeout: { type: Yn.NUMBER, required: !1, sendToChild: !1 }, cspNonce: { type: Yn.STRING, required: !1 }, onDisplay: { type: Yn.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: or, decorate: ir }, onRendered: { type: Yn.FUNCTION, required: !1, sendToChild: !1, default: or, decorate: ir }, onRender: { type: Yn.FUNCTION, required: !1, sendToChild: !1, default: or, decorate: ir }, onClose: { type: Yn.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: or, decorate: ir }, onDestroy: { type: Yn.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: or, decorate: ir }, onResize: { type: Yn.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: or }, onFocus: { type: Yn.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: or }, close: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.close } }, focus: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.focus } }, resize: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.resize } }, uid: { type: Yn.STRING, required: !1, sendToChild: !1, childDecorate: function (e) { return e.uid } }, tag: { type: Yn.STRING, required: !1, sendToChild: !1, childDecorate: function (e) { return e.tag } }, getParent: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.getParent } }, getParentDomain: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.getParentDomain } }, show: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.show } }, hide: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.hide } }, export: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.export } }, onError: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.onError } }, onProps: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.onProps } }, getSiblings: { type: Yn.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.getSiblings } } }, u); if (!g) throw new Error("Container template required"); return { name: R, tag: n, url: r, domain: t, bridgeUrl: o, method: W, propsDef: j, dimensions: s, autoResize: d, allowedParentDomains: h, attributes: w, defaultContext: v, containerTemplate: g, prerenderTemplate: E, validate: _, logger: S, eligible: O, children: N, exports: "function" == typeof T ? T : function (e) { for (var n = e.getExports, r = {}, t = function (e, t) { var o = t[e], i = T[o].type, a = n().then((function (e) { return e[o] })); r[o] = i === Yn.FUNCTION ? function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return a.then((function (e) { return e.apply(void 0, n) })) } : a }, o = 0, i = Object.keys(T); o < i.length; o++)t(o, i); return r } } }(e), o = t.name, a = t.tag, u = t.defaultContext, c = t.eligible, s = t.children, f = Ln(window), d = [], l = function () { if (function (e) { try { return Xn(window.name).name === e } catch (e) { } return !1 }(o)) { var e = Qn().payload; if (e.tag === a && U(e.childDomainMatch, P())) return !0 } return !1 }, h = ce((function () { if (l()) { if (window.xprops) throw delete f.components[a], new Error("Can not register " + o + " as child - child already registered"); var e = function (e) { var n, r = e.tag, t = e.propsDef, o = e.autoResize, i = e.allowedParentDomains, a = [], u = Qn(), c = u.parent, s = u.payload, f = c.win, d = c.domain, l = new p, h = s.version, w = s.uid, m = s.exports, v = s.context, y = s.props; if ("9_0_82" !== h) throw new Error("Parent window has zoid version " + h + ", child window has version 9_0_82"); var g = m.show, b = m.hide, E = m.close, _ = m.onError, x = m.checkClose, O = m.export, D = m.resize, T = m.init, W = function () { return f }, k = function () { return d }, R = function (e) { a.push(e) }, j = function (e) { return D.fireAndForget({ width: e.width, height: e.height }) }, I = function (e) { return l.resolve(e), O(e) }, A = function (e) { var t = (void 0 === e ? {} : e).anyParent, o = [], i = n.parent; if (void 0 === t && (t = !i), !t && !i) throw new Error("No parent found for " + r + " child"); for (var a = 0, u = N(window); a < u.length; a++) { var c = u[a]; if (C(c)) { var s = S(c).xprops; if (s && W() === s.getParent()) { var f = s.parent; if (t || !i || f && f.uid === i.uid) { var d = Mn(c, (function (e) { return e.exports })); o.push({ props: s, exports: d }) } } } } return o }, z = function (e, o, i) { void 0 === i && (i = !1); var u = function (e, n, r, t, o, i) { void 0 === i && (i = !1); for (var a = {}, u = 0, c = Object.keys(r); u < c.length; u++) { var s = c[u], f = n[s]; if (!f || !f.sameDomain || t === P(window) && C(e)) { var d = nr(n, 0, s, r[s], o); a[s] = d, f && f.alias && !a[f.alias] && (a[f.alias] = d) } } if (!i) for (var l = 0, h = Object.keys(n); l < h.length; l++) { var p = h[l]; r.hasOwnProperty(p) || (a[p] = nr(n, 0, p, void 0, o)) } return a }(f, t, e, o, { tag: r, show: g, hide: b, close: E, focus: rr, onError: _, resize: j, getSiblings: A, onProps: R, getParent: W, getParentDomain: k, uid: w, export: I }, i); n ? pe(n, u) : n = u; for (var c = 0; c < a.length; c++)(0, a[c])(n) }, F = function (e) { return p.try((function () { return z(e, d, !0) })) }; return { init: function () { return p.try((function () { return C(f) && function (e) { var n = e.componentName, r = e.parentComponentWindow, t = Hn({ data: Xn(window.name).serializedInitialPayload, sender: { win: r }, basic: !0 }), o = t.sender; if ("uid" === t.reference.type || "global" === t.metaData.windowRef.type) { var i = Jn({ data: t.data, metaData: { windowRef: er(r) }, sender: { domain: o.domain }, receiver: { win: window, domain: P() }, basic: !0 }); window.name = $n({ name: n, serializedPayload: i.serializedData }) } }({ componentName: e.name, parentComponentWindow: f }), Ln(window).exports = e.exports({ getExports: function () { return l } }), function (e, n) { if (!U(e, n)) throw new Error("Can not be rendered by domain: " + n) }(i, d), sn(f), window.addEventListener("beforeunload", (function () { x.fireAndForget() })), window.addEventListener("unload", (function () { x.fireAndForget() })), B(f, (function () { tr() })), T({ updateProps: F, close: tr }) })).then((function () { return (e = o.width, n = void 0 !== e && e, r = o.height, t = void 0 !== r && r, i = o.element, Re(void 0 === i ? "body" : i).catch(fe).then((function (e) { return { width: n, height: t, element: e } }))).then((function (e) { var n = e.width, r = e.height, t = e.element; t && (n || r) && v !== Zn.POPUP && Je(t, (function (e) { j({ width: n ? e.width : void 0, height: r ? e.height : void 0 }) }), { width: n, height: r }) })); var e, n, r, t, i })).catch((function (e) { _(e) })) }, getProps: function () { return n || (z(y, d), n) } } }(t); return e.init(), e } })); if (h(), n = An("zoid_allow_delegate_" + o, (function () { return !0 })), r = An("zoid_delegate_" + o, (function (e) { var n = e.data; return { parent: cr({ uid: n.uid, options: t, overrides: n.overrides, parentWin: e.source }) } })), dr.register(n.cancel), dr.register(r.cancel), f.components = f.components || {}, f.components[a]) throw new Error("Can not register multiple components with the same tag: " + a); return f.components[a] = !0, { init: function e(n) { var r, f = "zoid-" + a + "-" + te(), l = n || {}, h = c({ props: l }), w = h.eligible, m = h.reason, v = l.onDestroy; l.onDestroy = function () { if (r && w && d.splice(d.indexOf(r), 1), v) return v.apply(void 0, arguments) }; var y = cr({ uid: f, options: t }); y.init(), w ? y.setProps(l) : l.onDestroy && l.onDestroy(), fr.register((function (e) { return y.destroy(e || new Error("zoid destroyed all components")) })); var g = function (n) { var r = (void 0 === n ? {} : n).decorate; return e((void 0 === r ? we : r)(l)) }, b = function (e, n, t) { return p.try((function () { if (!w) { var n = new Error(m || o + " component is not eligible"); return y.destroy(n).then((function () { throw n })) } if (!J(e)) throw new Error("Must pass window to renderTo"); return function (e, n) { return p.try((function () { if (e.window) return Fn(e.window).getType(); if (n) { if (n !== Zn.IFRAME && n !== Zn.POPUP) throw new Error("Unrecognized context: " + n); return n } return u })) }(l, t) })).then((function (o) { if (n = function (e, n) { if (n) { if ("string" != typeof n && !ke(n)) throw new TypeError("Expected string or element selector to be passed"); return n } if (e === Zn.POPUP) return "body"; throw new Error("Expected element to be passed to render iframe") }(o, n), e !== window && "string" != typeof n) throw new Error("Must pass string element when rendering to another window"); return y.render({ target: e, container: n, context: o, rerender: function () { var o = g(); return pe(r, o), o.renderTo(e, n, t) } }) })).catch((function (e) { return y.destroy(e).then((function () { throw e })) })) }; return r = i({}, y.getExports(), y.getHelpers(), function () { for (var e = s(), n = {}, r = function (r, t) { var o = t[r], a = e[o]; n[o] = function (e) { var n = y.getProps(), r = i({}, e, { parent: { uid: f, props: n, export: y.export } }); return a(r) } }, t = 0, o = Object.keys(e); t < o.length; t++)r(t, o); return n }(), { isEligible: function () { return w }, clone: g, render: function (e, n) { return b(window, e, n) }, renderTo: function (e, n, r) { return b(e, n, r) } }), w && d.push(r), r }, instances: d, driver: function (e, n) { throw new Error("Driver support not enabled") }, isChild: l, canRenderTo: function (e) { return zn(e, "zoid_allow_delegate_" + o).then((function (e) { return e.data })).catch((function () { return !1 })) }, registerChild: h } } var hr = function (e) { var n, r, t, o; Xe().initialized || (Xe().initialized = !0, r = (n = { on: An, send: zn }).on, t = n.send, (o = Xe()).receiveMessage = o.receiveMessage || function (e) { return In(e, { on: r, send: t }) }, function (e) { var n = e.on, r = e.send; Qe().getOrSet("postMessageListener", (function () { return Le(window, "message", (function (e) { !function (e, n) { var r = n.on, t = n.send; p.try((function () { var n = e.source || e.sourceElement, o = e.origin || e.originalEvent && e.originalEvent.origin, i = e.data; if ("null" === o && (o = "file://"), n) { if (!o) throw new Error("Post message did not have origin domain"); In({ source: n, origin: o, data: i }, { on: r, send: t }) } })) }(e, { on: n, send: r }) })) })) }({ on: An, send: zn }), function (e) { var n = e.on, r = e.send; Qe("builtinListeners").getOrSet("helloListener", (function () { var e = n("postrobot_hello", { domain: "*" }, (function (e) { return an(e.source, { domain: e.origin }), { instanceID: on() } })), t = z(); return t && un(t, { send: r }).catch((function (e) { })), e })) }({ on: An, send: zn })); var i = lr(e), a = function (e) { return i.init(e) }; a.driver = function (e, n) { return i.driver(e, n) }, a.isChild = function () { return i.isChild() }, a.canRenderTo = function (e) { return i.canRenderTo(e) }, a.instances = i.instances; var u = i.registerChild(); return u && (window.xprops = a.xprops = u.getProps()), a }; function pr(e) { var n = fr.all(e); return fr = Ee(), n } var wr = pr; function mr(e) { var n; return wr(), delete window.__zoid_9_0_82__, function () { for (var e = Qe("responseListeners"), n = 0, r = e.keys(); n < r.length; n++) { var t = r[n], o = e.get(t); o && (o.cancelled = !0), e.del(t) } }(), (n = Qe().get("postMessageListener")) && n.cancel(), delete window.__post_robot_10_0_44__, dr.all(e) } }]) }, 548: function (e) { "undefined" != typeof self && self, e.exports = function (e) { var n = {}; function r(t) { if (n[t]) return n[t].exports; var o = n[t] = { i: t, l: !1, exports: {} }; return e[t].call(o.exports, o, o.exports, r), o.l = !0, o.exports } return r.m = e, r.c = n, r.d = function (e, n, t) { r.o(e, n) || Object.defineProperty(e, n, { enumerable: !0, get: t }) }, r.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, r.t = function (e, n) { if (1 & n && (e = r(e)), 8 & n) return e; if (4 & n && "object" == typeof e && e && e.__esModule) return e; var t = Object.create(null); if (r.r(t), Object.defineProperty(t, "default", { enumerable: !0, value: e }), 2 & n && "string" != typeof e) for (var o in e) r.d(t, o, function (n) { return e[n] }.bind(null, o)); return t }, r.n = function (e) { var n = e && e.__esModule ? function () { return e.default } : function () { return e }; return r.d(n, "a", n), n }, r.o = function (e, n) { return {}.hasOwnProperty.call(e, n) }, r.p = "", r(r.s = 0) }([function (e, n, r) { "use strict"; function t(e, n) { return (t = Object.setPrototypeOf || function (e, n) { return e.__proto__ = n, e })(e, n) } function o(e, n) { e.prototype = Object.create(n.prototype), e.prototype.constructor = e, t(e, n) } function i() { return (i = Object.assign || function (e) { for (var n = 1; n < arguments.length; n++) { var r = arguments[n]; for (var t in r) ({}).hasOwnProperty.call(r, t) && (e[t] = r[t]) } return e }).apply(this, arguments) } function a(e) { try { if (!e) return !1; if ("undefined" != typeof Promise && e instanceof Promise) return !0; if ("undefined" != typeof window && "function" == typeof window.Window && e instanceof window.Window) return !1; if ("undefined" != typeof window && "function" == typeof window.constructor && e instanceof window.constructor) return !1; var n = {}.toString; if (n) { var r = n.call(e); if ("[object Window]" === r || "[object global]" === r || "[object DOMWindow]" === r) return !1 } if ("function" == typeof e.then) return !0 } catch (e) { return !1 } return !1 } r.r(n), r.d(n, "PopupOpenError", (function () { return Fe })), r.d(n, "create", (function () { return Ar })), r.d(n, "destroy", (function () { return Lr })), r.d(n, "destroyComponents", (function () { return zr })), r.d(n, "destroyAll", (function () { return Fr })), r.d(n, "PROP_TYPE", (function () { return pr })), r.d(n, "PROP_SERIALIZATION", (function () { return wr })), r.d(n, "CONTEXT", (function () { return mr })), r.d(n, "EVENT", (function () { return vr })); var u, c = [], s = [], f = 0; function d() { if (!f && u) { var e = u; u = null, e.resolve() } } function l() { f += 1 } function h() { f -= 1, d() } var p = function () { function e(e) { var n = this; if (this.resolved = void 0, this.rejected = void 0, this.errorHandled = void 0, this.value = void 0, this.error = void 0, this.handlers = void 0, this.dispatching = void 0, this.stack = void 0, this.resolved = !1, this.rejected = !1, this.errorHandled = !1, this.handlers = [], e) { var r, t, o = !1, i = !1, a = !1; l(); try { e((function (e) { a ? n.resolve(e) : (o = !0, r = e) }), (function (e) { a ? n.reject(e) : (i = !0, t = e) })) } catch (e) { return h(), void this.reject(e) } h(), a = !0, o ? this.resolve(r) : i && this.reject(t) } } var n = e.prototype; return n.resolve = function (e) { if (this.resolved || this.rejected) return this; if (a(e)) throw new Error("Can not resolve promise with another promise"); return this.resolved = !0, this.value = e, this.dispatch(), this }, n.reject = function (e) { var n = this; if (this.resolved || this.rejected) return this; if (a(e)) throw new Error("Can not reject promise with another promise"); if (!e) { var r = e && "function" == typeof e.toString ? e.toString() : {}.toString.call(e); e = new Error("Expected reject to be called with Error, got " + r) } return this.rejected = !0, this.error = e, this.errorHandled || setTimeout((function () { n.errorHandled || function (e, n) { if (-1 === c.indexOf(e)) { c.push(e), setTimeout((function () { throw e }), 1); for (var r = 0; r < s.length; r++)s[r](e, n) } }(e, n) }), 1), this.dispatch(), this }, n.asyncReject = function (e) { return this.errorHandled = !0, this.reject(e), this }, n.dispatch = function () { var n = this.resolved, r = this.rejected, t = this.handlers; if (!this.dispatching && (n || r)) { this.dispatching = !0, l(); for (var o = function (e, n) { return e.then((function (e) { n.resolve(e) }), (function (e) { n.reject(e) })) }, i = 0; i < t.length; i++) { var u = t[i], c = u.onSuccess, s = u.onError, f = u.promise, d = void 0; if (n) try { d = c ? c(this.value) : this.value } catch (e) { f.reject(e); continue } else if (r) { if (!s) { f.reject(this.error); continue } try { d = s(this.error) } catch (e) { f.reject(e); continue } } if (d instanceof e && (d.resolved || d.rejected)) { var p = d; p.resolved ? f.resolve(p.value) : f.reject(p.error), p.errorHandled = !0 } else a(d) ? d instanceof e && (d.resolved || d.rejected) ? d.resolved ? f.resolve(d.value) : f.reject(d.error) : o(d, f) : f.resolve(d) } t.length = 0, this.dispatching = !1, h() } }, n.then = function (n, r) { if (n && "function" != typeof n && !n.call) throw new Error("Promise.then expected a function for success handler"); if (r && "function" != typeof r && !r.call) throw new Error("Promise.then expected a function for error handler"); var t = new e; return this.handlers.push({ promise: t, onSuccess: n, onError: r }), this.errorHandled = !0, this.dispatch(), t }, n.catch = function (e) { return this.then(void 0, e) }, n.finally = function (n) { if (n && "function" != typeof n && !n.call) throw new Error("Promise.finally expected a function"); return this.then((function (r) { return e.try(n).then((function () { return r })) }), (function (r) { return e.try(n).then((function () { throw r })) })) }, n.timeout = function (e, n) { var r = this; if (this.resolved || this.rejected) return this; var t = setTimeout((function () { r.resolved || r.rejected || r.reject(n || new Error("Promise timed out after " + e + "ms")) }), e); return this.then((function (e) { return clearTimeout(t), e })) }, n.toPromise = function () { if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise"); return Promise.resolve(this) }, n.lazy = function () { return this.errorHandled = !0, this }, e.resolve = function (n) { return n instanceof e ? n : a(n) ? new e((function (e, r) { return n.then(e, r) })) : (new e).resolve(n) }, e.reject = function (n) { return (new e).reject(n) }, e.asyncReject = function (n) { return (new e).asyncReject(n) }, e.all = function (n) { var r = new e, t = n.length, o = [].slice(); if (!t) return r.resolve(o), r; for (var i = function (e, n, i) { return n.then((function (n) { o[e] = n, 0 == (t -= 1) && r.resolve(o) }), (function (e) { i.reject(e) })) }, u = 0; u < n.length; u++) { var c = n[u]; if (c instanceof e) { if (c.resolved) { o[u] = c.value, t -= 1; continue } } else if (!a(c)) { o[u] = c, t -= 1; continue } i(u, e.resolve(c), r) } return 0 === t && r.resolve(o), r }, e.hash = function (n) { var r = {}, t = [], o = function (e) { if (n.hasOwnProperty(e)) { var o = n[e]; a(o) ? t.push(o.then((function (n) { r[e] = n }))) : r[e] = o } }; for (var i in n) o(i); return e.all(t).then((function () { return r })) }, e.map = function (n, r) { return e.all(n.map(r)) }, e.onPossiblyUnhandledException = function (e) { return function (e) { return s.push(e), { cancel: function () { s.splice(s.indexOf(e), 1) } } }(e) }, e.try = function (n, r, t) { if (n && "function" != typeof n && !n.call) throw new Error("Promise.try expected a function"); var o; l(); try { o = n.apply(r, t || []) } catch (n) { return h(), e.reject(n) } return h(), e.resolve(o) }, e.delay = function (n) { return new e((function (e) { setTimeout(e, n) })) }, e.isPromise = function (n) { return !!(n && n instanceof e) || a(n) }, e.flush = function () { return n = e, r = u = u || new n, d(), r; var n, r }, e }(); function w(e) { return "[object RegExp]" === {}.toString.call(e) } var m = { IFRAME: "iframe", POPUP: "popup" }, v = "Call was rejected by callee.\r\n"; function y(e) { return void 0 === e && (e = window), e.location.protocol } function g(e) { if (void 0 === e && (e = window), e.mockDomain) { var n = e.mockDomain.split("//")[0]; if (n) return n } return y(e) } function b(e) { return void 0 === e && (e = window), "about:" === g(e) } function E(e) { if (void 0 === e && (e = window), e) try { if (e.parent && e.parent !== e) return e.parent } catch (e) { } } function _(e) { if (void 0 === e && (e = window), e && !E(e)) try { return e.opener } catch (e) { } } function x(e) { try { return !0 } catch (e) { } return !1 } function O(e) { void 0 === e && (e = window); var n = e.location; if (!n) throw new Error("Can not read window location"); var r = y(e); if (!r) throw new Error("Can not read window protocol"); if ("file:" === r) return "file://"; if ("about:" === r) { var t = E(e); return t && x() ? O(t) : "about://" } var o = n.host; if (!o) throw new Error("Can not read window host"); return r + "//" + o } function P(e) { void 0 === e && (e = window); var n = O(e); return n && e.mockDomain && 0 === e.mockDomain.indexOf("mock:") ? e.mockDomain : n } function C(e) { if (!function (e) { try { if (e === window) return !0 } catch (e) { } try { var n = Object.getOwnPropertyDescriptor(e, "location"); if (n && !1 === n.enumerable) return !1 } catch (e) { } try { if (b(e) && x()) return !0 } catch (e) { } try { if (function (e) { return void 0 === e && (e = window), "mock:" === g(e) }(e) && x()) return !0 } catch (e) { } try { if (O(e) === O(window)) return !0 } catch (e) { } return !1 }(e)) return !1; try { if (e === window) return !0; if (b(e) && x()) return !0; if (P(window) === P(e)) return !0 } catch (e) { } return !1 } function S(e) { if (!C(e)) throw new Error("Expected window to be same domain"); return e } function D(e, n) { if (!e || !n) return !1; var r = E(n); return r ? r === e : -1 !== function (e) { var n = []; try { for (; e.parent !== e;)n.push(e.parent), e = e.parent } catch (e) { } return n }(n).indexOf(e) } function T(e) { var n, r, t = []; try { n = e.frames } catch (r) { n = e } try { r = n.length } catch (e) { } if (0 === r) return t; if (r) { for (var o = 0; o < r; o++) { var i = void 0; try { i = n[o] } catch (e) { continue } t.push(i) } return t } for (var a = 0; a < 100; a++) { var u = void 0; try { u = n[a] } catch (e) { return t } if (!u) return t; t.push(u) } return t } function W(e) { for (var n = [], r = 0, t = T(e); r < t.length; r++) { var o = t[r]; n.push(o); for (var i = 0, a = W(o); i < a.length; i++)n.push(a[i]) } return n } function k(e) { void 0 === e && (e = window); try { if (e.top) return e.top } catch (e) { } if (E(e) === e) return e; try { if (D(window, e) && window.top) return window.top } catch (e) { } try { if (D(e, window) && window.top) return window.top } catch (e) { } for (var n = 0, r = W(e); n < r.length; n++) { var t = r[n]; try { if (t.top) return t.top } catch (e) { } if (E(t) === t) return t } } function N(e) { var n = k(e); if (!n) throw new Error("Can not determine top window"); var r = [].concat(W(n), [n]); return -1 === r.indexOf(e) && (r = [].concat(r, [e], W(e))), r } var R = [], j = []; function I(e, n) { void 0 === n && (n = !0); try { if (e === window) return !1 } catch (e) { return !0 } try { if (!e) return !0 } catch (e) { return !0 } try { if (e.closed) return !0 } catch (e) { return !e || e.message !== v } if (n && C(e)) try { if (e.mockclosed) return !0 } catch (e) { } try { if (!e.parent || !e.top) return !0 } catch (e) { } var r = function (e, n) { for (var r = 0; r < e.length; r++)try { if (e[r] === n) return r } catch (e) { } return -1 }(R, e); if (-1 !== r) { var t = j[r]; if (t && function (e) { if (!e.contentWindow) return !0; if (!e.parentNode) return !0; var n = e.ownerDocument; if (n && n.documentElement && !n.documentElement.contains(e)) { for (var r = e; r.parentNode && r.parentNode !== r;)r = r.parentNode; if (!r.host || !n.documentElement.contains(r.host)) return !0 } return !1 }(t)) return !0 } return !1 } function A(e) { return (e = e || window).navigator.mockUserAgent || e.navigator.userAgent } function z(e, n) { for (var r = T(e), t = 0; t < r.length; t++) { var o = r[t]; try { if (C(o) && o.name === n && -1 !== r.indexOf(o)) return o } catch (e) { } } try { if (-1 !== r.indexOf(e.frames[n])) return e.frames[n] } catch (e) { } try { if (-1 !== r.indexOf(e[n])) return e[n] } catch (e) { } } function F(e, n) { return e === _(n) } function L(e) { return void 0 === e && (e = window), _(e = e || window) || E(e) || void 0 } function M(e, n) { for (var r = 0; r < e.length; r++)for (var t = e[r], o = 0; o < n.length; o++)if (t === n[o]) return !0; return !1 } function U(e) { void 0 === e && (e = window); for (var n = 0, r = e; r;)(r = E(r)) && (n += 1); return n } function q(e, n) { var r = k(e) || e, t = k(n) || n; try { if (r && t) return r === t } catch (e) { } var o = N(e), i = N(n); if (M(o, i)) return !0; var a = _(r), u = _(t); return a && M(N(a), i) || u && M(N(u), o), !1 } function B(e, n) { if ("string" == typeof e) { if ("string" == typeof n) return "*" === e || n === e; if (w(n)) return !1; if (Array.isArray(n)) return !1 } return w(e) ? w(n) ? e.toString() === n.toString() : !Array.isArray(n) && Boolean(n.match(e)) : !!Array.isArray(e) && (Array.isArray(n) ? JSON.stringify(e) === JSON.stringify(n) : !w(n) && e.some((function (e) { return B(e, n) }))) } function J(e) { return e.match(/^(https?|mock|file):\/\//) ? e.split("/").slice(0, 3).join("/") : P() } function H(e, n, r, t) { var o; return void 0 === r && (r = 1e3), void 0 === t && (t = 1 / 0), function i() { if (I(e)) return o && clearTimeout(o), n(); t <= 0 ? clearTimeout(o) : (t -= r, o = setTimeout(i, r)) }(), { cancel: function () { o && clearTimeout(o) } } } function Y(e) { try { if (e === window) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if ("[object Window]" === {}.toString.call(e)) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (window.Window && e instanceof window.Window) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (e && e.self === e) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (e && e.parent === e) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (e && e.top === e) return !0 } catch (e) { if (e && e.message === v) return !0 } try { if (e && "__unlikely_value__" === e.__cross_domain_utils_window_check__) return !1 } catch (e) { return !0 } try { if ("postMessage" in e && "self" in e && "location" in e) return !0 } catch (e) { } return !1 } function V(e) { if (0 !== J(e).indexOf("mock:")) return e; throw new Error("Mock urls not supported out of test mode") } function Z(e) { if (C(e)) return S(e).frameElement; for (var n = 0, r = document.querySelectorAll("iframe"); n < r.length; n++) { var t = r[n]; if (t && t.contentWindow && t.contentWindow === e) return t } } function G(e) { if (function (e) { return void 0 === e && (e = window), Boolean(E(e)) }(e)) { var n = Z(e); if (n && n.parentElement) return void n.parentElement.removeChild(n) } try { e.close() } catch (e) { } } function $(e, n) { for (var r = 0; r < e.length; r++)try { if (e[r] === n) return r } catch (e) { } return -1 } var X, K = function () { function e() { if (this.name = void 0, this.weakmap = void 0, this.keys = void 0, this.values = void 0, this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__", function () { if ("undefined" == typeof WeakMap) return !1; if (void 0 === Object.freeze) return !1; try { var e = new WeakMap, n = {}; return Object.freeze(n), e.set(n, "__testvalue__"), "__testvalue__" === e.get(n) } catch (e) { return !1 } }()) try { this.weakmap = new WeakMap } catch (e) { } this.keys = [], this.values = [] } var n = e.prototype; return n._cleanupClosedWindows = function () { for (var e = this.weakmap, n = this.keys, r = 0; r < n.length; r++) { var t = n[r]; if (Y(t) && I(t)) { if (e) try { e.delete(t) } catch (e) { } n.splice(r, 1), this.values.splice(r, 1), r -= 1 } } }, n.isSafeToReadWrite = function (e) { return !Y(e) }, n.set = function (e, n) { if (!e) throw new Error("WeakMap expected key"); var r = this.weakmap; if (r) try { r.set(e, n) } catch (e) { delete this.weakmap } if (this.isSafeToReadWrite(e)) try { var t = this.name, o = e[t]; return void (o && o[0] === e ? o[1] = n : Object.defineProperty(e, t, { value: [e, n], writable: !0 })) } catch (e) { } this._cleanupClosedWindows(); var i = this.keys, a = this.values, u = $(i, e); -1 === u ? (i.push(e), a.push(n)) : a[u] = n }, n.get = function (e) { if (!e) throw new Error("WeakMap expected key"); var n = this.weakmap; if (n) try { if (n.has(e)) return n.get(e) } catch (e) { delete this.weakmap } if (this.isSafeToReadWrite(e)) try { var r = e[this.name]; return r && r[0] === e ? r[1] : void 0 } catch (e) { } this._cleanupClosedWindows(); var t = $(this.keys, e); if (-1 !== t) return this.values[t] }, n.delete = function (e) { if (!e) throw new Error("WeakMap expected key"); var n = this.weakmap; if (n) try { n.delete(e) } catch (e) { delete this.weakmap } if (this.isSafeToReadWrite(e)) try { var r = e[this.name]; r && r[0] === e && (r[0] = r[1] = void 0) } catch (e) { } this._cleanupClosedWindows(); var t = this.keys, o = $(t, e); -1 !== o && (t.splice(o, 1), this.values.splice(o, 1)) }, n.has = function (e) { if (!e) throw new Error("WeakMap expected key"); var n = this.weakmap; if (n) try { if (n.has(e)) return !0 } catch (e) { delete this.weakmap } if (this.isSafeToReadWrite(e)) try { var r = e[this.name]; return !(!r || r[0] !== e) } catch (e) { } return this._cleanupClosedWindows(), -1 !== $(this.keys, e) }, n.getOrSet = function (e, n) { if (this.has(e)) return this.get(e); var r = n(); return this.set(e, r), r }, e }(); function Q(e) { return (Q = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function ee() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (e) { return !1 } } function ne(e, n, r) { return (ne = ee() ? Reflect.construct : function (e, n, r) { var o = [null]; o.push.apply(o, n); var i = new (Function.bind.apply(e, o)); return r && t(i, r.prototype), i }).apply(null, arguments) } function re(e) { var n = "function" == typeof Map ? new Map : void 0; return (re = function (e) { if (null === e || (r = e, -1 === Function.toString.call(r).indexOf("[native code]"))) return e; var r; if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== n) { if (n.has(e)) return n.get(e); n.set(e, o) } function o() { return ne(e, arguments, Q(this).constructor) } return o.prototype = Object.create(e.prototype, { constructor: { value: o, enumerable: !1, writable: !0, configurable: !0 } }), t(o, e) })(e) } function te(e) { return e.name || e.__name__ || e.displayName || "anonymous" } function oe(e, n) { try { delete e.name, e.name = n } catch (e) { } return e.__name__ = e.displayName = n, e } function ie(e) { if ("function" == typeof btoa) return btoa(encodeURIComponent(e).replace(/%([0-9A-F]{2})/g, (function (e, n) { return String.fromCharCode(parseInt(n, 16)) }))).replace(/[=]/g, ""); if ("undefined" != typeof Buffer) return Buffer.from(e, "utf8").toString("base64").replace(/[=]/g, ""); throw new Error("Can not find window.btoa or Buffer") } function ae() { var e = "0123456789abcdef"; return "uid_" + "xxxxxxxxxx".replace(/./g, (function () { return e.charAt(Math.floor(Math.random() * e.length)) })) + "_" + ie((new Date).toISOString().slice(11, 19).replace("T", ".")).replace(/[^a-zA-Z0-9]/g, "").toLowerCase() } function ue(e) { try { return JSON.stringify([].slice.call(e), (function (e, n) { return "function" == typeof n ? "memoize[" + function (e) { if (X = X || new K, null == e || "object" != typeof e && "function" != typeof e) throw new Error("Invalid object"); var n = X.get(e); return n || (n = typeof e + ":" + ae(), X.set(e, n)), n }(n) + "]" : n })) } catch (e) { throw new Error("Arguments not serializable -- can not be used to memoize") } } function ce() { return {} } var se = 0, fe = 0; function de(e, n) { void 0 === n && (n = {}); var r, t, o = n.thisNamespace, i = void 0 !== o && o, a = n.time, u = se; se += 1; var c = function () { for (var n = arguments.length, o = new Array(n), c = 0; c < n; c++)o[c] = arguments[c]; var s; u < fe && (r = null, t = null, u = se, se += 1), s = i ? (t = t || new K).getOrSet(this, ce) : r = r || {}; var f = ue(o), d = s[f]; if (d && a && Date.now() - d.time < a && (delete s[f], d = null), d) return d.value; var l = Date.now(), h = e.apply(this, arguments); return s[f] = { time: l, value: h }, h }; return c.reset = function () { r = null, t = null }, oe(c, (n.name || te(e)) + "::memoized") } function le(e) { var n = {}; function r() { for (var r = arguments, t = this, o = arguments.length, i = new Array(o), a = 0; a < o; a++)i[a] = arguments[a]; var u = ue(i); return n.hasOwnProperty(u) || (n[u] = p.try((function () { return e.apply(t, r) })).finally((function () { delete n[u] }))), n[u] } return r.reset = function () { n = {} }, oe(r, te(e) + "::promiseMemoized") } function he() { } function pe(e) { var n = !1; return oe((function () { if (!n) return n = !0, e.apply(this, arguments) }), te(e) + "::once") } function we(e, n) { if (void 0 === n && (n = 1), n >= 3) return "stringifyError stack overflow"; try { if (!e) return "<unknown error: " + {}.toString.call(e) + ">"; if ("string" == typeof e) return e; if (e instanceof Error) { var r = e && e.stack, t = e && e.message; if (r && t) return -1 !== r.indexOf(t) ? r : t + "\n" + r; if (r) return r; if (t) return t } return e && e.toString && "function" == typeof e.toString ? e.toString() : {}.toString.call(e) } catch (e) { return "Error while stringifying error: " + we(e, n + 1) } } function me(e) { return "string" == typeof e ? e : e && e.toString && "function" == typeof e.toString ? e.toString() : {}.toString.call(e) } function ve(e, n) { if (!n) return e; if (Object.assign) return Object.assign(e, n); for (var r in n) n.hasOwnProperty(r) && (e[r] = n[r]); return e } function ye(e) { return e } function ge(e, n) { var r; return function t() { r = setTimeout((function () { e(), t() }), n) }(), { cancel: function () { clearTimeout(r) } } } function be(e) { return [].slice.call(e) } function Ee(e) { return null != e } function _e(e) { return "[object RegExp]" === {}.toString.call(e) } function xe(e, n, r) { if (e.hasOwnProperty(n)) return e[n]; var t = r(); return e[n] = t, t } function Oe(e) { var n, r = [], t = !1, o = { set: function (n, r) { return t || (e[n] = r, o.register((function () { delete e[n] }))), r }, register: function (e) { var o = pe((function () { return e(n) })); return t ? e(n) : r.push(o), { cancel: function () { var e = r.indexOf(o); -1 !== e && r.splice(e, 1) } } }, all: function (e) { n = e; var o = []; for (t = !0; r.length;) { var i = r.shift(); o.push(i()) } return p.all(o).then(he) } }; return o } function Pe(e, n) { if (null == n) throw new Error("Expected " + e + " to be present"); return n } de.clear = function () { fe = se }, de((function (e) { if (Object.values) return Object.values(e); var n = []; for (var r in e) e.hasOwnProperty(r) && n.push(e[r]); return n })); var Ce = function (e) { function n(n) { var r; return (r = e.call(this, n) || this).name = r.constructor.name, "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(r), r.constructor) : r.stack = new Error(n).stack, r } return o(n, e), n }(re(Error)); function Se() { var e = document.body; if (!e) throw new Error("Body element not found"); return e } function De() { return Boolean(document.body) && "complete" === document.readyState } function Te() { return Boolean(document.body) && "interactive" === document.readyState } function We(e) { return encodeURIComponent(e) } function ke(e) { return function (n, r, t) { void 0 === t && (t = []); var o = n.__inline_memoize_cache__ = n.__inline_memoize_cache__ || {}, i = ue(t); return o.hasOwnProperty(i) ? o[i] : o[i] = function () { var n = {}; if (!e) return n; if (-1 === e.indexOf("=")) return n; for (var r = 0, t = e.split("&"); r < t.length; r++) { var o = t[r]; (o = o.split("="))[0] && o[1] && (n[decodeURIComponent(o[0])] = decodeURIComponent(o[1])) } return n }.apply(void 0, t) }(ke, 0, [e]) } function Ne(e, n) { return void 0 === n && (n = {}), n && Object.keys(n).length ? (void 0 === (r = i({}, ke(e), n)) && (r = {}), Object.keys(r).filter((function (e) { return "string" == typeof r[e] || "boolean" == typeof r[e] })).map((function (e) { var n = r[e]; if ("string" != typeof n && "boolean" != typeof n) throw new TypeError("Invalid type for query"); return We(e) + "=" + We(n.toString()) })).join("&")) : e; var r } function Re(e, n) { e.appendChild(n) } function je(e) { return e instanceof window.Element || null !== e && "object" == typeof e && 1 === e.nodeType && "object" == typeof e.style && "object" == typeof e.ownerDocument } function Ie(e, n) { return void 0 === n && (n = document), je(e) ? e : "string" == typeof e ? n.querySelector(e) : void 0 } function Ae(e) { return new p((function (n, r) { var t = me(e), o = Ie(e); if (o) return n(o); if (De()) return r(new Error("Document is ready and element " + t + " does not exist")); var i = setInterval((function () { if (o = Ie(e)) n(o), clearInterval(i); else if (De()) return clearInterval(i), r(new Error("Document is ready and element " + t + " does not exist")) }), 10) })) } de((function () { return new p((function (e) { if (De() || Te()) return e(); var n = setInterval((function () { if (De() || Te()) return clearInterval(n), e() }), 10) })) })); var ze, Fe = function (e) { function n() { return e.apply(this, arguments) || this } return o(n, e), n }(Ce); function Le(e) { if ((ze = ze || new K).has(e)) { var n = ze.get(e); if (n) return n } var r = new p((function (n, r) { e.addEventListener("load", (function () { !function (e) { if (function () { for (var e = 0; e < R.length; e++) { var n = !1; try { n = R[e].closed } catch (e) { } n && (j.splice(e, 1), R.splice(e, 1)) } }(), e && e.contentWindow) try { R.push(e.contentWindow), j.push(e) } catch (e) { } }(e), n(e) })), e.addEventListener("error", (function (t) { e.contentWindow ? n(e) : r(t) })) })); return ze.set(e, r), r } function Me(e) { return Le(e).then((function (e) { if (!e.contentWindow) throw new Error("Could not find window in iframe"); return e.contentWindow })) } function Ue(e, n) { void 0 === e && (e = {}); var r = e.style || {}, t = function (e, n, r) { void 0 === e && (e = "div"), void 0 === n && (n = {}), e = e.toLowerCase(); var t, o, i, a = document.createElement(e); if (n.style && ve(a.style, n.style), n.class && (a.className = n.class.join(" ")), n.id && a.setAttribute("id", n.id), n.attributes) for (var u = 0, c = Object.keys(n.attributes); u < c.length; u++) { var s = c[u]; a.setAttribute(s, n.attributes[s]) } if (n.styleSheet && (t = a, o = n.styleSheet, void 0 === i && (i = window.document), t.styleSheet ? t.styleSheet.cssText = o : t.appendChild(i.createTextNode(o))), n.html) { if ("iframe" === e) throw new Error("Iframe html can not be written unless container provided and iframe in DOM"); a.innerHTML = n.html } return a }("iframe", { attributes: i({ allowTransparency: "true" }, e.attributes || {}), style: i({ backgroundColor: "transparent", border: "none" }, r), html: e.html, class: e.class }), o = window.navigator.userAgent.match(/MSIE|Edge/i); return t.hasAttribute("id") || t.setAttribute("id", ae()), Le(t), n && function (e, n) { void 0 === n && (n = document); var r = Ie(e, n); if (r) return r; throw new Error("Can not find element: " + me(e)) }(n).appendChild(t), (e.url || o) && t.setAttribute("src", e.url || "about:blank"), t } function qe(e, n, r) { return e.addEventListener(n, r), { cancel: function () { e.removeEventListener(n, r) } } } function Be(e) { e.style.setProperty("display", "") } function Je(e) { e.style.setProperty("display", "none", "important") } function He(e) { e && e.parentNode && e.parentNode.removeChild(e) } function Ye(e) { return !(e && e.parentNode && e.ownerDocument && e.ownerDocument.documentElement && e.ownerDocument.documentElement.contains(e)) } function Ve(e, n, r) { var t = void 0 === r ? {} : r, o = t.width, i = void 0 === o || o, a = t.height, u = void 0 === a || a, c = t.interval, s = void 0 === c ? 100 : c, f = t.win, d = void 0 === f ? window : f, l = e.offsetWidth, h = e.offsetHeight, p = !1; n({ width: l, height: h }); var w, m, v = function () { if (!p && function (e) { return Boolean(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }(e)) { var r = e.offsetWidth, t = e.offsetHeight; (i && r !== l || u && t !== h) && n({ width: r, height: t }), l = r, h = t } }; return d.addEventListener("resize", v), void 0 !== d.ResizeObserver ? ((w = new d.ResizeObserver(v)).observe(e), m = ge(v, 10 * s)) : void 0 !== d.MutationObserver ? ((w = new d.MutationObserver(v)).observe(e, { attributes: !0, childList: !0, subtree: !0, characterData: !1 }), m = ge(v, 10 * s)) : m = ge(v, s), { cancel: function () { p = !0, w.disconnect(), window.removeEventListener("resize", v), m.cancel() } } } function Ze(e) { for (; e.parentNode;)e = e.parentNode; return "[object ShadowRoot]" === e.toString() } var Ge = "undefined" != typeof document ? document.currentScript : null, $e = de((function () { if (Ge) return Ge; if (Ge = function () { try { var e = function () { try { throw new Error("_") } catch (e) { return e.stack || "" } }(), n = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(e), r = n && n[1]; if (!r) return; for (var t = 0, o = [].slice.call(document.getElementsByTagName("script")).reverse(); t < o.length; t++) { var i = o[t]; if (i.src && i.src === r) return i } } catch (e) { } }()) return Ge; throw new Error("Can not determine current script") })), Xe = ae(); function Ke(e) { return "string" == typeof e && /^[0-9]+%$/.test(e) } function Qe(e) { if ("number" == typeof e) return e; var n = e.match(/^([0-9]+)(px|%)$/); if (!n) throw new Error("Could not match css value from " + e); return parseInt(n[1], 10) } function en(e) { return Qe(e) + "px" } function nn(e) { return "number" == typeof e ? en(e) : Ke(e) ? e : en(e) } function rn(e, n) { if ("number" == typeof e) return e; if (Ke(e)) return parseInt(n * Qe(e) / 100, 10); if ("string" == typeof (r = e) && /^[0-9]+px$/.test(r)) return Qe(e); var r; throw new Error("Can not normalize dimension: " + e) } function tn(e) { void 0 === e && (e = window); var n = "__post_robot_10_0_44__"; return e !== window ? e[n] : e[n] = e[n] || {} } de((function () { var e; try { e = $e() } catch (e) { return Xe } var n = e.getAttribute("data-uid"); if (n && "string" == typeof n) return n; if ((n = e.getAttribute("data-uid-auto")) && "string" == typeof n) return n; if (e.src) { var r = function (e) { for (var n = "", r = 0; r < e.length; r++) { var t = e[r].charCodeAt(0) * r; e[r + 1] && (t += e[r + 1].charCodeAt(0) * (r - 1)), n += String.fromCharCode(97 + Math.abs(t) % 26) } return n }(JSON.stringify({ src: e.src, dataset: e.dataset })); n = "uid_" + r.slice(r.length - 30) } else n = ae(); return e.setAttribute("data-uid-auto", n), n })); var on = function () { return {} }; function an(e, n) { return void 0 === e && (e = "store"), void 0 === n && (n = on), xe(tn(), e, (function () { var e = n(); return { has: function (n) { return e.hasOwnProperty(n) }, get: function (n, r) { return e.hasOwnProperty(n) ? e[n] : r }, set: function (n, r) { return e[n] = r, r }, del: function (n) { delete e[n] }, getOrSet: function (n, r) { return xe(e, n, r) }, reset: function () { e = n() }, keys: function () { return Object.keys(e) } } })) } var un, cn = function () { }; function sn() { var e = tn(); return e.WINDOW_WILDCARD = e.WINDOW_WILDCARD || new cn, e.WINDOW_WILDCARD } function fn(e, n) { return void 0 === e && (e = "store"), void 0 === n && (n = on), an("windowStore").getOrSet(e, (function () { var r = new K, t = function (e) { return r.getOrSet(e, n) }; return { has: function (n) { return t(n).hasOwnProperty(e) }, get: function (n, r) { var o = t(n); return o.hasOwnProperty(e) ? o[e] : r }, set: function (n, r) { return t(n)[e] = r, r }, del: function (n) { delete t(n)[e] }, getOrSet: function (n, r) { return xe(t(n), e, r) } } })) } function dn() { return an("instance").getOrSet("instanceID", ae) } function ln(e, n) { var r = n.domain, t = fn("helloPromises"), o = t.get(e); o && o.resolve({ domain: r }); var i = p.resolve({ domain: r }); return t.set(e, i), i } function hn(e, n) { return (0, n.send)(e, "postrobot_hello", { instanceID: dn() }, { domain: "*", timeout: -1 }).then((function (n) { var r = n.origin, t = n.data.instanceID; return ln(e, { domain: r }), { win: e, domain: r, instanceID: t } })) } function pn(e, n) { var r = n.send; return fn("windowInstanceIDPromises").getOrSet(e, (function () { return hn(e, { send: r }).then((function (e) { return e.instanceID })) })) } function wn(e, n, r) { void 0 === n && (n = 5e3), void 0 === r && (r = "Window"); var t = function (e) { return fn("helloPromises").getOrSet(e, (function () { return new p })) }(e); return -1 !== n && (t = t.timeout(n, new Error(r + " did not load after " + n + "ms"))), t } function mn(e) { fn("knownWindows").set(e, !0) } function vn(e) { return "object" == typeof e && null !== e && "string" == typeof e.__type__ } function yn(e) { return void 0 === e ? "undefined" : null === e ? "null" : Array.isArray(e) ? "array" : "function" == typeof e ? "function" : "object" == typeof e ? e instanceof Error ? "error" : "function" == typeof e.then ? "promise" : "[object RegExp]" === {}.toString.call(e) ? "regex" : "[object Date]" === {}.toString.call(e) ? "date" : "object" : "string" == typeof e ? "string" : "number" == typeof e ? "number" : "boolean" == typeof e ? "boolean" : void 0 } function gn(e, n) { return { __type__: e, __val__: n } } var bn, En = ((un = {}).function = function () { }, un.error = function (e) { return gn("error", { message: e.message, stack: e.stack, code: e.code, data: e.data }) }, un.promise = function () { }, un.regex = function (e) { return gn("regex", e.source) }, un.date = function (e) { return gn("date", e.toJSON()) }, un.array = function (e) { return e }, un.object = function (e) { return e }, un.string = function (e) { return e }, un.number = function (e) { return e }, un.boolean = function (e) { return e }, un.null = function (e) { return e }, un[void 0] = function (e) { return gn("undefined", e) }, un), _n = {}, xn = ((bn = {}).function = function () { throw new Error("Function serialization is not implemented; nothing to deserialize") }, bn.error = function (e) { var n = e.stack, r = e.code, t = e.data, o = new Error(e.message); return o.code = r, t && (o.data = t), o.stack = n + "\n\n" + o.stack, o }, bn.promise = function () { throw new Error("Promise serialization is not implemented; nothing to deserialize") }, bn.regex = function (e) { return new RegExp(e) }, bn.date = function (e) { return new Date(e) }, bn.array = function (e) { return e }, bn.object = function (e) { return e }, bn.string = function (e) { return e }, bn.number = function (e) { return e }, bn.boolean = function (e) { return e }, bn.null = function (e) { return e }, bn[void 0] = function () { }, bn), On = {}; function Pn() { return !!A(window).match(/MSIE|trident|edge\/12|edge\/13/i) } function Cn(e) { return !q(window, e) } function Sn(e, n) { if (e) { if (P() !== J(e)) return !0 } else if (n && !C(n)) return !0; return !1 } function Dn(e) { var n = e.win, r = e.domain; return !(!Pn() || r && !Sn(r, n) || n && !Cn(n)) } function Tn(e) { return "__postrobot_bridge___" + (e = e || J(e)).replace(/[^a-zA-Z0-9]+/g, "_") } function Wn() { return Boolean(window.name && window.name === Tn(P())) } var kn = new p((function (e) { if (window.document && window.document.body) return e(window.document.body); var n = setInterval((function () { if (window.document && window.document.body) return clearInterval(n), e(window.document.body) }), 10) })); function Nn(e) { fn("remoteWindowPromises").getOrSet(e, (function () { return new p })) } function Rn(e) { var n = fn("remoteWindowPromises").get(e); if (!n) throw new Error("Remote window promise not found"); return n } function jn(e, n, r) { Rn(e).resolve((function (t, o, i) { if (t !== e) throw new Error("Remote window does not match window"); if (!B(o, n)) throw new Error("Remote domain " + o + " does not match domain " + n); r.fireAndForget(i) })) } function In(e, n) { Rn(e).reject(n).catch(he) } function An(e) { for (var n = e.win, r = e.name, t = e.domain, o = an("popupWindowsByName"), i = fn("popupWindowsByWin"), a = 0, u = o.keys(); a < u.length; a++) { var c = u[a], s = o.get(c); s && !I(s.win) || o.del(c) } if (I(n)) return { win: n, name: r, domain: t }; var f = i.getOrSet(n, (function () { return r ? o.getOrSet(r, (function () { return { win: n, name: r } })) : { win: n } })); if (f.win && f.win !== n) throw new Error("Different window already linked for window: " + (r || "undefined")); return r && (f.name = r, o.set(r, f)), t && (f.domain = t, Nn(n)), i.set(n, f), f } function zn(e) { var n, r = e.on, t = e.send, o = e.receiveMessage; n = window.open, window.open = function (e, r, t, o) { var i = n.call(this, V(e), r, t, o); return i ? (An({ win: i, name: r, domain: e ? J(e) : null }), i) : i }, function (e) { var n = e.on, r = e.send, t = e.receiveMessage, o = an("popupWindowsByName"); n("postrobot_open_tunnel", (function (e) { var i = e.source, a = e.origin, u = e.data, c = an("bridges").get(a); if (!c) throw new Error("Can not find bridge promise for domain " + a); return c.then((function (e) { if (i !== e) throw new Error("Message source does not matched registered bridge for domain " + a); if (!u.name) throw new Error("Register window expected to be passed window name"); if (!u.sendMessage) throw new Error("Register window expected to be passed sendMessage method"); if (!o.has(u.name)) throw new Error("Window with name " + u.name + " does not exist, or was not opened by this window"); var c = function () { return o.get(u.name) }; if (!c().domain) throw new Error("We do not have a registered domain for window " + u.name); if (c().domain !== a) throw new Error("Message origin " + a + " does not matched registered window origin " + (c().domain || "unknown")); return jn(c().win, a, u.sendMessage), { sendMessage: function (e) { if (window && !window.closed && c()) { var o = c().domain; if (o) try { t({ data: e, origin: o, source: c().win }, { on: n, send: r }) } catch (e) { p.reject(e) } } } } })) })) }({ on: r, send: t, receiveMessage: o }), function (e) { var n = e.send; tn(window).openTunnelToParent = function (e) { var r = e.name, t = e.source, o = e.canary, i = e.sendMessage, a = an("tunnelWindows"), u = E(window); if (!u) throw new Error("No parent window found to open tunnel to"); var c = function (e) { var n = e.name, r = e.source, t = e.canary, o = e.sendMessage; !function () { for (var e = an("tunnelWindows"), n = 0, r = e.keys(); n < r.length; n++) { var t = r[n]; I(e[t].source) && e.del(t) } }(); var i = ae(); return an("tunnelWindows").set(i, { name: n, source: r, canary: t, sendMessage: o }), i }({ name: r, source: t, canary: o, sendMessage: i }); return n(u, "postrobot_open_tunnel", { name: r, sendMessage: function () { var e = a.get(c); if (e && e.source && !I(e.source)) { try { e.canary() } catch (e) { return } e.sendMessage.apply(this, arguments) } } }, { domain: "*" }) } }({ send: t }), function (e) { var n = e.on, r = e.send, t = e.receiveMessage; p.try((function () { var e, o = _(window); if (o && Dn({ win: o })) return Nn(o), (e = o, fn("remoteBridgeAwaiters").getOrSet(e, (function () { return p.try((function () { var n = z(e, Tn(P())); if (n) return C(n) && tn(S(n)) ? n : new p((function (e) { var r, t; r = setInterval((function () { if (n && C(n) && tn(S(n))) return clearInterval(r), clearTimeout(t), e(n) }), 100), t = setTimeout((function () { return clearInterval(r), e() }), 2e3) })) })) }))).then((function (e) { return e ? window.name ? tn(S(e)).openTunnelToParent({ name: window.name, source: window, canary: function () { }, sendMessage: function (e) { try { window } catch (e) { return } if (window && !window.closed) try { t({ data: e, origin: this.origin, source: this.source }, { on: n, send: r }) } catch (e) { p.reject(e) } } }).then((function (e) { var n = e.source, r = e.origin, t = e.data; if (n !== o) throw new Error("Source does not match opener"); jn(n, r, t.sendMessage) })).catch((function (e) { throw In(o, e), e })) : In(o, new Error("Can not register with opener: window does not have a name")) : In(o, new Error("Can not register with opener: no bridge found in opener")) })) })) }({ on: r, send: t, receiveMessage: o }) } function Fn() { for (var e = an("idToProxyWindow"), n = 0, r = e.keys(); n < r.length; n++) { var t = r[n]; e.get(t).shouldClean() && e.del(t) } } function Ln(e, n) { var r = n.send, t = n.id, o = void 0 === t ? ae() : t, i = e.then((function (e) { if (C(e)) return S(e).name })), a = e.then((function (e) { if (I(e)) throw new Error("Window is closed, can not determine type"); return _(e) ? m.POPUP : m.IFRAME })); i.catch(he), a.catch(he); var u = function () { return e.then((function (e) { if (!I(e)) return C(e) ? S(e).name : i })) }; return { id: o, getType: function () { return a }, getInstanceID: le((function () { return e.then((function (e) { return pn(e, { send: r }) })) })), close: function () { return e.then(G) }, getName: u, focus: function () { return e.then((function (e) { e.focus() })) }, isClosed: function () { return e.then((function (e) { return I(e) })) }, setLocation: function (n, r) { return void 0 === r && (r = {}), e.then((function (e) { var t = window.location.protocol + "//" + window.location.host, o = r.method, i = void 0 === o ? "get" : o, a = r.body; if (0 === n.indexOf("/")) n = "" + t + n; else if (!n.match(/^https?:\/\//) && 0 !== n.indexOf(t)) throw new Error("Expected url to be http or https url, or absolute path, got " + JSON.stringify(n)); if ("post" === i) return u().then((function (e) { if (!e) throw new Error("Can not post to window without target name"); !function (e) { var n = e.url, r = e.target, t = e.body, o = e.method, i = void 0 === o ? "post" : o, a = document.createElement("form"); if (a.setAttribute("target", r), a.setAttribute("method", i), a.setAttribute("action", n), a.style.display = "none", t) for (var u = 0, c = Object.keys(t); u < c.length; u++) { var s, f = c[u], d = document.createElement("input"); d.setAttribute("name", f), d.setAttribute("value", null == (s = t[f]) ? void 0 : s.toString()), a.appendChild(d) } Se().appendChild(a), a.submit(), Se().removeChild(a) }({ url: n, target: e, method: i, body: a }) })); if ("get" !== i) throw new Error("Unsupported method: " + i); if (C(e)) try { if (e.location && "function" == typeof e.location.replace) return void e.location.replace(n) } catch (e) { } e.location = n })) }, setName: function (n) { return e.then((function (e) { An({ win: e, name: n }); var r = C(e), t = Z(e); if (!r) throw new Error("Can not set name for cross-domain window: " + n); S(e).name = n, t && t.setAttribute("name", n), i = p.resolve(n) })) } } } var Mn = function () { function e(e) { var n = e.send, r = e.win, t = e.serializedWindow; this.id = void 0, this.isProxyWindow = !0, this.serializedWindow = void 0, this.actualWindow = void 0, this.actualWindowPromise = void 0, this.send = void 0, this.name = void 0, this.actualWindowPromise = new p, this.serializedWindow = t || Ln(this.actualWindowPromise, { send: n }), an("idToProxyWindow").set(this.getID(), this), r && this.setWindow(r, { send: n }) } var n = e.prototype; return n.getID = function () { return this.serializedWindow.id }, n.getType = function () { return this.serializedWindow.getType() }, n.isPopup = function () { return this.getType().then((function (e) { return e === m.POPUP })) }, n.setLocation = function (e, n) { var r = this; return this.serializedWindow.setLocation(e, n).then((function () { return r })) }, n.getName = function () { return this.serializedWindow.getName() }, n.setName = function (e) { var n = this; return this.serializedWindow.setName(e).then((function () { return n })) }, n.close = function () { var e = this; return this.serializedWindow.close().then((function () { return e })) }, n.focus = function () { var e = this, n = this.isPopup(), r = this.getName(), t = p.hash({ isPopup: n, name: r }).then((function (e) { var n = e.name; e.isPopup && n && window.open("", n) })), o = this.serializedWindow.focus(); return p.all([t, o]).then((function () { return e })) }, n.isClosed = function () { return this.serializedWindow.isClosed() }, n.getWindow = function () { return this.actualWindow }, n.setWindow = function (e, n) { var r = n.send; this.actualWindow = e, this.actualWindowPromise.resolve(this.actualWindow), this.serializedWindow = Ln(this.actualWindowPromise, { send: r, id: this.getID() }), fn("winToProxyWindow").set(e, this) }, n.awaitWindow = function () { return this.actualWindowPromise }, n.matchWindow = function (e, n) { var r = this, t = n.send; return p.try((function () { return r.actualWindow ? e === r.actualWindow : p.hash({ proxyInstanceID: r.getInstanceID(), knownWindowInstanceID: pn(e, { send: t }) }).then((function (n) { var o = n.proxyInstanceID === n.knownWindowInstanceID; return o && r.setWindow(e, { send: t }), o })) })) }, n.unwrap = function () { return this.actualWindow || this }, n.getInstanceID = function () { return this.serializedWindow.getInstanceID() }, n.shouldClean = function () { return Boolean(this.actualWindow && I(this.actualWindow)) }, n.serialize = function () { return this.serializedWindow }, e.unwrap = function (n) { return e.isProxyWindow(n) ? n.unwrap() : n }, e.serialize = function (n, r) { var t = r.send; return Fn(), e.toProxyWindow(n, { send: t }).serialize() }, e.deserialize = function (n, r) { var t = r.send; return Fn(), an("idToProxyWindow").get(n.id) || new e({ serializedWindow: n, send: t }) }, e.isProxyWindow = function (e) { return Boolean(e && !Y(e) && e.isProxyWindow) }, e.toProxyWindow = function (n, r) { var t = r.send; if (Fn(), e.isProxyWindow(n)) return n; var o = n; return fn("winToProxyWindow").get(o) || new e({ win: o, send: t }) }, e }(); function Un(e, n, r, t, o) { var i = fn("methodStore"), a = an("proxyWindowMethods"); Mn.isProxyWindow(t) ? a.set(e, { val: n, name: r, domain: o, source: t }) : (a.del(e), i.getOrSet(t, (function () { return {} }))[e] = { domain: o, name: r, val: n, source: t }) } function qn(e, n) { var r = fn("methodStore"), t = an("proxyWindowMethods"); return r.getOrSet(e, (function () { return {} }))[n] || t.get(n) } function Bn(e, n, r, t, o) { var i, a, u; a = (i = { on: o.on, send: o.send }).on, u = i.send, an("builtinListeners").getOrSet("functionCalls", (function () { return a("postrobot_method", { domain: "*" }, (function (e) { var n = e.source, r = e.origin, t = e.data, o = t.id, i = t.name, a = qn(n, o); if (!a) throw new Error("Could not find method '" + i + "' with id: " + t.id + " in " + P(window)); var c = a.source, s = a.domain, f = a.val; return p.try((function () { if (!B(s, r)) throw new Error("Method '" + t.name + "' domain " + JSON.stringify(_e(a.domain) ? a.domain.source : a.domain) + " does not match origin " + r + " in " + P(window)); if (Mn.isProxyWindow(c)) return c.matchWindow(n, { send: u }).then((function (e) { if (!e) throw new Error("Method call '" + t.name + "' failed - proxy window does not match source in " + P(window)) })) })).then((function () { return f.apply({ source: n, origin: r }, t.args) }), (function (e) { return p.try((function () { if (f.onError) return f.onError(e) })).then((function () { var n; throw e.stack && (e.stack = "Remote call to " + i + "(" + (void 0 === (n = t.args) && (n = []), be(n).map((function (e) { return "string" == typeof e ? "'" + e + "'" : void 0 === e ? "undefined" : null === e ? "null" : "boolean" == typeof e ? e.toString() : Array.isArray(e) ? "[ ... ]" : "object" == typeof e ? "{ ... }" : "function" == typeof e ? "() => { ... }" : "<" + typeof e + ">" })).join(", ") + ") failed\n\n") + e.stack), e })) })).then((function (e) { return { result: e, id: o, name: i } })) })) })); var c = r.__id__ || ae(); e = Mn.unwrap(e); var s = r.__name__ || r.name || t; return "string" == typeof s && "function" == typeof s.indexOf && 0 === s.indexOf("anonymous::") && (s = s.replace("anonymous::", t + "::")), Mn.isProxyWindow(e) ? (Un(c, r, s, e, n), e.awaitWindow().then((function (e) { Un(c, r, s, e, n) }))) : Un(c, r, s, e, n), gn("cross_domain_function", { id: c, name: s }) } function Jn(e, n, r, t) { var o, i = t.on, a = t.send; return function (e, n) { void 0 === n && (n = _n); var r = JSON.stringify(e, (function (e) { var r = this[e]; if (vn(this)) return r; var t = yn(r); if (!t) return r; var o = n[t] || En[t]; return o ? o(r, e) : r })); return void 0 === r ? "undefined" : r }(r, ((o = {}).promise = function (r, t) { return function (e, n, r, t, o) { return gn("cross_domain_zalgo_promise", { then: Bn(e, n, (function (e, n) { return r.then(e, n) }), t, { on: o.on, send: o.send }) }) }(e, n, r, t, { on: i, send: a }) }, o.function = function (r, t) { return Bn(e, n, r, t, { on: i, send: a }) }, o.object = function (e) { return Y(e) || Mn.isProxyWindow(e) ? gn("cross_domain_window", Mn.serialize(e, { send: a })) : e }, o)) } function Hn(e, n, r, t) { var o, i = t.send; return function (e, n) { if (void 0 === n && (n = On), "undefined" !== e) return JSON.parse(e, (function (e, r) { if (vn(this)) return r; var t, o; if (vn(r) ? (t = r.__type__, o = r.__val__) : (t = yn(r), o = r), !t) return o; var i = n[t] || xn[t]; return i ? i(o, e) : o })) }(r, ((o = {}).cross_domain_zalgo_promise = function (e) { return function (e, n, r) { return new p(r.then) }(0, 0, e) }, o.cross_domain_function = function (r) { return function (e, n, r, t) { var o = r.id, i = r.name, a = t.send, u = function (r) { function t() { var u = arguments; return Mn.toProxyWindow(e, { send: a }).awaitWindow().then((function (e) { var c = qn(e, o); if (c && c.val !== t) return c.val.apply({ source: window, origin: P() }, u); var s = [].slice.call(u); return r.fireAndForget ? a(e, "postrobot_method", { id: o, name: i, args: s }, { domain: n, fireAndForget: !0 }) : a(e, "postrobot_method", { id: o, name: i, args: s }, { domain: n, fireAndForget: !1 }).then((function (e) { return e.data.result })) })).catch((function (e) { throw e })) } return void 0 === r && (r = {}), t.__name__ = i, t.__origin__ = n, t.__source__ = e, t.__id__ = o, t.origin = n, t }, c = u(); return c.fireAndForget = u({ fireAndForget: !0 }), c }(e, n, r, { send: i }) }, o.cross_domain_window = function (e) { return Mn.deserialize(e, { send: i }) }, o)) } var Yn = {}; function Vn(e, n, r, t) { var o = t.on, i = t.send; return p.try((function () { var t = fn().getOrSet(e, (function () { return {} })); return t.buffer = t.buffer || [], t.buffer.push(r), t.flush = t.flush || p.flush().then((function () { if (I(e)) throw new Error("Window is closed"); var r, a = Jn(e, n, ((r = {}).__post_robot_10_0_44__ = t.buffer || [], r), { on: o, send: i }); delete t.buffer; for (var u = Object.keys(Yn), c = [], s = 0; s < u.length; s++) { var f = u[s]; try { Yn[f](e, a, n) } catch (e) { c.push(e) } } if (c.length === u.length) throw new Error("All post-robot messaging strategies failed:\n\n" + c.map((function (e, n) { return n + ". " + we(e) })).join("\n\n")) })), t.flush.then((function () { delete t.flush })) })).then(he) } function Zn(e) { return an("responseListeners").get(e) } function Gn(e) { an("responseListeners").del(e) } function $n(e) { return an("erroredResponseListeners").has(e) } function Xn(e) { var n = e.name, r = e.win, t = e.domain, o = fn("requestListeners"); if ("*" === r && (r = null), "*" === t && (t = null), !n) throw new Error("Name required to get request listener"); for (var i = 0, a = [r, sn()]; i < a.length; i++) { var u = a[i]; if (u) { var c = o.get(u); if (c) { var s = c[n]; if (s) { if (t && "string" == typeof t) { if (s[t]) return s[t]; if (s.__domain_regex__) for (var f = 0, d = s.__domain_regex__; f < d.length; f++) { var l = d[f], h = l.listener; if (B(l.regex, t)) return h } } if (s["*"]) return s["*"] } } } } } function Kn(e, n, r, t) { var o = t.on, i = t.send, a = Xn({ name: r.name, win: e, domain: n }), u = "postrobot_method" === r.name && r.data && "string" == typeof r.data.name ? r.data.name + "()" : r.name; function c(t, a, c) { return p.flush().then((function () { if (!r.fireAndForget && !I(e)) try { return Vn(e, n, { id: ae(), origin: P(window), type: "postrobot_message_response", hash: r.hash, name: r.name, ack: t, data: a, error: c }, { on: o, send: i }) } catch (e) { throw new Error("Send response message failed for " + u + " in " + P() + "\n\n" + we(e)) } })) } return p.all([p.flush().then((function () { if (!r.fireAndForget && !I(e)) try { return Vn(e, n, { id: ae(), origin: P(window), type: "postrobot_message_ack", hash: r.hash, name: r.name }, { on: o, send: i }) } catch (e) { throw new Error("Send ack message failed for " + u + " in " + P() + "\n\n" + we(e)) } })), p.try((function () { if (!a) throw new Error("No handler found for post message: " + r.name + " from " + n + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname); if (!B(a.domain, n)) throw new Error("Request origin " + n + " does not match domain " + a.domain.toString()); return a.handler({ source: e, origin: n, data: r.data }) })).then((function (e) { return c("success", e) }), (function (e) { return c("error", null, e) }))]).then(he).catch((function (e) { if (a && a.handleError) return a.handleError(e); throw e })) } function Qn(e, n, r) { if (!$n(r.hash)) { var t = Zn(r.hash); if (!t) throw new Error("No handler found for post message ack for message: " + r.name + " from " + n + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname); try { if (!B(t.domain, n)) throw new Error("Ack origin " + n + " does not match domain " + t.domain.toString()); if (e !== t.win) throw new Error("Ack source does not match registered window") } catch (e) { t.promise.reject(e) } t.ack = !0 } } function er(e, n, r) { if (!$n(r.hash)) { var t, o = Zn(r.hash); if (!o) throw new Error("No handler found for post message response for message: " + r.name + " from " + n + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname); if (!B(o.domain, n)) throw new Error("Response origin " + n + " does not match domain " + (t = o.domain, Array.isArray(t) ? "(" + t.join(" | ") + ")" : w(t) ? "RegExp(" + t.toString() + ")" : t.toString())); if (e !== o.win) throw new Error("Response source does not match registered window"); Gn(r.hash), "error" === r.ack ? o.promise.reject(r.error) : "success" === r.ack && o.promise.resolve({ source: e, origin: n, data: r.data }) } } function nr(e, n) { var r = n.on, t = n.send, o = an("receivedMessages"); try { if (!window || window.closed || !e.source) return } catch (e) { return } var i = e.source, a = e.origin, u = function (e, n, r, t) { var o, i = t.on, a = t.send; try { o = Hn(n, r, e, { on: i, send: a }) } catch (e) { return } if (o && "object" == typeof o && null !== o) { var u = o.__post_robot_10_0_44__; if (Array.isArray(u)) return u } }(e.data, i, a, { on: r, send: t }); if (u) { mn(i); for (var c = 0; c < u.length; c++) { var s = u[c]; if (o.has(s.id)) return; if (o.set(s.id, !0), I(i) && !s.fireAndForget) return; 0 === s.origin.indexOf("file:") && (a = "file://"); try { "postrobot_message_request" === s.type ? Kn(i, a, s, { on: r, send: t }) : "postrobot_message_response" === s.type ? er(i, a, s) : "postrobot_message_ack" === s.type && Qn(i, a, s) } catch (e) { setTimeout((function () { throw e }), 0) } } } } function rr(e, n, r) { if (!e) throw new Error("Expected name"); if ("function" == typeof (n = n || {}) && (r = n, n = {}), !r) throw new Error("Expected handler"); (n = n || {}).name = e, n.handler = r || n.handler; var t = n.window, o = n.domain, i = function e(n, r) { var t = n.name, o = n.win, i = n.domain, a = fn("requestListeners"); if (!t || "string" != typeof t) throw new Error("Name required to add request listener"); if (Array.isArray(o)) { for (var u = [], c = 0, s = o; c < s.length; c++)u.push(e({ name: t, domain: i, win: s[c] }, r)); return { cancel: function () { for (var e = 0; e < u.length; e++)u[e].cancel() } } } if (Array.isArray(i)) { for (var f = [], d = 0, l = i; d < l.length; d++)f.push(e({ name: t, win: o, domain: l[d] }, r)); return { cancel: function () { for (var e = 0; e < f.length; e++)f[e].cancel() } } } var h = Xn({ name: t, win: o, domain: i }); if (o && "*" !== o || (o = sn()), i = i || "*", h) throw o && i ? new Error("Request listener already exists for " + t + " on domain " + i.toString() + " for " + (o === sn() ? "wildcard" : "specified") + " window") : o ? new Error("Request listener already exists for " + t + " for " + (o === sn() ? "wildcard" : "specified") + " window") : i ? new Error("Request listener already exists for " + t + " on domain " + i.toString()) : new Error("Request listener already exists for " + t); var p, w, m = a.getOrSet(o, (function () { return {} })), v = xe(m, t, (function () { return {} })), y = i.toString(); return _e(i) ? (p = xe(v, "__domain_regex__", (function () { return [] }))).push(w = { regex: i, listener: r }) : v[y] = r, { cancel: function () { delete v[y], w && (p.splice(p.indexOf(w, 1)), p.length || delete v.__domain_regex__), Object.keys(v).length || delete m[t], o && !Object.keys(m).length && a.del(o) } } }({ name: e, win: t, domain: o }, { handler: n.handler, handleError: n.errorHandler || function (e) { throw e }, window: t, domain: o || "*", name: e }); return { cancel: function () { i.cancel() } } } Yn.postrobot_post_message = function (e, n, r) { 0 === r.indexOf("file:") && (r = "*"), e.postMessage(n, r) }, Yn.postrobot_bridge = function (e, n, r) { if (!Pn() && !Wn()) throw new Error("Bridge not needed for browser"); if (C(e)) throw new Error("Post message through bridge disabled between same domain windows"); if (!1 !== q(window, e)) throw new Error("Can only use bridge to communicate between two different windows, not between frames"); !function (e, n, r) { var t = F(window, e), o = F(e, window); if (!t && !o) throw new Error("Can only send messages to and from parent and popup windows"); Rn(e).then((function (t) { return t(e, n, r) })) }(e, r, n) }, Yn.postrobot_global = function (e, n) { if (!A(window).match(/MSIE|rv:11|trident|edge\/12|edge\/13/i)) throw new Error("Global messaging not needed for browser"); if (!C(e)) throw new Error("Post message through global disabled between different domain windows"); if (!1 !== q(window, e)) throw new Error("Can only use global to communicate between two different windows, not between frames"); var r = tn(e); if (!r) throw new Error("Can not find postRobot global on foreign window"); r.receiveMessage({ source: window, origin: P(), data: n }) }; var tr, or = function e(n, r, t, o) { var i = (o = o || {}).domain || "*", a = o.timeout || -1, u = o.timeout || 5e3, c = o.fireAndForget || !1; return p.try((function () { if (function (e, n, r) { if (!e) throw new Error("Expected name"); if (r && "string" != typeof r && !Array.isArray(r) && !_e(r)) throw new TypeError("Can not send " + e + ". Expected domain " + JSON.stringify(r) + " to be a string, array, or regex"); if (I(n)) throw new Error("Can not send " + e + ". Target window is closed") }(r, n, i), function (e, n) { var r = L(n); if (r) return r === e; if (n === e) return !1; if (k(n) === n) return !1; for (var t = 0, o = T(e); t < o.length; t++)if (o[t] === n) return !0; return !1 }(window, n)) return wn(n, u) })).then((function (r) { return function (e, n, r, t) { var o = t.send; return p.try((function () { return "string" == typeof n ? n : p.try((function () { return r || hn(e, { send: o }).then((function (e) { return e.domain })) })).then((function (e) { if (!B(n, n)) throw new Error("Domain " + me(n) + " does not match " + me(n)); return e })) })) }(n, i, (void 0 === r ? {} : r).domain, { send: e }) })).then((function (o) { var i = o, u = "postrobot_method" === r && t && "string" == typeof t.name ? t.name + "()" : r, s = new p, f = r + "_" + ae(); if (!c) { var d = { name: r, win: n, domain: i, promise: s }; !function (e, n) { an("responseListeners").set(e, n) }(f, d); var l = fn("requestPromises").getOrSet(n, (function () { return [] })); l.push(s), s.catch((function () { !function (e) { an("erroredResponseListeners").set(e, !0) }(f), Gn(f) })); var h = function (e) { return fn("knownWindows").get(e, !1) }(n) ? 1e4 : 2e3, w = a, m = h, v = w, y = ge((function () { return I(n) ? s.reject(new Error("Window closed for " + r + " before " + (d.ack ? "response" : "ack"))) : d.cancelled ? s.reject(new Error("Response listener was cancelled for " + r)) : (m = Math.max(m - 500, 0), -1 !== v && (v = Math.max(v - 500, 0)), d.ack || 0 !== m ? 0 === v ? s.reject(new Error("No response for postMessage " + u + " in " + P() + " in " + w + "ms")) : void 0 : s.reject(new Error("No ack for postMessage " + u + " in " + P() + " in " + h + "ms"))) }), 500); s.finally((function () { y.cancel(), l.splice(l.indexOf(s, 1)) })).catch(he) } return Vn(n, i, { id: ae(), origin: P(window), type: "postrobot_message_request", hash: f, name: r, data: t, fireAndForget: c }, { on: rr, send: e }).then((function () { return c ? s.resolve() : s }), (function (e) { throw new Error("Send request message failed for " + u + " in " + P() + "\n\n" + we(e)) })) })) }; function ir(e) { return Mn.toProxyWindow(e, { send: or }) } function ar(e) { for (var n = 0, r = fn("requestPromises").get(e, []); n < r.length; n++)r[n].reject(new Error("Window " + (I(e) ? "closed" : "cleaned up") + " before response")).catch(he) } function ur(e) { if (!C(e)) throw new Error("Can not get global for window on different domain"); return e.__zoid_9_0_82__ || (e.__zoid_9_0_82__ = {}), e.__zoid_9_0_82__ } function cr(e, n) { try { return n(ur(e)) } catch (e) { } } function sr(e) { return { get: function () { var n = this; return p.try((function () { if (n.source && n.source !== window) throw new Error("Can not call get on proxy object from a remote window"); return e })) } } } function fr(e) { return ie(JSON.stringify(e)) } function dr(e) { var n = ur(e); return n.references = n.references || {}, n.references } function lr(e) { var n, r, t = e.data, o = e.metaData, i = e.sender, a = e.receiver, u = e.passByReference, c = void 0 !== u && u, s = e.basic, f = void 0 !== s && s, d = ir(a.win), l = f ? JSON.stringify(t) : Jn(d, a.domain, t, { on: rr, send: or }), h = c ? (n = l, r = ae(), dr(window)[r] = n, { type: "uid", uid: r }) : { type: "raw", val: l }; return { serializedData: fr({ sender: { domain: i.domain }, metaData: o, reference: h }), cleanReference: function () { var e, n; e = window, "uid" === (n = h).type && delete dr(e)[n.uid] } } } function hr(e) { var n, r, t = e.sender, o = e.basic, i = void 0 !== o && o, a = function (e) { return JSON.parse(function (e) { if ("function" == typeof atob) return decodeURIComponent([].map.call(atob(e), (function (e) { return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2) })).join("")); if ("undefined" != typeof Buffer) return Buffer.from(e, "base64").toString("utf8"); throw new Error("Can not find window.atob or Buffer") }(e)) }(e.data), u = a.reference, c = a.metaData; n = "function" == typeof t.win ? t.win({ metaData: c }) : t.win, r = "function" == typeof t.domain ? t.domain({ metaData: c }) : "string" == typeof t.domain ? t.domain : a.sender.domain; var s = function (e, n) { if ("raw" === n.type) return n.val; if ("uid" === n.type) return dr(e)[n.uid]; throw new Error("Unsupported ref type: " + n.type) }(n, u); return { data: i ? JSON.parse(s) : function (e, n, r) { return Hn(e, n, r, { on: rr, send: or }) }(n, r, s), metaData: c, sender: { win: n, domain: r }, reference: u } } tr = { setupBridge: zn, openBridge: function (e, n) { var r = an("bridges"), t = an("bridgeFrames"); return n = n || J(e), r.getOrSet(n, (function () { return p.try((function () { if (P() === n) throw new Error("Can not open bridge on the same domain as current domain: " + n); var r = Tn(n); if (z(window, r)) throw new Error("Frame with name " + r + " already exists on page"); var o = function (e, n) { var r = document.createElement("iframe"); return r.setAttribute("name", e), r.setAttribute("id", e), r.setAttribute("style", "display: none; margin: 0; padding: 0; border: 0px none; overflow: hidden;"), r.setAttribute("frameborder", "0"), r.setAttribute("border", "0"), r.setAttribute("scrolling", "no"), r.setAttribute("allowTransparency", "true"), r.setAttribute("tabindex", "-1"), r.setAttribute("hidden", "true"), r.setAttribute("title", ""), r.setAttribute("role", "presentation"), r.src = n, r }(r, e); return t.set(n, o), kn.then((function (n) { n.appendChild(o); var r = o.contentWindow; return new p((function (e, n) { o.addEventListener("load", e), o.addEventListener("error", n) })).then((function () { return wn(r, 5e3, "Bridge " + e) })).then((function () { return r })) })) })) })) }, linkWindow: An, linkUrl: function (e, n) { An({ win: e, domain: J(n) }) }, isBridge: Wn, needsBridge: Dn, needsBridgeForBrowser: Pn, hasBridge: function (e, n) { return an("bridges").has(n || J(e)) }, needsBridgeForWin: Cn, needsBridgeForDomain: Sn, destroyBridges: function () { for (var e = an("bridges"), n = an("bridgeFrames"), r = 0, t = n.keys(); r < t.length; r++) { var o = n.get(t[r]); o && o.parentNode && o.parentNode.removeChild(o) } n.reset(), e.reset() } }; var pr = { STRING: "string", OBJECT: "object", FUNCTION: "function", BOOLEAN: "boolean", NUMBER: "number", ARRAY: "array" }, wr = { JSON: "json", DOTIFY: "dotify", BASE64: "base64" }, mr = m, vr = { RENDER: "zoid-render", RENDERED: "zoid-rendered", DISPLAY: "zoid-display", ERROR: "zoid-error", CLOSE: "zoid-close", DESTROY: "zoid-destroy", PROPS: "zoid-props", RESIZE: "zoid-resize", FOCUS: "zoid-focus" }; function yr(e) { return "__zoid__" + e.name + "__" + e.serializedPayload + "__" } function gr(e) { if (!e) throw new Error("No window name"); var n = e.split("__"), r = n[1], t = n[2], o = n[3]; if ("zoid" !== r) throw new Error("Window not rendered by zoid - got " + r); if (!t) throw new Error("Expected component name"); if (!o) throw new Error("Expected serialized payload ref"); return { name: t, serializedInitialPayload: o } } var br = de((function (e) { var n = hr({ data: gr(e).serializedInitialPayload, sender: { win: function (e) { return function (e) { if ("opener" === e.type) return Pe("opener", _(window)); if ("parent" === e.type && "number" == typeof e.distance) return Pe("parent", (n = window, void 0 === (r = e.distance) && (r = 1), function (e, n) { void 0 === n && (n = 1); for (var r = e, t = 0; t < n; t++) { if (!r) return; r = E(r) } return r }(n, U(n) - r))); var n, r; if ("global" === e.type && e.uid && "string" == typeof e.uid) { var t = function () { var n = e.uid, r = L(window); if (!r) throw new Error("Can not find ancestor window"); for (var t = 0, o = N(r); t < o.length; t++) { var i = o[t]; if (C(i)) { var a = cr(i, (function (e) { return e.windows && e.windows[n] })); if (a) return { v: a } } } }(); if ("object" == typeof t) return t.v } else if ("name" === e.type) { var o = e.name; return Pe("namedWindow", function (e, n) { return z(e, n) || function e(n, r) { var t = z(n, r); if (t) return t; for (var o = 0, i = T(n); o < i.length; o++) { var a = e(i[o], r); if (a) return a } }(k(e) || e, n) }(Pe("ancestor", L(window)), o)) } throw new Error("Unable to find " + e.type + " parent component window") }(e.metaData.windowRef) } } }); return { parent: n.sender, payload: n.data, reference: n.reference } })); function Er() { return br(window.name) } function _r(e, n) { if (void 0 === n && (n = window), e === E(n)) return { type: "parent", distance: U(e) }; if (e === _(n)) return { type: "opener" }; if (C(e) && (t = e) !== k(t)) { var r = S(e).name; if (r) return { type: "name", name: r } } var t } function xr(e, n, r, t, o) { if (!e.hasOwnProperty(r)) return t; var i = e[r]; return "function" == typeof i.childDecorate ? i.childDecorate({ value: t, uid: o.uid, tag: o.tag, close: o.close, focus: o.focus, onError: o.onError, onProps: o.onProps, resize: o.resize, getParent: o.getParent, getParentDomain: o.getParentDomain, show: o.show, hide: o.hide, export: o.export, getSiblings: o.getSiblings }) : t } function Or() { return p.try((function () { window.focus() })) } function Pr() { return p.try((function () { window.close() })) } var Cr = function () { return he }, Sr = function (e) { return pe(e.value) }; function Dr(e, n, r) { for (var t = 0, o = Object.keys(e); t < o.length; t++) { var i = o[t], a = n[i]; a && r(i, a, e[i]) } } function Tr(e, n, r) { var t = {}; return p.all(function (e, n, o) { var i = []; return Dr(e, n, (function (e, n, o) { var a = function (e, n, o) { return p.resolve().then((function () { var i, a; if (null != o) { var u = (i = {}, i.get = n.queryParam, i.post = n.bodyParam, i)[r], c = (a = {}, a.get = n.queryValue, a.post = n.bodyValue, a)[r]; if (u) return p.hash({ finalParam: p.try((function () { return "function" == typeof u ? u({ value: o }) : "string" == typeof u ? u : e })), finalValue: p.try((function () { return "function" == typeof c && Ee(o) ? c({ value: o }) : o })) }).then((function (r) { var o, i = r.finalParam, a = r.finalValue; if ("boolean" == typeof a) o = a.toString(); else if ("string" == typeof a) o = a.toString(); else if ("object" == typeof a && null !== a) { if (n.serialization === wr.JSON) o = JSON.stringify(a); else if (n.serialization === wr.BASE64) o = ie(JSON.stringify(a)); else if (n.serialization === wr.DOTIFY || !n.serialization) { o = function e(n, r, t) { for (var o in void 0 === r && (r = ""), void 0 === t && (t = {}), r = r ? r + "." : r, n) n.hasOwnProperty(o) && null != n[o] && "function" != typeof n[o] && (n[o] && Array.isArray(n[o]) && n[o].length && n[o].every((function (e) { return "object" != typeof e })) ? t["" + r + o + "[]"] = n[o].join(",") : n[o] && "object" == typeof n[o] ? t = e(n[o], "" + r + o, t) : t["" + r + o] = n[o].toString()); return t }(a, e); for (var u = 0, c = Object.keys(o); u < c.length; u++) { var s = c[u]; t[s] = o[s] } return } } else "number" == typeof a && (o = a.toString()); t[i] = o })) } })) }(e, n, o); i.push(a) })), i }(n, e)).then((function () { return t })) } function Wr(e) { var n, r, t, o, a, u, c, s = e.uid, f = e.options, d = e.overrides, l = void 0 === d ? {} : d, h = e.parentWin, w = void 0 === h ? window : h, m = f.propsDef, v = f.containerTemplate, y = f.prerenderTemplate, g = f.tag, b = f.name, E = f.attributes, _ = f.dimensions, x = f.autoResize, O = f.url, D = f.domain, T = f.exports, W = new p, k = [], N = Oe(), R = {}, j = { visible: !0 }, A = l.event ? l.event : (n = {}, r = {}, t = { on: function (e, n) { var t = r[e] = r[e] || []; t.push(n); var o = !1; return { cancel: function () { o || (o = !0, t.splice(t.indexOf(n), 1)) } } }, once: function (e, n) { var r = t.on(e, (function () { r.cancel(), n() })); return r }, trigger: function (e) { for (var n = arguments.length, t = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)t[o - 1] = arguments[o]; var i = r[e], a = []; if (i) for (var u = function (e) { var n = i[e]; a.push(p.try((function () { return n.apply(void 0, t) }))) }, c = 0; c < i.length; c++)u(c); return p.all(a).then(he) }, triggerOnce: function (e) { if (n[e]) return p.resolve(); n[e] = !0; for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)o[i - 1] = arguments[i]; return t.trigger.apply(t, [e].concat(o)) }, reset: function () { r = {} } }), z = l.props ? l.props : {}, F = l.onError, M = l.getProxyContainer, Y = l.show, Z = l.hide, $ = l.close, X = l.renderContainer, K = l.getProxyWindow, Q = l.setProxyWin, ee = l.openFrame, ne = l.openPrerenderFrame, re = l.prerender, te = l.open, oe = l.openPrerender, ie = l.watchForUnload, ue = l.getInternalState, ce = l.setInternalState, se = function () { return "function" == typeof _ ? _({ props: z }) : _ }, fe = function () { return p.try((function () { return l.resolveInitPromise ? l.resolveInitPromise() : W.resolve() })) }, le = function (e) { return p.try((function () { return l.rejectInitPromise ? l.rejectInitPromise(e) : W.reject(e) })) }, ye = function (e) { for (var n = {}, r = 0, t = Object.keys(z); r < t.length; r++) { var o = t[r], i = m[o]; i && !1 === i.sendToChild || i && i.sameDomain && !B(e, P(window)) || (n[o] = z[o]) } return p.hash(n) }, _e = function () { return p.try((function () { return ue ? ue() : j })) }, xe = function (e) { return p.try((function () { return ce ? ce(e) : j = i({}, j, e) })) }, Pe = function () { return K ? K() : p.try((function () { var e = z.window; if (e) { var n = ir(e); return N.register((function () { return e.close() })), n } return new Mn({ send: or }) })) }, Ce = function (e) { return M ? M(e) : p.try((function () { return Ae(e) })).then((function (e) { return Ze(e) && (e = function e(n) { var r = function (e) { var n = function (e) { for (; e.parentNode;)e = e.parentNode; if (Ze(e)) return e }(e); if (n && n.host) return n.host }(n); if (!r) throw new Error("Element is not in shadow dom"); var t = "shadow-slot-" + ae(), o = document.createElement("slot"); o.setAttribute("name", t), n.appendChild(o); var i = document.createElement("div"); return i.setAttribute("slot", t), r.appendChild(i), Ze(r) ? e(i) : i }(e)), sr(e) })) }, Se = function (e) { return Q ? Q(e) : p.try((function () { o = e })) }, De = function () { return Y ? Y() : p.hash({ setState: xe({ visible: !0 }), showElement: a ? a.get().then(Be) : null }).then(he) }, Te = function () { return Z ? Z() : p.hash({ setState: xe({ visible: !1 }), showElement: a ? a.get().then(Je) : null }).then(he) }, We = function () { return "function" == typeof O ? O({ props: z }) : O }, ke = function () { return "function" == typeof E ? E({ props: z }) : E }, je = function () { return J(We()) }, ze = function (e, n) { var r = n.windowName; return ee ? ee(e, { windowName: r }) : p.try((function () { if (e === mr.IFRAME) return sr(Ue({ attributes: i({ name: r, title: b }, ke().iframe) })) })) }, Le = function (e) { return ne ? ne(e) : p.try((function () { if (e === mr.IFRAME) return sr(Ue({ attributes: i({ name: "__zoid_prerender_frame__" + b + "_" + ae() + "__", title: "prerender__" + b }, ke().iframe) })) })) }, Ge = function (e, n, r) { return oe ? oe(e, n, r) : p.try((function () { if (e === mr.IFRAME) { if (!r) throw new Error("Expected proxy frame to be passed"); return r.get().then((function (e) { return N.register((function () { return He(e) })), Me(e).then((function (e) { return S(e) })).then((function (e) { return ir(e) })) })) } if (e === mr.POPUP) return n; throw new Error("No render context available for " + e) })) }, $e = function () { return p.try((function () { if (o) return p.all([A.trigger(vr.FOCUS), o.focus()]).then(he) })) }, Xe = function () { var e = ur(window); return e.windows = e.windows || {}, e.windows[s] = window, N.register((function () { delete e.windows[s] })), s }, Ke = function (e, n, r, t) { if (n === P(window)) return { type: "global", uid: Xe() }; if (e !== window) throw new Error("Can not construct cross-domain window reference for different target window"); if (z.window) { var o = t.getWindow(); if (!o) throw new Error("Can not construct cross-domain window reference for lazy window prop"); if (L(o) !== window) throw new Error("Can not construct cross-domain window reference for window prop with different ancestor") } if (r === mr.POPUP) return { type: "opener" }; if (r === mr.IFRAME) return { type: "parent", distance: U(window) }; throw new Error("Can not construct window reference for child") }, Qe = function (e, n) { return p.try((function () { c = e, u = n, fe(), N.register((function () { return n.close.fireAndForget().catch(he) })) })) }, en = function (e) { var n = e.width, r = e.height; return p.try((function () { A.trigger(vr.RESIZE, { width: n, height: r }) })) }, nn = function (e) { return p.try((function () { return A.trigger(vr.DESTROY) })).catch(he).then((function () { return N.all(e) })).then((function () { W.asyncReject(e || new Error("Component destroyed")) })) }, tn = de((function (e) { return p.try((function () { if ($) { if (I($.__source__)) return; return $() } return p.try((function () { return A.trigger(vr.CLOSE) })).then((function () { return nn(e || new Error("Component closed")) })) })) })), on = function (e, n) { var r = n.proxyWin, t = n.proxyFrame, o = n.windowName; return te ? te(e, { proxyWin: r, proxyFrame: t, windowName: o }) : p.try((function () { if (e === mr.IFRAME) { if (!t) throw new Error("Expected proxy frame to be passed"); return t.get().then((function (e) { return Me(e).then((function (n) { return N.register((function () { return He(e) })), N.register((function () { return ar(n) })), n })) })) } if (e === mr.POPUP) { var n = se(), r = n.width, a = void 0 === r ? "300px" : r, u = n.height, c = void 0 === u ? "150px" : u; a = rn(a, window.outerWidth), c = rn(c, window.outerWidth); var s = function (e, n) { var r = (n = n || {}).closeOnUnload, t = void 0 === r ? 1 : r, o = n.name, a = void 0 === o ? "" : o, u = n.width, c = n.height, s = 0, f = 0; u && (window.outerWidth ? f = Math.round((window.outerWidth - u) / 2) + window.screenX : window.screen.width && (f = Math.round((window.screen.width - u) / 2))), c && (window.outerHeight ? s = Math.round((window.outerHeight - c) / 2) + window.screenY : window.screen.height && (s = Math.round((window.screen.height - c) / 2))), delete n.closeOnUnload, delete n.name, u && c && (n = i({ top: s, left: f, width: u, height: c, status: 1, toolbar: 0, menubar: 0, resizable: 1, scrollbars: 1 }, n)); var d, l, h = Object.keys(n).map((function (e) { if (null != n[e]) return e + "=" + me(n[e]) })).filter(Boolean).join(","); try { d = window.open("", a, h) } catch (l) { throw new Fe("Can not open popup window - " + (l.stack || l.message)) } if (I(d)) throw new Fe("Can not open popup window - blocked"); return t && window.addEventListener("unload", (function () { return d.close() })), d }(0, i({ name: o, width: a, height: c }, ke().popup)); return N.register((function () { return G(s) })), N.register((function () { return ar(s) })), s } throw new Error("No render context available for " + e) })).then((function (e) { return r.setWindow(e, { send: or }), r.setName(o).then((function () { return r })) })) }, an = function () { return p.try((function () { var e = qe(window, "unload", pe((function () { nn(new Error("Window navigated away")) }))), n = H(w, nn, 3e3); if (N.register(n.cancel), N.register(e.cancel), ie) return ie() })) }, un = function (e) { var n = !1; return e.isClosed().then((function (r) { return r ? (n = !0, tn(new Error("Detected component window close"))) : p.delay(200).then((function () { return e.isClosed() })).then((function (e) { if (e) return n = !0, tn(new Error("Detected component window close")) })) })).then((function () { return n })) }, cn = function (e) { return F ? F(e) : p.try((function () { if (-1 === k.indexOf(e)) return k.push(e), W.asyncReject(e), A.trigger(vr.ERROR, e) })) }, sn = new p, fn = function (e) { return p.try((function () { sn.resolve(e) })) }; Qe.onError = cn; var dn = function (e, n) { return e({ uid: s, container: n.container, context: n.context, doc: n.doc, frame: n.frame, prerenderFrame: n.prerenderFrame, focus: $e, close: tn, state: R, props: z, tag: g, dimensions: se(), event: A }) }, ln = function (e, n) { var r = n.context; return re ? re(e, { context: r }) : p.try((function () { if (y) { var n = e.getWindow(); if (n && C(n) && function (e) { try { if (!e.location.href) return !0; if ("about:blank" === e.location.href) return !0 } catch (e) { } return !1 }(n)) { var t = (n = S(n)).document, o = dn(y, { context: r, doc: t }); if (o) { if (o.ownerDocument !== t) throw new Error("Expected prerender template to have been created with document from child window"); !function (e, n) { var r = n.tagName.toLowerCase(); if ("html" !== r) throw new Error("Expected element to be html, got " + r); for (var t = e.document.documentElement, o = 0, i = be(t.children); o < i.length; o++)t.removeChild(i[o]); for (var a = 0, u = be(n.children); a < u.length; a++)t.appendChild(u[a]) }(n, o); var i = x.width, a = void 0 !== i && i, u = x.height, c = void 0 !== u && u, s = x.element, f = void 0 === s ? "body" : s; if ((f = Ie(f, t)) && (a || c)) { var d = Ve(f, (function (e) { en({ width: a ? e.width : void 0, height: c ? e.height : void 0 }) }), { width: a, height: c, win: n }); A.on(vr.RENDERED, d.cancel) } } } } })) }, hn = function (e, n) { var r = n.proxyFrame, t = n.proxyPrerenderFrame, o = n.context, i = n.rerender; return X ? X(e, { proxyFrame: r, proxyPrerenderFrame: t, context: o, rerender: i }) : p.hash({ container: e.get(), frame: r ? r.get() : null, prerenderFrame: t ? t.get() : null, internalState: _e() }).then((function (e) { var n = e.container, r = e.internalState.visible, t = dn(v, { context: o, container: n, frame: e.frame, prerenderFrame: e.prerenderFrame, doc: document }); if (t) { r || Je(t), Re(n, t); var u = function (e, n) { n = pe(n); var r, t, o, i = !1, a = [], u = function () { i = !0; for (var e = 0; e < a.length; e++)a[e].disconnect(); r && r.cancel(), o && o.removeEventListener("unload", c), t && He(t) }, c = function () { i || (n(), u()) }; if (Ye(e)) return c(), { cancel: u }; if (window.MutationObserver) for (var s = e.parentElement; s;) { var f = new window.MutationObserver((function () { Ye(e) && c() })); f.observe(s, { childList: !0 }), a.push(f), s = s.parentElement } return (t = document.createElement("iframe")).setAttribute("name", "__detect_close_" + ae() + "__"), t.style.display = "none", Me(t).then((function (e) { (o = S(e)).addEventListener("unload", c) })), e.appendChild(t), r = ge((function () { Ye(e) && c() }), 1e3), { cancel: u } }(t, (function () { var e = new Error("Detected container element removed from DOM"); return p.delay(1).then((function () { if (!Ye(t)) return N.all(e), i().then(fe, le); tn(e) })) })); return N.register((function () { return u.cancel() })), N.register((function () { return He(t) })), a = sr(t) } })) }, pn = function () { return { state: R, event: A, close: tn, focus: $e, resize: en, onError: cn, updateProps: mn, show: De, hide: Te } }, wn = function (e, n) { void 0 === n && (n = !1); var r = pn(); !function (e, n, r, t, o) { void 0 === o && (o = !1), ve(n, r = r || {}); for (var i = o ? [] : [].concat(Object.keys(e)), a = 0, u = Object.keys(r); a < u.length; a++) { var c = u[a]; -1 === i.indexOf(c) && i.push(c) } for (var s = [], f = t.state, d = t.close, l = t.focus, h = t.event, p = t.onError, w = 0; w < i.length; w++) { var m = i[w], v = e[m], y = r[m]; if (v) { var g = v.alias; if (g && (!Ee(y) && Ee(r[g]) && (y = r[g]), s.push(g)), v.value && (y = v.value({ props: n, state: f, close: d, focus: l, event: h, onError: p })), !Ee(y) && v.default && (y = v.default({ props: n, state: f, close: d, focus: l, event: h, onError: p })), Ee(y) && ("array" === v.type ? !Array.isArray(y) : typeof y !== v.type)) throw new TypeError("Prop is not of type " + v.type + ": " + m); n[m] = y } } for (var b = 0; b < s.length; b++)delete n[s[b]]; Dr(n, e, (function (e, r, t) { if (r && Ee(t) && r.decorate) { var o = r.decorate({ value: t, props: n, state: f, close: d, focus: l, event: h, onError: p }); n[e] = o } })); for (var E = 0, _ = Object.keys(e); E < _.length; E++) { var x = _[E]; if (!1 !== e[x].required && !Ee(n[x])) throw new Error('Expected prop "' + x + '" to be defined') } }(m, z, e, r, n) }, mn = function (e) { return wn(e, !0), W.then((function () { var e = u, n = o; if (e && n && c) return ye(c).then((function (r) { return e.updateProps(r).catch((function (e) { return un(n).then((function (n) { if (!n) throw e })) })) })) })) }; return { init: function () { A.on(vr.RENDER, (function () { return z.onRender() })), A.on(vr.DISPLAY, (function () { return z.onDisplay() })), A.on(vr.RENDERED, (function () { return z.onRendered() })), A.on(vr.CLOSE, (function () { return z.onClose() })), A.on(vr.DESTROY, (function () { return z.onDestroy() })), A.on(vr.RESIZE, (function () { return z.onResize() })), A.on(vr.FOCUS, (function () { return z.onFocus() })), A.on(vr.PROPS, (function (e) { return z.onProps(e) })), A.on(vr.ERROR, (function (e) { return z && z.onError ? z.onError(e) : le(e).then((function () { setTimeout((function () { throw e }), 1) })) })), N.register(A.reset) }, render: function (e) { var n = e.target, r = e.container, t = e.context, i = e.rerender; return p.try((function () { var e = je(), a = D || je(); !function (e, n, r) { if (e !== window) { if (!q(window, e)) throw new Error("Can only renderTo an adjacent frame"); var t = P(); if (!B(n, t) && !C(e)) throw new Error("Can not render remotely to " + n.toString() + " - can only render to " + t); if (r && "string" != typeof r) throw new Error("Container passed to renderTo must be a string selector, got " + typeof r + " }") } }(n, a, r); var u = p.try((function () { if (n !== window) return function (e, n) { for (var r = {}, t = 0, o = Object.keys(z); t < o.length; t++) { var i = o[t], a = m[i]; a && a.allowDelegate && (r[i] = z[i]) } var u = or(n, "zoid_delegate_" + b, { uid: s, overrides: { props: r, event: A, close: tn, onError: cn, getInternalState: _e, setInternalState: xe, resolveInitPromise: fe, rejectInitPromise: le } }).then((function (e) { var r = e.data.parent; return N.register((function (e) { if (!I(n)) return r.destroy(e) })), r.getDelegateOverrides() })).catch((function (e) { throw new Error("Unable to delegate rendering. Possibly the component is not loaded in the target window.\n\n" + we(e)) })); return M = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.getProxyContainer.apply(e, n) })) }, X = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.renderContainer.apply(e, n) })) }, Y = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.show.apply(e, n) })) }, Z = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.hide.apply(e, n) })) }, ie = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.watchForUnload.apply(e, n) })) }, e === mr.IFRAME ? (K = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.getProxyWindow.apply(e, n) })) }, ee = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.openFrame.apply(e, n) })) }, ne = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.openPrerenderFrame.apply(e, n) })) }, re = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.prerender.apply(e, n) })) }, te = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.open.apply(e, n) })) }, oe = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.openPrerender.apply(e, n) })) }) : e === mr.POPUP && (Q = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return u.then((function (e) { return e.setProxyWin.apply(e, n) })) }), u }(t, n) })), c = z.window, d = an(), l = Tr(m, z, "get").then((function (e) { return function (e, n) { var r, t, o = n.query || {}, i = n.hash || {}, a = e.split("#"); t = a[1]; var u = (r = a[0]).split("?"); r = u[0]; var c = Ne(u[1], o), s = Ne(t, i); return c && (r = r + "?" + c), s && (r = r + "#" + s), r }(V(We()), { query: e }) })), h = Tr(m, z, "post"), w = A.trigger(vr.RENDER), v = Ce(r), y = Pe(), E = y.then((function (r) { return function (e) { var n = void 0 === e ? {} : e, r = n.proxyWin, t = n.initialChildDomain, o = n.childDomainMatch, i = n.target, a = void 0 === i ? window : i, u = n.context; return function (e) { var n = void 0 === e ? {} : e, r = n.proxyWin, t = n.childDomainMatch, o = n.context; return ye(n.initialChildDomain).then((function (e) { return { uid: s, context: o, tag: g, childDomainMatch: t, version: "9_0_82", props: e, exports: (n = r, { init: function (e) { return Qe(this.origin, e) }, close: tn, checkClose: function () { return un(n) }, resize: en, onError: cn, show: De, hide: Te, export: fn }) }; var n })) }({ proxyWin: r, initialChildDomain: t, childDomainMatch: o, context: u }).then((function (e) { var n = lr({ data: e, metaData: { windowRef: Ke(a, t, u, r) }, sender: { domain: P(window) }, receiver: { win: r, domain: o }, passByReference: t === P() }), i = n.serializedData; return N.register(n.cleanReference), i })) }({ proxyWin: (o = { proxyWin: r, initialChildDomain: e, childDomainMatch: a, target: n, context: t }).proxyWin, initialChildDomain: o.initialChildDomain, childDomainMatch: o.childDomainMatch, target: o.target, context: o.context }).then((function (e) { return yr({ name: b, serializedPayload: e }) })); var o })), _ = E.then((function (e) { return ze(t, { windowName: e }) })), x = Le(t), O = p.hash({ proxyContainer: v, proxyFrame: _, proxyPrerenderFrame: x }).then((function (e) { return hn(e.proxyContainer, { context: t, proxyFrame: e.proxyFrame, proxyPrerenderFrame: e.proxyPrerenderFrame, rerender: i }) })).then((function (e) { return e })), S = p.hash({ windowName: E, proxyFrame: _, proxyWin: y }).then((function (e) { var n = e.proxyWin; return c ? n : on(t, { windowName: e.windowName, proxyWin: n, proxyFrame: e.proxyFrame }) })), T = p.hash({ proxyWin: S, proxyPrerenderFrame: x }).then((function (e) { return Ge(t, e.proxyWin, e.proxyPrerenderFrame) })), k = S.then((function (e) { return o = e, Se(e) })), R = p.hash({ proxyPrerenderWin: T, state: k }).then((function (e) { return ln(e.proxyPrerenderWin, { context: t }) })), j = p.hash({ proxyWin: S, windowName: E }).then((function (e) { if (c) return e.proxyWin.setName(e.windowName) })), F = p.hash({ body: h }).then((function (e) { return f.method ? f.method : Object.keys(e.body).length ? "post" : "get" })), L = p.hash({ proxyWin: S, windowUrl: l, body: h, method: F, windowName: j, prerender: R }).then((function (e) { return e.proxyWin.setLocation(e.windowUrl, { method: e.method, body: e.body }) })), U = S.then((function (e) { !function e(n, r) { var t = !1; return N.register((function () { t = !0 })), p.delay(2e3).then((function () { return n.isClosed() })).then((function (o) { if (!t) return o ? tn(new Error("Detected " + r + " close")) : e(n, r) })) }(e, t) })), H = p.hash({ container: O, prerender: R }).then((function () { return A.trigger(vr.DISPLAY) })), G = S.then((function (n) { return function (e, n, r) { return p.try((function () { return e.awaitWindow() })).then((function (e) { if (tr && tr.needsBridge({ win: e, domain: n }) && !tr.hasBridge(n, n)) { var t = "function" == typeof f.bridgeUrl ? f.bridgeUrl({ props: z }) : f.bridgeUrl; if (!t) throw new Error("Bridge needed to render " + r); var o = J(t); return tr.linkUrl(e, n), tr.openBridge(V(t), o) } })) }(n, e, t) })), $ = L.then((function () { return p.try((function () { var e = z.timeout; if (e) return W.timeout(e, new Error("Loading component timed out after " + e + " milliseconds")) })) })), ae = W.then((function () { return A.trigger(vr.RENDERED) })); return p.hash({ initPromise: W, buildUrlPromise: l, onRenderPromise: w, getProxyContainerPromise: v, openFramePromise: _, openPrerenderFramePromise: x, renderContainerPromise: O, openPromise: S, openPrerenderPromise: T, setStatePromise: k, prerenderPromise: R, loadUrlPromise: L, buildWindowNamePromise: E, setWindowNamePromise: j, watchForClosePromise: U, onDisplayPromise: H, openBridgePromise: G, runTimeoutPromise: $, onRenderedPromise: ae, delegatePromise: u, watchForUnloadPromise: d }) })).catch((function (e) { return p.all([cn(e), nn(e)]).then((function () { throw e }), (function () { throw e })) })).then(he) }, destroy: nn, getProps: function () { return z }, setProps: wn, export: fn, getHelpers: pn, getDelegateOverrides: function () { return p.try((function () { return { getProxyContainer: Ce, show: De, hide: Te, renderContainer: hn, getProxyWindow: Pe, watchForUnload: an, openFrame: ze, openPrerenderFrame: Le, prerender: ln, open: on, openPrerender: Ge, setProxyWin: Se } })) }, getExports: function () { return T({ getExports: function () { return sn } }) } } } function kr(e) { var n = e.uid, r = e.frame, t = e.prerenderFrame, o = e.doc, i = e.props, a = e.event, u = e.dimensions, c = u.width, s = u.height; if (r && t) { var f = o.createElement("div"); f.setAttribute("id", n); var d = o.createElement("style"); return i.cspNonce && d.setAttribute("nonce", i.cspNonce), d.appendChild(o.createTextNode("\n            #" + n + " {\n                display: inline-block;\n                position: relative;\n                width: " + c + ";\n                height: " + s + ";\n            }\n\n            #" + n + " > iframe {\n                display: inline-block;\n                position: absolute;\n                width: 100%;\n                height: 100%;\n                top: 0;\n                left: 0;\n                transition: opacity .2s ease-in-out;\n            }\n\n            #" + n + " > iframe.zoid-invisible {\n                opacity: 0;\n            }\n\n            #" + n + " > iframe.zoid-visible {\n                opacity: 1;\n        }\n        ")), f.appendChild(r), f.appendChild(t), f.appendChild(d), t.classList.add("zoid-visible"), r.classList.add("zoid-invisible"), a.on(vr.RENDERED, (function () { t.classList.remove("zoid-visible"), t.classList.add("zoid-invisible"), r.classList.remove("zoid-invisible"), r.classList.add("zoid-visible"), setTimeout((function () { He(t) }), 1) })), a.on(vr.RESIZE, (function (e) { var n = e.width, r = e.height; "number" == typeof n && (f.style.width = nn(n)), "number" == typeof r && (f.style.height = nn(r)) })), f } } function Nr(e) { var n = e.doc, r = e.props, t = n.createElement("html"), o = n.createElement("body"), i = n.createElement("style"), a = n.createElement("div"); return a.classList.add("spinner"), r.cspNonce && i.setAttribute("nonce", r.cspNonce), t.appendChild(o), o.appendChild(a), o.appendChild(i), i.appendChild(n.createTextNode("\n            html, body {\n                width: 100%;\n                height: 100%;\n            }\n\n            .spinner {\n                position: fixed;\n                max-height: 60vmin;\n                max-width: 60vmin;\n                height: 40px;\n                width: 40px;\n                top: 50%;\n                left: 50%;\n                box-sizing: border-box;\n                border: 3px solid rgba(0, 0, 0, .2);\n                border-top-color: rgba(33, 128, 192, 0.8);\n                border-radius: 100%;\n                animation: rotation .7s infinite linear;\n            }\n\n            @keyframes rotation {\n                from {\n                    transform: translateX(-50%) translateY(-50%) rotate(0deg);\n                }\n                to {\n                    transform: translateX(-50%) translateY(-50%) rotate(359deg);\n                }\n            }\n        ")), t } var Rr = Oe(), jr = Oe(); function Ir(e) { var n, r, t = function (e) { var n = e.tag, r = e.url, t = e.domain, o = e.bridgeUrl, a = e.props, u = void 0 === a ? {} : a, c = e.dimensions, s = void 0 === c ? {} : c, f = e.autoResize, d = void 0 === f ? {} : f, l = e.allowedParentDomains, h = void 0 === l ? "*" : l, p = e.attributes, w = void 0 === p ? {} : p, m = e.defaultContext, v = void 0 === m ? mr.IFRAME : m, y = e.containerTemplate, g = void 0 === y ? kr : y, b = e.prerenderTemplate, E = void 0 === b ? Nr : b, _ = e.validate, x = e.eligible, O = void 0 === x ? function () { return { eligible: !0 } } : x, P = e.logger, S = void 0 === P ? { info: he } : P, D = e.exports, T = void 0 === D ? he : D, W = e.method, k = e.children, N = void 0 === k ? function () { return {} } : k, R = n.replace(/-/g, "_"), j = i({}, { window: { type: pr.OBJECT, sendToChild: !1, required: !1, allowDelegate: !0, validate: function (e) { var n = e.value; if (!Y(n) && !Mn.isProxyWindow(n)) throw new Error("Expected Window or ProxyWindow"); if (Y(n)) { if (I(n)) throw new Error("Window is closed"); if (!C(n)) throw new Error("Window is not same domain") } }, decorate: function (e) { return ir(e.value) } }, timeout: { type: pr.NUMBER, required: !1, sendToChild: !1 }, cspNonce: { type: pr.STRING, required: !1 }, onDisplay: { type: pr.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: Cr, decorate: Sr }, onRendered: { type: pr.FUNCTION, required: !1, sendToChild: !1, default: Cr, decorate: Sr }, onRender: { type: pr.FUNCTION, required: !1, sendToChild: !1, default: Cr, decorate: Sr }, onClose: { type: pr.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: Cr, decorate: Sr }, onDestroy: { type: pr.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: Cr, decorate: Sr }, onResize: { type: pr.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: Cr }, onFocus: { type: pr.FUNCTION, required: !1, sendToChild: !1, allowDelegate: !0, default: Cr }, close: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.close } }, focus: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.focus } }, resize: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.resize } }, uid: { type: pr.STRING, required: !1, sendToChild: !1, childDecorate: function (e) { return e.uid } }, tag: { type: pr.STRING, required: !1, sendToChild: !1, childDecorate: function (e) { return e.tag } }, getParent: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.getParent } }, getParentDomain: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.getParentDomain } }, show: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.show } }, hide: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.hide } }, export: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.export } }, onError: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.onError } }, onProps: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.onProps } }, getSiblings: { type: pr.FUNCTION, required: !1, sendToChild: !1, childDecorate: function (e) { return e.getSiblings } } }, u); if (!g) throw new Error("Container template required"); return { name: R, tag: n, url: r, domain: t, bridgeUrl: o, method: W, propsDef: j, dimensions: s, autoResize: d, allowedParentDomains: h, attributes: w, defaultContext: v, containerTemplate: g, prerenderTemplate: E, validate: _, logger: S, eligible: O, children: N, exports: "function" == typeof T ? T : function (e) { for (var n = e.getExports, r = {}, t = function (e, t) { var o = t[e], i = T[o].type, a = n().then((function (e) { return e[o] })); r[o] = i === pr.FUNCTION ? function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return a.then((function (e) { return e.apply(void 0, n) })) } : a }, o = 0, i = Object.keys(T); o < i.length; o++)t(o, i); return r } } }(e), o = t.name, a = t.tag, u = t.defaultContext, c = t.eligible, s = t.children, f = ur(window), d = [], l = function () { if (function (e) { try { return gr(window.name).name === e } catch (e) { } return !1 }(o)) { var e = Er().payload; if (e.tag === a && B(e.childDomainMatch, P())) return !0 } return !1 }, h = de((function () { if (l()) { if (window.xprops) throw delete f.components[a], new Error("Can not register " + o + " as child - child already registered"); var e = function (e) { var n, r = e.tag, t = e.propsDef, o = e.autoResize, i = e.allowedParentDomains, a = [], u = Er(), c = u.parent, s = u.payload, f = c.win, d = c.domain, l = new p, h = s.version, w = s.uid, m = s.exports, v = s.context, y = s.props; if ("9_0_82" !== h) throw new Error("Parent window has zoid version " + h + ", child window has version 9_0_82"); var g = m.show, b = m.hide, E = m.close, _ = m.onError, x = m.checkClose, O = m.export, D = m.resize, T = m.init, W = function () { return f }, k = function () { return d }, R = function (e) { a.push(e) }, j = function (e) { return D.fireAndForget({ width: e.width, height: e.height }) }, I = function (e) { return l.resolve(e), O(e) }, A = function (e) { var t = (void 0 === e ? {} : e).anyParent, o = [], i = n.parent; if (void 0 === t && (t = !i), !t && !i) throw new Error("No parent found for " + r + " child"); for (var a = 0, u = N(window); a < u.length; a++) { var c = u[a]; if (C(c)) { var s = S(c).xprops; if (s && W() === s.getParent()) { var f = s.parent; if (t || !i || f && f.uid === i.uid) { var d = cr(c, (function (e) { return e.exports })); o.push({ props: s, exports: d }) } } } } return o }, z = function (e, o, i) { void 0 === i && (i = !1); var u = function (e, n, r, t, o, i) { void 0 === i && (i = !1); for (var a = {}, u = 0, c = Object.keys(r); u < c.length; u++) { var s = c[u], f = n[s]; if (!f || !f.sameDomain || t === P(window) && C(e)) { var d = xr(n, 0, s, r[s], o); a[s] = d, f && f.alias && !a[f.alias] && (a[f.alias] = d) } } if (!i) for (var l = 0, h = Object.keys(n); l < h.length; l++) { var p = h[l]; r.hasOwnProperty(p) || (a[p] = xr(n, 0, p, void 0, o)) } return a }(f, t, e, o, { tag: r, show: g, hide: b, close: E, focus: Or, onError: _, resize: j, getSiblings: A, onProps: R, getParent: W, getParentDomain: k, uid: w, export: I }, i); n ? ve(n, u) : n = u; for (var c = 0; c < a.length; c++)(0, a[c])(n) }, F = function (e) { return p.try((function () { return z(e, d, !0) })) }; return { init: function () { return p.try((function () { return C(f) && function (e) { var n = e.componentName, r = e.parentComponentWindow, t = hr({ data: gr(window.name).serializedInitialPayload, sender: { win: r }, basic: !0 }), o = t.sender; if ("uid" === t.reference.type || "global" === t.metaData.windowRef.type) { var i = lr({ data: t.data, metaData: { windowRef: _r(r) }, sender: { domain: o.domain }, receiver: { win: window, domain: P() }, basic: !0 }); window.name = yr({ name: n, serializedPayload: i.serializedData }) } }({ componentName: e.name, parentComponentWindow: f }), ur(window).exports = e.exports({ getExports: function () { return l } }), function (e, n) { if (!B(e, n)) throw new Error("Can not be rendered by domain: " + n) }(i, d), mn(f), window.addEventListener("beforeunload", (function () { x.fireAndForget() })), window.addEventListener("unload", (function () { x.fireAndForget() })), H(f, (function () { Pr() })), T({ updateProps: F, close: Pr }) })).then((function () { return (e = o.width, n = void 0 !== e && e, r = o.height, t = void 0 !== r && r, i = o.element, Ae(void 0 === i ? "body" : i).catch(he).then((function (e) { return { width: n, height: t, element: e } }))).then((function (e) { var n = e.width, r = e.height, t = e.element; t && (n || r) && v !== mr.POPUP && Ve(t, (function (e) { j({ width: n ? e.width : void 0, height: r ? e.height : void 0 }) }), { width: n, height: r }) })); var e, n, r, t, i })).catch((function (e) { _(e) })) }, getProps: function () { return n || (z(y, d), n) } } }(t); return e.init(), e } })); if (h(), n = rr("zoid_allow_delegate_" + o, (function () { return !0 })), r = rr("zoid_delegate_" + o, (function (e) { var n = e.data; return { parent: Wr({ uid: n.uid, options: t, overrides: n.overrides, parentWin: e.source }) } })), jr.register(n.cancel), jr.register(r.cancel), f.components = f.components || {}, f.components[a]) throw new Error("Can not register multiple components with the same tag: " + a); return f.components[a] = !0, { init: function e(n) { var r, f = "zoid-" + a + "-" + ae(), l = n || {}, h = c({ props: l }), w = h.eligible, m = h.reason, v = l.onDestroy; l.onDestroy = function () { if (r && w && d.splice(d.indexOf(r), 1), v) return v.apply(void 0, arguments) }; var y = Wr({ uid: f, options: t }); y.init(), w ? y.setProps(l) : l.onDestroy && l.onDestroy(), Rr.register((function (e) { return y.destroy(e || new Error("zoid destroyed all components")) })); var g = function (n) { var r = (void 0 === n ? {} : n).decorate; return e((void 0 === r ? ye : r)(l)) }, b = function (e, n, t) { return p.try((function () { if (!w) { var n = new Error(m || o + " component is not eligible"); return y.destroy(n).then((function () { throw n })) } if (!Y(e)) throw new Error("Must pass window to renderTo"); return function (e, n) { return p.try((function () { if (e.window) return ir(e.window).getType(); if (n) { if (n !== mr.IFRAME && n !== mr.POPUP) throw new Error("Unrecognized context: " + n); return n } return u })) }(l, t) })).then((function (o) { if (n = function (e, n) { if (n) { if ("string" != typeof n && !je(n)) throw new TypeError("Expected string or element selector to be passed"); return n } if (e === mr.POPUP) return "body"; throw new Error("Expected element to be passed to render iframe") }(o, n), e !== window && "string" != typeof n) throw new Error("Must pass string element when rendering to another window"); return y.render({ target: e, container: n, context: o, rerender: function () { var o = g(); return ve(r, o), o.renderTo(e, n, t) } }) })).catch((function (e) { return y.destroy(e).then((function () { throw e })) })) }; return r = i({}, y.getExports(), y.getHelpers(), function () { for (var e = s(), n = {}, r = function (r, t) { var o = t[r], a = e[o]; n[o] = function (e) { var n = y.getProps(), r = i({}, e, { parent: { uid: f, props: n, export: y.export } }); return a(r) } }, t = 0, o = Object.keys(e); t < o.length; t++)r(t, o); return n }(), { isEligible: function () { return w }, clone: g, render: function (e, n) { return b(window, e, n) }, renderTo: function (e, n, r) { return b(e, n, r) } }), w && d.push(r), r }, instances: d, driver: function (e, n) { throw new Error("Driver support not enabled") }, isChild: l, canRenderTo: function (e) { return or(e, "zoid_allow_delegate_" + o).then((function (e) { return e.data })).catch((function () { return !1 })) }, registerChild: h } } var Ar = function (e) { var n, r, t, o; tn().initialized || (tn().initialized = !0, r = (n = { on: rr, send: or }).on, t = n.send, (o = tn()).receiveMessage = o.receiveMessage || function (e) { return nr(e, { on: r, send: t }) }, function (e) { var n = e.on, r = e.send; an().getOrSet("postMessageListener", (function () { return qe(window, "message", (function (e) { !function (e, n) { var r = n.on, t = n.send; p.try((function () { var n = e.source || e.sourceElement, o = e.origin || e.originalEvent && e.originalEvent.origin, i = e.data; if ("null" === o && (o = "file://"), n) { if (!o) throw new Error("Post message did not have origin domain"); nr({ source: n, origin: o, data: i }, { on: r, send: t }) } })) }(e, { on: n, send: r }) })) })) }({ on: rr, send: or }), zn({ on: rr, send: or, receiveMessage: nr }), function (e) { var n = e.on, r = e.send; an("builtinListeners").getOrSet("helloListener", (function () { var e = n("postrobot_hello", { domain: "*" }, (function (e) { return ln(e.source, { domain: e.origin }), { instanceID: dn() } })), t = L(); return t && hn(t, { send: r }).catch((function (e) { })), e })) }({ on: rr, send: or })); var i = Ir(e), a = function (e) { return i.init(e) }; a.driver = function (e, n) { return i.driver(e, n) }, a.isChild = function () { return i.isChild() }, a.canRenderTo = function (e) { return i.canRenderTo(e) }, a.instances = i.instances; var u = i.registerChild(); return u && (window.xprops = a.xprops = u.getProps()), a }; function zr(e) { tr && tr.destroyBridges(); var n = Rr.all(e); return Rr = Oe(), n } var Fr = zr; function Lr(e) { var n; return Fr(), delete window.__zoid_9_0_82__, function () { for (var e = an("responseListeners"), n = 0, r = e.keys(); n < r.length; n++) { var t = r[n], o = e.get(t); o && (o.cancelled = !0), e.del(t) } }(), (n = an().get("postMessageListener")) && n.cancel(), delete window.__post_robot_10_0_44__, jr.all(e) } }]) }, 175: function (e, n, r) { var t = r(155); t && t.env && t.env.ZOID_FRAME_ONLY ? (e.exports = r(145), e.exports.default = e.exports) : (e.exports = r(548), e.exports.default = e.exports) } }, n = {}; function r(t) { var o = n[t]; if (void 0 !== o) return o.exports; var i = n[t] = { exports: {} }; return e[t].call(i.exports, i, i.exports, r), i.exports } r.n = function (e) { var n = e && e.__esModule ? function () { return e.default } : function () { return e }; return r.d(n, { a: n }), n }, r.d = function (e, n) { for (var t in n) r.o(n, t) && !r.o(e, t) && Object.defineProperty(e, t, { enumerable: !0, get: n[t] }) }, r.o = function (e, n) { return Object.prototype.hasOwnProperty.call(e, n) }, r.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }; var t = {}; return function () { "use strict"; function e(e, n) { for (var r = 0; r < n.length; r++) { var t = n[r]; t.enumerable = t.enumerable || !1, t.configurable = !0, "value" in t && (t.writable = !0), Object.defineProperty(e, t.key, t) } } r.r(t), r.d(t, { Auth: function () { return O } }); var n = function () { function n() { !function (e, n) { if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function") }(this, n), this.events = {} } var r, t, o; return r = n, t = [{ key: "_getEventListByName", value: function (e) { return void 0 === this.events[e] && (this.events[e] = new Set), this.events[e] } }, { key: "on", value: function (e, n) { this._getEventListByName(e).add(n) } }, { key: "once", value: function (e, n) { var r = this; this.on(e, (function t() { r.removeListener(e, t); for (var o = arguments.length, i = new Array(o), a = 0; a < o; a++)i[a] = arguments[a]; n.apply(r, i) })) } }, { key: "emit", value: function (e) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), t = 1; t < n; t++)r[t - 1] = arguments[t]; this._getEventListByName(e).forEach(function (e) { e.apply(this, r) }.bind(this)) } }, { key: "removeListener", value: function (e, n) { this._getEventListByName(e).delete(n) } }], t && e(r.prototype, t), o && e(r, o), n }(), o = n, i = Object.freeze({ Production: { AuthURL: "https://auth.onzauth.com", IdpURL: "https://idp.onzauth.com", IdpApiURL: "https://idp-api.onzauth.com" } }), a = Object.freeze({ OnAuthenticated: "authenticated", OnClosed: "closed", OnError: "error", OnRefreshed: "refreshed", OnLoggedOut: "logged_out" }), u = r(175), c = r.n(u), s = c().create({ tag: "onz-login-component", url: function (e) { var n = e.props; return new URL("signin", n.idpURL).href }, dimensions: { width: "350px", height: "575px" }, autoResize: { width: !1, height: !1 }, props: { idpURL: { type: "string", required: !0 }, clientID: { type: "string", required: !0, queryParam: "client_id" }, onLogin: { type: "function", required: !0 }, onLoginError: { type: "function", required: !0 } }, attributes: { iframe: { allow: "publickey-credentials-get *" } } }), f = c().create({ tag: "onz-logout-component", url: function (e) { var n = e.props; return new URL("logout", n.idpURL).href }, dimensions: { width: "0px", height: "0px" }, props: { idpURL: { type: "string", required: !0 }, idToken: { type: "string", required: !0, queryParam: "id_token" }, clientID: { type: "string", required: !0, queryParam: "client_id" }, onLogout: { type: "function", required: !0 }, onLogoutError: { type: "function", required: !0 } } }), d = r(669), l = r.n(d); function h(e) { this.message = e } h.prototype = new Error, h.prototype.name = "InvalidCharacterError"; var p = "undefined" != typeof window && window.atob && window.atob.bind(window) || function (e) { var n = String(e).replace(/=+$/, ""); if (n.length % 4 == 1) throw new h("'atob' failed: The string to be decoded is not correctly encoded."); for (var r, t, o = 0, i = 0, a = ""; t = n.charAt(i++); ~t && (r = o % 4 ? 64 * r + t : t, o++ % 4) ? a += String.fromCharCode(255 & r >> (-2 * o & 6)) : 0)t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(t); return a }; function w(e) { var n = e.replace(/-/g, "+").replace(/_/g, "/"); switch (n.length % 4) { case 0: break; case 2: n += "=="; break; case 3: n += "="; break; default: throw "Illegal base64url string!" }try { return function (e) { return decodeURIComponent(p(e).replace(/(.)/g, (function (e, n) { var r = n.charCodeAt(0).toString(16).toUpperCase(); return r.length < 2 && (r = "0" + r), "%" + r }))) }(n) } catch (e) { return p(n) } } function m(e) { this.message = e } m.prototype = new Error, m.prototype.name = "InvalidTokenError"; var v = function (e, n) { if ("string" != typeof e) throw new m("Invalid token specified"); var r = !0 === (n = n || {}).header ? 0 : 1; try { return JSON.parse(w(e.split(".")[r])) } catch (e) { throw new m("Invalid token specified: " + e.message) } }; function y(e) { return y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, y(e) } function g(e, n) { for (var r = 0; r < n.length; r++) { var t = n[r]; t.enumerable = t.enumerable || !1, t.configurable = !0, "value" in t && (t.writable = !0), Object.defineProperty(e, t.key, t) } } function b(e, n) { return b = Object.setPrototypeOf || function (e, n) { return e.__proto__ = n, e }, b(e, n) } function E(e) { var n = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var r, t = x(e); if (n) { var o = x(this).constructor; r = Reflect.construct(t, arguments, o) } else r = t.apply(this, arguments); return _(this, r) } } function _(e, n) { if (n && ("object" === y(n) || "function" == typeof n)) return n; if (void 0 !== n) throw new TypeError("Derived constructors may only return object or undefined"); return function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) } function x(e) { return x = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, x(e) } var O = function (e) { !function (e, n) { if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(n && n.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), n && b(e, n) }(u, e); var n, r, t, o = E(u); function u(e) { var n, r; if (function (e, n) { if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function") }(this, u), r = o.call(this), !e) throw new Exception("invalid auth options"); if (!e.clientID) throw new Exception("invalid clientID"); return r.clientID = e.clientID, r.containerID = null !== (n = e.containerID) && void 0 !== n ? n : "container", r.isIframe = e.isIframe ? "iframe" : "popup", r._currentComponent = null, r._initialiseURL(), r } return n = u, r = [{ key: "_initialiseURL", value: function () { this.urls = i.Production } }, { key: "_newLoginComponent", value: function () { var e = this; return s({ clientID: this.clientID, idpURL: this.urls.IdpURL, onLogin: function (n) { e._setSession(n), e.emit(a.OnAuthenticated, n) }, onLoginError: function (n) { e.emit(a.OnError, n) }, onClose: function () { e.emit(a.OnClosed), e._currentComponent = null }, onError: function (n) { var r = n && n.message ? n.message.toString() : n; e.emit(a.OnError, r) } }) } }, { key: "_newLogoutComponent", value: function (e) { var n = this; return f({ idToken: e, clientID: this.clientID, idpURL: this.urls.IdpURL, onLogout: function () { n._setSession(null), n.emit(a.OnLoggedOut) }, onLogoutError: function (e) { n.emit(a.OnError, e) }, onClose: function () { n.emit(a.OnClosed) }, onError: function (e) { var r = e && e.message ? e.message.toString() : e; n.emit(a.OnError, r) } }) } }, { key: "_setSession", value: function (e) { e ? (e.accessToken && localStorage.setItem("access_token", e.accessToken), e.idToken && localStorage.setItem("id_token", e.idToken), e.refreshToken && localStorage.setItem("refresh_token", e.refreshToken), e.expiry && localStorage.setItem("expiry", e.expiry)) : (localStorage.removeItem("access_token"), localStorage.removeItem("id_token"), localStorage.removeItem("refresh_token"), localStorage.removeItem("expiry")) } }, { key: "showLogin", value: function () { var e = this; this._currentComponent ? this._currentComponent.close().then((function () { e.emit(a.OnClosed), e._currentComponent = e._newLoginComponent(), e._currentComponent.render("#".concat(e.containerID), e.isIframe) })) : (this._currentComponent = this._newLoginComponent(), this._currentComponent.render("#".concat(this.containerID), this.isIframe)) } }, { key: "isLoggingIn", value: function () { return this._currentComponent } }, { key: "updateOptions", value: function (e) { e.clientID && e.clientID !== this.clientID && (this.clientID = e.clientID), e.containerID && e.containerID !== this.containerID && (this.containerID = e.containerID), !!e.isIframe != ("iframe" === this.isIframe) && (this.isIframe = e.isIframe ? "iframe" : "popup") } }, { key: "close", value: function () { var e = this; this._currentComponent && this._currentComponent.close().then((function () { e.emit(a.OnClosed) })) } }, { key: "refreshAccessToken", value: function () { var e = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getRefreshToken(), r = new URL("public/refresh", this.urls.IdpApiURL).href; l().post(r, { clientId: this.clientID, refreshToken: n }).then((function (n) { n.data && (e._setSession(n.data), e.emit(a.OnRefreshed, n.data)) })).catch((function (n) { n.response && n.response.data && n.response.data.message ? e.emit(a.OnError, n.response.data.message) : e.emit(a.OnError, "unknown-error") })) } }, { key: "logout", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getIDToken(); if (e) { var n = document.getElementById("onzHiddenFrame"); if (null === n) { var r = document.createElement("div"); r.id = "onzHiddenFrame", r.style.display = "none", document.body.appendChild(r) } this._newLogoutComponent(e).render("#onzHiddenFrame") } else this.emit(a.OnError, "no id token provided") } }, { key: "isAuthenticated", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getAccessToken(); if (!e) return !1; var n = v(e), r = Date.now() / 1e3; return !(n.exp < r) } }, { key: "getOAuthTokens", value: function () { return localStorage.getItem("access_token") ? { accessToken: localStorage.getItem("access_token"), idToken: localStorage.getItem("id_token"), refreshToken: localStorage.getItem("refresh_token"), expiry: localStorage.getItem("expiry") } : null } }, { key: "getAccessToken", value: function () { return window.localStorage.getItem("access_token") } }, { key: "getDecodedAccessToken", value: function () { var e = this.getAccessToken(), n = v(e); return n || null } }, { key: "getIDToken", value: function () { return window.localStorage.getItem("id_token") } }, { key: "getDecodedIDToken", value: function () { var e = this.getIDToken(), n = v(e); return n || null } }, { key: "getRefreshToken", value: function () { return window.localStorage.getItem("refresh_token") } }], r && g(n.prototype, r), t && g(n, t), u }(o) }(), t }() }));

Archivo: onzauth/assets/screenshot-1.png
Tipo de archivo: image/png

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/assets/screenshot-2.png
Tipo de archivo: image/png

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/includes/

Archivo: onzauth/includes/class-configurations.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/includes/class-login.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/index.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/onzauth.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/readme.txt
Tipo de archivo: text/plain

Contenido:
=== OnzAuth ===
Tags: passwordless, magiclink, biometric, authentication, security, webauthn
Requires at least: 5.5.1
Tested up to: 6.1
Requires PHP: 7.3
License: GPL-3.0-only
License URI: https://opensource.org/licenses/GPL-3.0
Stable tag: 1.0.4
Contributors: zailky

OnzAuth plugin replaces the standard WordPress login form with one that enables passwordless email magic link and biometric login.

== Description ==
This plugin replaces the standard WordPress login form with one that enables passwordless email magic link and biometric login.

This plugin also supports the WooCommerce login.

Visit [https://tryonzauth.com](https://tryonzauth.com) to sign up for a free account and learn more.


== Installation ==
This plugin requires a [free or paid](https://tryonzauth.com/pricing) OnzAuth account.

1. [Sign up here](https://idp.onzauth.com/signin).
2. Follow the [installation instructions here](https://zailky.github.io/onz-auth-js/wordpress.html).

== Screenshots ==
1. Login form
2. Configuration page

== Changelog ==


Carpeta: onzauth/templates/

Archivo: onzauth/templates/form-login.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/

Archivo: onzauth/vendor/autoload.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/composer/

Archivo: onzauth/vendor/composer/autoload_classmap.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/autoload_files.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/autoload_namespaces.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/autoload_psr4.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/autoload_real.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/autoload_static.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/ClassLoader.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/installed.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/installed.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/InstalledVersions.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/composer/platform_check.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/firebase/

Carpeta: onzauth/vendor/firebase/php-jwt/

Archivo: onzauth/vendor/firebase/php-jwt/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/firebase/php-jwt/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/firebase/php-jwt/README.md
Tipo de archivo: text/markdown

Contenido:
![Build Status](https://github.com/firebase/php-jwt/actions/workflows/tests.yml/badge.svg)
[![Latest Stable Version](https://poser.pugx.org/firebase/php-jwt/v/stable)](https://packagist.org/packages/firebase/php-jwt)
[![Total Downloads](https://poser.pugx.org/firebase/php-jwt/downloads)](https://packagist.org/packages/firebase/php-jwt)
[![License](https://poser.pugx.org/firebase/php-jwt/license)](https://packagist.org/packages/firebase/php-jwt)

PHP-JWT
=======
A simple library to encode and decode JSON Web Tokens (JWT) in PHP, conforming to [RFC 7519](https://tools.ietf.org/html/rfc7519).

Installation
------------

Use composer to manage your dependencies and download PHP-JWT:

```bash
composer require firebase/php-jwt
```

Optionally, install the `paragonie/sodium_compat` package from composer if your
php is < 7.2 or does not have libsodium installed:

```bash
composer require paragonie/sodium_compat
```

Example
-------
```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

$key = 'example_key';
$payload = [
    'iss' => 'http://example.org',
    'aud' => 'http://example.com',
    'iat' => 1356999524,
    'nbf' => 1357000000
];

/**
 * IMPORTANT:
 * You must specify supported algorithms for your application. See
 * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40
 * for a list of spec-compliant algorithms.
 */
$jwt = JWT::encode($payload, $key, 'HS256');
$decoded = JWT::decode($jwt, new Key($key, 'HS256'));

print_r($decoded);

/*
 NOTE: This will now be an object instead of an associative array. To get
 an associative array, you will need to cast it as such:
*/

$decoded_array = (array) $decoded;

/**
 * You can add a leeway to account for when there is a clock skew times between
 * the signing and verifying servers. It is recommended that this leeway should
 * not be bigger than a few minutes.
 *
 * Source: http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#nbfDef
 */
JWT::$leeway = 60; // $leeway in seconds
$decoded = JWT::decode($jwt, new Key($key, 'HS256'));
```
Example with RS256 (openssl)
----------------------------
```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

$privateKey = <<<EOD
-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQC8kGa1pSjbSYZVebtTRBLxBz5H4i2p/llLCrEeQhta5kaQu/Rn
vuER4W8oDH3+3iuIYW4VQAzyqFpwuzjkDI+17t5t0tyazyZ8JXw+KgXTxldMPEL9
5+qVhgXvwtihXC1c5oGbRlEDvDF6Sa53rcFVsYJ4ehde/zUxo6UvS7UrBQIDAQAB
AoGAb/MXV46XxCFRxNuB8LyAtmLDgi/xRnTAlMHjSACddwkyKem8//8eZtw9fzxz
bWZ/1/doQOuHBGYZU8aDzzj59FZ78dyzNFoF91hbvZKkg+6wGyd/LrGVEB+Xre0J
Nil0GReM2AHDNZUYRv+HYJPIOrB0CRczLQsgFJ8K6aAD6F0CQQDzbpjYdx10qgK1
cP59UHiHjPZYC0loEsk7s+hUmT3QHerAQJMZWC11Qrn2N+ybwwNblDKv+s5qgMQ5
5tNoQ9IfAkEAxkyffU6ythpg/H0Ixe1I2rd0GbF05biIzO/i77Det3n4YsJVlDck
ZkcvY3SK2iRIL4c9yY6hlIhs+K9wXTtGWwJBAO9Dskl48mO7woPR9uD22jDpNSwe
k90OMepTjzSvlhjbfuPN1IdhqvSJTDychRwn1kIJ7LQZgQ8fVz9OCFZ/6qMCQGOb
qaGwHmUK6xzpUbbacnYrIM6nLSkXgOAwv7XXCojvY614ILTK3iXiLBOxPu5Eu13k
eUz9sHyD6vkgZzjtxXECQAkp4Xerf5TGfQXGXhxIX52yH+N2LtujCdkQZjXAsGdm
B2zNzvrlgRmgBrklMTrMYgm1NPcW+bRLGcwgW2PTvNM=
-----END RSA PRIVATE KEY-----
EOD;

$publicKey = <<<EOD
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC8kGa1pSjbSYZVebtTRBLxBz5H
4i2p/llLCrEeQhta5kaQu/RnvuER4W8oDH3+3iuIYW4VQAzyqFpwuzjkDI+17t5t
0tyazyZ8JXw+KgXTxldMPEL95+qVhgXvwtihXC1c5oGbRlEDvDF6Sa53rcFVsYJ4
ehde/zUxo6UvS7UrBQIDAQAB
-----END PUBLIC KEY-----
EOD;

$payload = [
    'iss' => 'example.org',
    'aud' => 'example.com',
    'iat' => 1356999524,
    'nbf' => 1357000000
];

$jwt = JWT::encode($payload, $privateKey, 'RS256');
echo "Encode:\n" . print_r($jwt, true) . "\n";

$decoded = JWT::decode($jwt, new Key($publicKey, 'RS256'));

/*
 NOTE: This will now be an object instead of an associative array. To get
 an associative array, you will need to cast it as such:
*/

$decoded_array = (array) $decoded;
echo "Decode:\n" . print_r($decoded_array, true) . "\n";
```

Example with a passphrase
-------------------------

```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

// Your passphrase
$passphrase = '[YOUR_PASSPHRASE]';

// Your private key file with passphrase
// Can be generated with "ssh-keygen -t rsa -m pem"
$privateKeyFile = '/path/to/key-with-passphrase.pem';

// Create a private key of type "resource"
$privateKey = openssl_pkey_get_private(
    file_get_contents($privateKeyFile),
    $passphrase
);

$payload = [
    'iss' => 'example.org',
    'aud' => 'example.com',
    'iat' => 1356999524,
    'nbf' => 1357000000
];

$jwt = JWT::encode($payload, $privateKey, 'RS256');
echo "Encode:\n" . print_r($jwt, true) . "\n";

// Get public key from the private key, or pull from from a file.
$publicKey = openssl_pkey_get_details($privateKey)['key'];

$decoded = JWT::decode($jwt, new Key($publicKey, 'RS256'));
echo "Decode:\n" . print_r((array) $decoded, true) . "\n";
```

Example with EdDSA (libsodium and Ed25519 signature)
----------------------------
```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

// Public and private keys are expected to be Base64 encoded. The last
// non-empty line is used so that keys can be generated with
// sodium_crypto_sign_keypair(). The secret keys generated by other tools may
// need to be adjusted to match the input expected by libsodium.

$keyPair = sodium_crypto_sign_keypair();

$privateKey = base64_encode(sodium_crypto_sign_secretkey($keyPair));

$publicKey = base64_encode(sodium_crypto_sign_publickey($keyPair));

$payload = [
    'iss' => 'example.org',
    'aud' => 'example.com',
    'iat' => 1356999524,
    'nbf' => 1357000000
];

$jwt = JWT::encode($payload, $privateKey, 'EdDSA');
echo "Encode:\n" . print_r($jwt, true) . "\n";

$decoded = JWT::decode($jwt, new Key($publicKey, 'EdDSA'));
echo "Decode:\n" . print_r((array) $decoded, true) . "\n";
````

Using JWKs
----------

```php
use Firebase\JWT\JWK;
use Firebase\JWT\JWT;

// Set of keys. The "keys" key is required. For example, the JSON response to
// this endpoint: https://www.gstatic.com/iap/verify/public_key-jwk
$jwks = ['keys' => []];

// JWK::parseKeySet($jwks) returns an associative array of **kid** to Firebase\JWT\Key
// objects. Pass this as the second parameter to JWT::decode.
JWT::decode($payload, JWK::parseKeySet($jwks));
```

Using Cached Key Sets
---------------------

The `CachedKeySet` class can be used to fetch and cache JWKS (JSON Web Key Sets) from a public URI.
This has the following advantages:

1. The results are cached for performance.
2. If an unrecognized key is requested, the cache is refreshed, to accomodate for key rotation.
3. If rate limiting is enabled, the JWKS URI will not make more than 10 requests a second.

```php
use Firebase\JWT\CachedKeySet;
use Firebase\JWT\JWT;

// The URI for the JWKS you wish to cache the results from
$jwksUri = 'https://www.gstatic.com/iap/verify/public_key-jwk';

// Create an HTTP client (can be any PSR-7 compatible HTTP client)
$httpClient = new GuzzleHttp\Client();

// Create an HTTP request factory (can be any PSR-17 compatible HTTP request factory)
$httpFactory = new GuzzleHttp\Psr\HttpFactory();

// Create a cache item pool (can be any PSR-6 compatible cache item pool)
$cacheItemPool = Phpfastcache\CacheManager::getInstance('files');

$keySet = new CachedKeySet(
    $jwksUri,
    $httpClient,
    $httpFactory,
    $cacheItemPool,
    null, // $expiresAfter int seconds to set the JWKS to expire
    true  // $rateLimit    true to enable rate limit of 10 RPS on lookup of invalid keys
);

$jwt = 'eyJhbGci...'; // Some JWT signed by a key from the $jwkUri above
$decoded = JWT::decode($jwt, $keySet);
```

Miscellaneous
-------------

#### Casting to array

The return value of `JWT::decode` is the generic PHP object `stdClass`. If you'd like to handle with arrays
instead, you can do the following:

```php
// return type is stdClass
$decoded = JWT::decode($payload, $keys);

// cast to array
$decoded = json_decode(json_encode($decoded), true);
```

Changelog
---------

#### 6.3.0 / 2022-07-15

 - Added ES256 support to JWK parsing ([#399](https://github.com/firebase/php-jwt/pull/399))
 - Fixed potential caching error in `CachedKeySet` by caching jwks as strings ([#435](https://github.com/firebase/php-jwt/pull/435))

#### 6.2.0 / 2022-05-14

 - Added `CachedKeySet` ([#397](https://github.com/firebase/php-jwt/pull/397))
 - Added `$defaultAlg` parameter to `JWT::parseKey` and `JWT::parseKeySet` ([#426](https://github.com/firebase/php-jwt/pull/426)). 

#### 6.1.0 / 2022-03-23

 - Drop support for PHP 5.3, 5.4, 5.5, 5.6, and 7.0
 - Add parameter typing and return types where possible

#### 6.0.0 / 2022-01-24

 - **Backwards-Compatibility Breaking Changes**: See the [Release Notes](https://github.com/firebase/php-jwt/releases/tag/v6.0.0) for more information.
 - New Key object to prevent key/algorithm type confusion (#365)
 - Add JWK support (#273)
 - Add ES256 support (#256)
 - Add ES384 support (#324)
 - Add Ed25519 support (#343)

#### 5.0.0 / 2017-06-26
- Support RS384 and RS512.
  See [#117](https://github.com/firebase/php-jwt/pull/117). Thanks [@joostfaassen](https://github.com/joostfaassen)!
- Add an example for RS256 openssl.
  See [#125](https://github.com/firebase/php-jwt/pull/125). Thanks [@akeeman](https://github.com/akeeman)!
- Detect invalid Base64 encoding in signature.
  See [#162](https://github.com/firebase/php-jwt/pull/162). Thanks [@psignoret](https://github.com/psignoret)!
- Update `JWT::verify` to handle OpenSSL errors.
  See [#159](https://github.com/firebase/php-jwt/pull/159). Thanks [@bshaffer](https://github.com/bshaffer)!
- Add `array` type hinting to `decode` method
  See [#101](https://github.com/firebase/php-jwt/pull/101). Thanks [@hywak](https://github.com/hywak)!
- Add all JSON error types.
  See [#110](https://github.com/firebase/php-jwt/pull/110). Thanks [@gbalduzzi](https://github.com/gbalduzzi)!
- Bugfix 'kid' not in given key list.
  See [#129](https://github.com/firebase/php-jwt/pull/129). Thanks [@stampycode](https://github.com/stampycode)!
- Miscellaneous cleanup, documentation and test fixes.
  See [#107](https://github.com/firebase/php-jwt/pull/107), [#115](https://github.com/firebase/php-jwt/pull/115),
  [#160](https://github.com/firebase/php-jwt/pull/160), [#161](https://github.com/firebase/php-jwt/pull/161), and
  [#165](https://github.com/firebase/php-jwt/pull/165). Thanks [@akeeman](https://github.com/akeeman),
  [@chinedufn](https://github.com/chinedufn), and [@bshaffer](https://github.com/bshaffer)!

#### 4.0.0 / 2016-07-17
- Add support for late static binding. See [#88](https://github.com/firebase/php-jwt/pull/88) for details. Thanks to [@chappy84](https://github.com/chappy84)!
- Use static `$timestamp` instead of `time()` to improve unit testing. See [#93](https://github.com/firebase/php-jwt/pull/93) for details. Thanks to [@josephmcdermott](https://github.com/josephmcdermott)!
- Fixes to exceptions classes. See [#81](https://github.com/firebase/php-jwt/pull/81) for details. Thanks to [@Maks3w](https://github.com/Maks3w)!
- Fixes to PHPDoc. See [#76](https://github.com/firebase/php-jwt/pull/76) for details. Thanks to [@akeeman](https://github.com/akeeman)!

#### 3.0.0 / 2015-07-22
- Minimum PHP version updated from `5.2.0` to `5.3.0`.
- Add `\Firebase\JWT` namespace. See
[#59](https://github.com/firebase/php-jwt/pull/59) for details. Thanks to
[@Dashron](https://github.com/Dashron)!
- Require a non-empty key to decode and verify a JWT. See
[#60](https://github.com/firebase/php-jwt/pull/60) for details. Thanks to
[@sjones608](https://github.com/sjones608)!
- Cleaner documentation blocks in the code. See
[#62](https://github.com/firebase/php-jwt/pull/62) for details. Thanks to
[@johanderuijter](https://github.com/johanderuijter)!

#### 2.2.0 / 2015-06-22
- Add support for adding custom, optional JWT headers to `JWT::encode()`. See
[#53](https://github.com/firebase/php-jwt/pull/53/files) for details. Thanks to
[@mcocaro](https://github.com/mcocaro)!

#### 2.1.0 / 2015-05-20
- Add support for adding a leeway to `JWT:decode()` that accounts for clock skew
between signing and verifying entities. Thanks to [@lcabral](https://github.com/lcabral)!
- Add support for passing an object implementing the `ArrayAccess` interface for
`$keys` argument in `JWT::decode()`. Thanks to [@aztech-dev](https://github.com/aztech-dev)!

#### 2.0.0 / 2015-04-01
- **Note**: It is strongly recommended that you update to > v2.0.0 to address
  known security vulnerabilities in prior versions when both symmetric and
  asymmetric keys are used together.
- Update signature for `JWT::decode(...)` to require an array of supported
  algorithms to use when verifying token signatures.


Tests
-----
Run the tests using phpunit:

```bash
$ pear install PHPUnit
$ phpunit --configuration phpunit.xml.dist
PHPUnit 3.7.10 by Sebastian Bergmann.
.....
Time: 0 seconds, Memory: 2.50Mb
OK (5 tests, 5 assertions)
```

New Lines in private keys
-----

If your private key contains `\n` characters, be sure to wrap it in double quotes `""`
and not single quotes `''` in order to properly interpret the escaped characters.

License
-------
[3-Clause BSD](http://opensource.org/licenses/BSD-3-Clause).


Carpeta: onzauth/vendor/firebase/php-jwt/src/

Archivo: onzauth/vendor/firebase/php-jwt/src/BeforeValidException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/firebase/php-jwt/src/CachedKeySet.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/firebase/php-jwt/src/ExpiredException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/firebase/php-jwt/src/JWK.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/firebase/php-jwt/src/JWT.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/firebase/php-jwt/src/Key.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/firebase/php-jwt/src/SignatureInvalidException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/guzzlehttp/

Carpeta: onzauth/vendor/guzzlehttp/guzzle/

Archivo: onzauth/vendor/guzzlehttp/guzzle/CHANGELOG.md
Tipo de archivo: text/markdown

Contenido:
# Change Log

Please refer to [UPGRADING](UPGRADING.md) guide for upgrading to a major version.

## 7.5.0 - 2022-08-28

### Added

- Support PHP 8.2
- Add request to delay closure params

## 7.4.5 - 2022-06-20

* Fix change in port should be considered a change in origin
* Fix `CURLOPT_HTTPAUTH` option not cleared on change of origin

## 7.4.4 - 2022-06-09

* Fix failure to strip Authorization header on HTTP downgrade
* Fix failure to strip the Cookie header on change in host or HTTP downgrade

## 7.4.3 - 2022-05-25

* Fix cross-domain cookie leakage

## 7.4.2 - 2022-03-20

### Fixed

- Remove curl auth on cross-domain redirects to align with the Authorization HTTP header
- Reject non-HTTP schemes in StreamHandler
- Set a default ssl.peer_name context in StreamHandler to allow `force_ip_resolve`

## 7.4.1 - 2021-12-06

### Changed

- Replaced implicit URI to string coercion [#2946](https://github.com/guzzle/guzzle/pull/2946)
- Allow `symfony/deprecation-contracts` version 3 [#2961](https://github.com/guzzle/guzzle/pull/2961)

### Fixed

- Only close curl handle if it's done [#2950](https://github.com/guzzle/guzzle/pull/2950)

## 7.4.0 - 2021-10-18

### Added

- Support PHP 8.1 [#2929](https://github.com/guzzle/guzzle/pull/2929), [#2939](https://github.com/guzzle/guzzle/pull/2939)
- Support `psr/log` version 2 and 3 [#2943](https://github.com/guzzle/guzzle/pull/2943)

### Fixed

- Make sure we always call `restore_error_handler()` [#2915](https://github.com/guzzle/guzzle/pull/2915)
- Fix progress parameter type compatibility between the cURL and stream handlers [#2936](https://github.com/guzzle/guzzle/pull/2936)
- Throw `InvalidArgumentException` when an incorrect `headers` array is provided [#2916](https://github.com/guzzle/guzzle/pull/2916), [#2942](https://github.com/guzzle/guzzle/pull/2942)

### Changed

- Be more strict with types [#2914](https://github.com/guzzle/guzzle/pull/2914), [#2917](https://github.com/guzzle/guzzle/pull/2917), [#2919](https://github.com/guzzle/guzzle/pull/2919), [#2945](https://github.com/guzzle/guzzle/pull/2945)

## 7.3.0 - 2021-03-23

### Added

- Support for DER and P12 certificates [#2413](https://github.com/guzzle/guzzle/pull/2413)
- Support the cURL (http://) scheme for StreamHandler proxies [#2850](https://github.com/guzzle/guzzle/pull/2850)
- Support for `guzzlehttp/psr7:^2.0` [#2878](https://github.com/guzzle/guzzle/pull/2878)

### Fixed

- Handle exceptions on invalid header consistently between PHP versions and handlers [#2872](https://github.com/guzzle/guzzle/pull/2872)

## 7.2.0 - 2020-10-10

### Added

- Support for PHP 8 [#2712](https://github.com/guzzle/guzzle/pull/2712), [#2715](https://github.com/guzzle/guzzle/pull/2715), [#2789](https://github.com/guzzle/guzzle/pull/2789)
- Support passing a body summarizer to the http errors middleware [#2795](https://github.com/guzzle/guzzle/pull/2795)

### Fixed

- Handle exceptions during response creation [#2591](https://github.com/guzzle/guzzle/pull/2591)
- Fix CURLOPT_ENCODING not to be overwritten [#2595](https://github.com/guzzle/guzzle/pull/2595)
- Make sure the Request always has a body object [#2804](https://github.com/guzzle/guzzle/pull/2804)

### Changed

- The `TooManyRedirectsException` has a response [#2660](https://github.com/guzzle/guzzle/pull/2660)
- Avoid "functions" from dependencies [#2712](https://github.com/guzzle/guzzle/pull/2712)

### Deprecated

- Using environment variable GUZZLE_CURL_SELECT_TIMEOUT [#2786](https://github.com/guzzle/guzzle/pull/2786)

## 7.1.1 - 2020-09-30

### Fixed

- Incorrect EOF detection for response body streams on Windows.

### Changed

- We dont connect curl `sink` on HEAD requests.
- Removed some PHP 5 workarounds

## 7.1.0 - 2020-09-22

### Added

- `GuzzleHttp\MessageFormatterInterface`

### Fixed

- Fixed issue that caused cookies with no value not to be stored.
- On redirects, we allow all safe methods like GET, HEAD and OPTIONS.
- Fixed logging on empty responses.
- Make sure MessageFormatter::format returns string

### Deprecated

- All functions in `GuzzleHttp` has been deprecated. Use static methods on `Utils` instead.
- `ClientInterface::getConfig()`
- `Client::getConfig()`
- `Client::__call()`
- `Utils::defaultCaBundle()`
- `CurlFactory::LOW_CURL_VERSION_NUMBER`

## 7.0.1 - 2020-06-27

* Fix multiply defined functions fatal error [#2699](https://github.com/guzzle/guzzle/pull/2699)

## 7.0.0 - 2020-06-27

No changes since 7.0.0-rc1.

## 7.0.0-rc1 - 2020-06-15

### Changed

* Use error level for logging errors in Middleware [#2629](https://github.com/guzzle/guzzle/pull/2629)
* Disabled IDN support by default and require ext-intl to use it [#2675](https://github.com/guzzle/guzzle/pull/2675)

## 7.0.0-beta2 - 2020-05-25

### Added

* Using `Utils` class instead of functions in the `GuzzleHttp` namespace. [#2546](https://github.com/guzzle/guzzle/pull/2546)
* `ClientInterface::MAJOR_VERSION` [#2583](https://github.com/guzzle/guzzle/pull/2583)

### Changed

* Avoid the `getenv` function when unsafe [#2531](https://github.com/guzzle/guzzle/pull/2531)
* Added real client methods [#2529](https://github.com/guzzle/guzzle/pull/2529)
* Avoid functions due to global install conflicts [#2546](https://github.com/guzzle/guzzle/pull/2546)
* Use Symfony intl-idn polyfill [#2550](https://github.com/guzzle/guzzle/pull/2550)
* Adding methods for HTTP verbs like `Client::get()`, `Client::head()`, `Client::patch()` etc [#2529](https://github.com/guzzle/guzzle/pull/2529)
* `ConnectException` extends `TransferException` [#2541](https://github.com/guzzle/guzzle/pull/2541)
* Updated the default User Agent to "GuzzleHttp/7" [#2654](https://github.com/guzzle/guzzle/pull/2654)

### Fixed

* Various intl icu issues [#2626](https://github.com/guzzle/guzzle/pull/2626)

### Removed

* Pool option `pool_size` [#2528](https://github.com/guzzle/guzzle/pull/2528)

## 7.0.0-beta1 - 2019-12-30

The diff might look very big but 95% of Guzzle users will be able to upgrade without modification.
Please see [the upgrade document](UPGRADING.md) that describes all BC breaking changes.

### Added

* Implement PSR-18 and dropped PHP 5 support [#2421](https://github.com/guzzle/guzzle/pull/2421) [#2474](https://github.com/guzzle/guzzle/pull/2474)
* PHP 7 types [#2442](https://github.com/guzzle/guzzle/pull/2442) [#2449](https://github.com/guzzle/guzzle/pull/2449) [#2466](https://github.com/guzzle/guzzle/pull/2466) [#2497](https://github.com/guzzle/guzzle/pull/2497) [#2499](https://github.com/guzzle/guzzle/pull/2499)
* IDN support for redirects [2424](https://github.com/guzzle/guzzle/pull/2424)

### Changed

* Dont allow passing null as third argument to `BadResponseException::__construct()` [#2427](https://github.com/guzzle/guzzle/pull/2427)
* Use SAPI constant instead of method call [#2450](https://github.com/guzzle/guzzle/pull/2450)
* Use native function invocation [#2444](https://github.com/guzzle/guzzle/pull/2444)
* Better defaults for PHP installations with old ICU lib [2454](https://github.com/guzzle/guzzle/pull/2454)
* Added visibility to all constants [#2462](https://github.com/guzzle/guzzle/pull/2462)
* Dont allow passing `null` as URI to `Client::request()` and `Client::requestAsync()` [#2461](https://github.com/guzzle/guzzle/pull/2461)
* Widen the exception argument to throwable [#2495](https://github.com/guzzle/guzzle/pull/2495)

### Fixed

* Logging when Promise rejected with a string [#2311](https://github.com/guzzle/guzzle/pull/2311)

### Removed

* Class `SeekException` [#2162](https://github.com/guzzle/guzzle/pull/2162)
* `RequestException::getResponseBodySummary()` [#2425](https://github.com/guzzle/guzzle/pull/2425)
* `CookieJar::getCookieValue()` [#2433](https://github.com/guzzle/guzzle/pull/2433)
* `uri_template()` and `UriTemplate` [#2440](https://github.com/guzzle/guzzle/pull/2440)
* Request options `save_to` and `exceptions` [#2464](https://github.com/guzzle/guzzle/pull/2464)

## 6.5.2 - 2019-12-23

* idn_to_ascii() fix for old PHP versions [#2489](https://github.com/guzzle/guzzle/pull/2489)

## 6.5.1 - 2019-12-21

* Better defaults for PHP installations with old ICU lib [#2454](https://github.com/guzzle/guzzle/pull/2454)
* IDN support for redirects [#2424](https://github.com/guzzle/guzzle/pull/2424)

## 6.5.0 - 2019-12-07

* Improvement: Added support for reset internal queue in MockHandler. [#2143](https://github.com/guzzle/guzzle/pull/2143)
* Improvement: Added support to pass arbitrary options to `curl_multi_init`. [#2287](https://github.com/guzzle/guzzle/pull/2287)
* Fix: Gracefully handle passing `null` to the `header` option. [#2132](https://github.com/guzzle/guzzle/pull/2132)
* Fix: `RetryMiddleware` did not do exponential delay between retires due unit mismatch. [#2132](https://github.com/guzzle/guzzle/pull/2132)
* Fix: Prevent undefined offset when using array for ssl_key options. [#2348](https://github.com/guzzle/guzzle/pull/2348)
* Deprecated `ClientInterface::VERSION`

## 6.4.1 - 2019-10-23

* No `guzzle.phar` was created in 6.4.0 due expired API token. This release will fix that
* Added `parent::__construct()` to `FileCookieJar` and `SessionCookieJar`

## 6.4.0 - 2019-10-23

* Improvement: Improved error messages when using curl < 7.21.2 [#2108](https://github.com/guzzle/guzzle/pull/2108)
* Fix: Test if response is readable before returning a summary in `RequestException::getResponseBodySummary()` [#2081](https://github.com/guzzle/guzzle/pull/2081)
* Fix: Add support for GUZZLE_CURL_SELECT_TIMEOUT environment variable [#2161](https://github.com/guzzle/guzzle/pull/2161)
* Improvement: Added `GuzzleHttp\Exception\InvalidArgumentException` [#2163](https://github.com/guzzle/guzzle/pull/2163)
* Improvement: Added `GuzzleHttp\_current_time()` to use `hrtime()` if that function exists. [#2242](https://github.com/guzzle/guzzle/pull/2242)
* Improvement: Added curl's `appconnect_time` in `TransferStats` [#2284](https://github.com/guzzle/guzzle/pull/2284)
* Improvement: Make GuzzleException extend Throwable wherever it's available [#2273](https://github.com/guzzle/guzzle/pull/2273)
* Fix: Prevent concurrent writes to file when saving `CookieJar` [#2335](https://github.com/guzzle/guzzle/pull/2335)
* Improvement: Update `MockHandler` so we can test transfer time [#2362](https://github.com/guzzle/guzzle/pull/2362)

## 6.3.3 - 2018-04-22

* Fix: Default headers when decode_content is specified


## 6.3.2 - 2018-03-26

* Fix: Release process


## 6.3.1 - 2018-03-26

* Bug fix: Parsing 0 epoch expiry times in cookies [#2014](https://github.com/guzzle/guzzle/pull/2014)
* Improvement: Better ConnectException detection [#2012](https://github.com/guzzle/guzzle/pull/2012)
* Bug fix: Malformed domain that contains a "/" [#1999](https://github.com/guzzle/guzzle/pull/1999)
* Bug fix: Undefined offset when a cookie has no first key-value pair [#1998](https://github.com/guzzle/guzzle/pull/1998)
* Improvement: Support PHPUnit 6 [#1953](https://github.com/guzzle/guzzle/pull/1953)
* Bug fix: Support empty headers [#1915](https://github.com/guzzle/guzzle/pull/1915)
* Bug fix: Ignore case during header modifications [#1916](https://github.com/guzzle/guzzle/pull/1916)

+ Minor code cleanups, documentation fixes and clarifications.


## 6.3.0 - 2017-06-22

* Feature: force IP resolution (ipv4 or ipv6) [#1608](https://github.com/guzzle/guzzle/pull/1608), [#1659](https://github.com/guzzle/guzzle/pull/1659)
* Improvement: Don't include summary in exception message when body is empty [#1621](https://github.com/guzzle/guzzle/pull/1621)
* Improvement: Handle `on_headers` option in MockHandler [#1580](https://github.com/guzzle/guzzle/pull/1580)
* Improvement: Added SUSE Linux CA path [#1609](https://github.com/guzzle/guzzle/issues/1609)
* Improvement: Use class reference for getting the name of the class instead of using hardcoded strings [#1641](https://github.com/guzzle/guzzle/pull/1641)
* Feature: Added `read_timeout` option [#1611](https://github.com/guzzle/guzzle/pull/1611)
* Bug fix: PHP 7.x fixes [#1685](https://github.com/guzzle/guzzle/pull/1685), [#1686](https://github.com/guzzle/guzzle/pull/1686), [#1811](https://github.com/guzzle/guzzle/pull/1811)
* Deprecation: BadResponseException instantiation without a response [#1642](https://github.com/guzzle/guzzle/pull/1642)
* Feature: Added NTLM auth [#1569](https://github.com/guzzle/guzzle/pull/1569)
* Feature: Track redirect HTTP status codes [#1711](https://github.com/guzzle/guzzle/pull/1711)
* Improvement: Check handler type during construction [#1745](https://github.com/guzzle/guzzle/pull/1745)
* Improvement: Always include the Content-Length if there's a body [#1721](https://github.com/guzzle/guzzle/pull/1721)
* Feature: Added convenience method to access a cookie by name [#1318](https://github.com/guzzle/guzzle/pull/1318)
* Bug fix: Fill `CURLOPT_CAPATH` and `CURLOPT_CAINFO` properly [#1684](https://github.com/guzzle/guzzle/pull/1684)
* Improvement:  	Use `\GuzzleHttp\Promise\rejection_for` function instead of object init [#1827](https://github.com/guzzle/guzzle/pull/1827)


+ Minor code cleanups, documentation fixes and clarifications.

## 6.2.3 - 2017-02-28

* Fix deprecations with guzzle/psr7 version 1.4

## 6.2.2 - 2016-10-08

* Allow to pass nullable Response to delay callable
* Only add scheme when host is present
* Fix drain case where content-length is the literal string zero
* Obfuscate in-URL credentials in exceptions

## 6.2.1 - 2016-07-18

* Address HTTP_PROXY security vulnerability, CVE-2016-5385:
  https://httpoxy.org/
* Fixing timeout bug with StreamHandler:
  https://github.com/guzzle/guzzle/pull/1488
* Only read up to `Content-Length` in PHP StreamHandler to avoid timeouts when
  a server does not honor `Connection: close`.
* Ignore URI fragment when sending requests.

## 6.2.0 - 2016-03-21

* Feature: added `GuzzleHttp\json_encode` and `GuzzleHttp\json_decode`.
  https://github.com/guzzle/guzzle/pull/1389
* Bug fix: Fix sleep calculation when waiting for delayed requests.
  https://github.com/guzzle/guzzle/pull/1324
* Feature: More flexible history containers.
  https://github.com/guzzle/guzzle/pull/1373
* Bug fix: defer sink stream opening in StreamHandler.
  https://github.com/guzzle/guzzle/pull/1377
* Bug fix: do not attempt to escape cookie values.
  https://github.com/guzzle/guzzle/pull/1406
* Feature: report original content encoding and length on decoded responses.
  https://github.com/guzzle/guzzle/pull/1409
* Bug fix: rewind seekable request bodies before dispatching to cURL.
  https://github.com/guzzle/guzzle/pull/1422
* Bug fix: provide an empty string to `http_build_query` for HHVM workaround.
  https://github.com/guzzle/guzzle/pull/1367

## 6.1.1 - 2015-11-22

* Bug fix: Proxy::wrapSync() now correctly proxies to the appropriate handler
  https://github.com/guzzle/guzzle/commit/911bcbc8b434adce64e223a6d1d14e9a8f63e4e4
* Feature: HandlerStack is now more generic.
  https://github.com/guzzle/guzzle/commit/f2102941331cda544745eedd97fc8fd46e1ee33e
* Bug fix: setting verify to false in the StreamHandler now disables peer
  verification. https://github.com/guzzle/guzzle/issues/1256
* Feature: Middleware now uses an exception factory, including more error
  context. https://github.com/guzzle/guzzle/pull/1282
* Feature: better support for disabled functions.
  https://github.com/guzzle/guzzle/pull/1287
* Bug fix: fixed regression where MockHandler was not using `sink`.
  https://github.com/guzzle/guzzle/pull/1292

## 6.1.0 - 2015-09-08

* Feature: Added the `on_stats` request option to provide access to transfer
  statistics for requests. https://github.com/guzzle/guzzle/pull/1202
* Feature: Added the ability to persist session cookies in CookieJars.
  https://github.com/guzzle/guzzle/pull/1195
* Feature: Some compatibility updates for Google APP Engine
  https://github.com/guzzle/guzzle/pull/1216
* Feature: Added support for NO_PROXY to prevent the use of a proxy based on
  a simple set of rules. https://github.com/guzzle/guzzle/pull/1197
* Feature: Cookies can now contain square brackets.
  https://github.com/guzzle/guzzle/pull/1237
* Bug fix: Now correctly parsing `=` inside of quotes in Cookies.
  https://github.com/guzzle/guzzle/pull/1232
* Bug fix: Cusotm cURL options now correctly override curl options of the
  same name. https://github.com/guzzle/guzzle/pull/1221
* Bug fix: Content-Type header is now added when using an explicitly provided
  multipart body. https://github.com/guzzle/guzzle/pull/1218
* Bug fix: Now ignoring Set-Cookie headers that have no name.
* Bug fix: Reason phrase is no longer cast to an int in some cases in the
  cURL handler. https://github.com/guzzle/guzzle/pull/1187
* Bug fix: Remove the Authorization header when redirecting if the Host
  header changes. https://github.com/guzzle/guzzle/pull/1207
* Bug fix: Cookie path matching fixes
  https://github.com/guzzle/guzzle/issues/1129
* Bug fix: Fixing the cURL `body_as_string` setting
  https://github.com/guzzle/guzzle/pull/1201
* Bug fix: quotes are no longer stripped when parsing cookies.
  https://github.com/guzzle/guzzle/issues/1172
* Bug fix: `form_params` and `query` now always uses the `&` separator.
  https://github.com/guzzle/guzzle/pull/1163
* Bug fix: Adding a Content-Length to PHP stream wrapper requests if not set.
  https://github.com/guzzle/guzzle/pull/1189

## 6.0.2 - 2015-07-04

* Fixed a memory leak in the curl handlers in which references to callbacks
  were not being removed by `curl_reset`.
* Cookies are now extracted properly before redirects.
* Cookies now allow more character ranges.
* Decoded Content-Encoding responses are now modified to correctly reflect
  their state if the encoding was automatically removed by a handler. This
  means that the `Content-Encoding` header may be removed an the
  `Content-Length` modified to reflect the message size after removing the
  encoding.
* Added a more explicit error message when trying to use `form_params` and
  `multipart` in the same request.
* Several fixes for HHVM support.
* Functions are now conditionally required using an additional level of
  indirection to help with global Composer installations.

## 6.0.1 - 2015-05-27

* Fixed a bug with serializing the `query` request option where the `&`
  separator was missing.
* Added a better error message for when `body` is provided as an array. Please
  use `form_params` or `multipart` instead.
* Various doc fixes.

## 6.0.0 - 2015-05-26

* See the UPGRADING.md document for more information.
* Added `multipart` and `form_params` request options.
* Added `synchronous` request option.
* Added the `on_headers` request option.
* Fixed `expect` handling.
* No longer adding default middlewares in the client ctor. These need to be
  present on the provided handler in order to work.
* Requests are no longer initiated when sending async requests with the
  CurlMultiHandler. This prevents unexpected recursion from requests completing
  while ticking the cURL loop.
* Removed the semantics of setting `default` to `true`. This is no longer
  required now that the cURL loop is not ticked for async requests.
* Added request and response logging middleware.
* No longer allowing self signed certificates when using the StreamHandler.
* Ensuring that `sink` is valid if saving to a file.
* Request exceptions now include a "handler context" which provides handler
  specific contextual information.
* Added `GuzzleHttp\RequestOptions` to allow request options to be applied
  using constants.
* `$maxHandles` has been removed from CurlMultiHandler.
* `MultipartPostBody` is now part of the `guzzlehttp/psr7` package.

## 5.3.0 - 2015-05-19

* Mock now supports `save_to`
* Marked `AbstractRequestEvent::getTransaction()` as public.
* Fixed a bug in which multiple headers using different casing would overwrite
  previous headers in the associative array.
* Added `Utils::getDefaultHandler()`
* Marked `GuzzleHttp\Client::getDefaultUserAgent` as deprecated.
* URL scheme is now always lowercased.

## 6.0.0-beta.1

* Requires PHP >= 5.5
* Updated to use PSR-7
  * Requires immutable messages, which basically means an event based system
    owned by a request instance is no longer possible.
  * Utilizing the [Guzzle PSR-7 package](https://github.com/guzzle/psr7).
  * Removed the dependency on `guzzlehttp/streams`. These stream abstractions
    are available in the `guzzlehttp/psr7` package under the `GuzzleHttp\Psr7`
    namespace.
* Added middleware and handler system
  * Replaced the Guzzle event and subscriber system with a middleware system.
  * No longer depends on RingPHP, but rather places the HTTP handlers directly
    in Guzzle, operating on PSR-7 messages.
  * Retry logic is now encapsulated in `GuzzleHttp\Middleware::retry`, which
    means the `guzzlehttp/retry-subscriber` is now obsolete.
  * Mocking responses is now handled using `GuzzleHttp\Handler\MockHandler`.
* Asynchronous responses
  * No longer supports the `future` request option to send an async request.
    Instead, use one of the `*Async` methods of a client (e.g., `requestAsync`,
    `getAsync`, etc.).
  * Utilizing `GuzzleHttp\Promise` instead of React's promise library to avoid
    recursion required by chaining and forwarding react promises. See
    https://github.com/guzzle/promises
  * Added `requestAsync` and `sendAsync` to send request asynchronously.
  * Added magic methods for `getAsync()`, `postAsync()`, etc. to send requests
    asynchronously.
* Request options
  * POST and form updates
    * Added the `form_fields` and `form_files` request options.
    * Removed the `GuzzleHttp\Post` namespace.
    * The `body` request option no longer accepts an array for POST requests.
  * The `exceptions` request option has been deprecated in favor of the
    `http_errors` request options.
  * The `save_to` request option has been deprecated in favor of `sink` request
    option.
* Clients no longer accept an array of URI template string and variables for
  URI variables. You will need to expand URI templates before passing them
  into a client constructor or request method.
* Client methods `get()`, `post()`, `put()`, `patch()`, `options()`, etc. are
  now magic methods that will send synchronous requests.
* Replaced `Utils.php` with plain functions in `functions.php`.
* Removed `GuzzleHttp\Collection`.
* Removed `GuzzleHttp\BatchResults`. Batched pool results are now returned as
  an array.
* Removed `GuzzleHttp\Query`. Query string handling is now handled using an
  associative array passed into the `query` request option. The query string
  is serialized using PHP's `http_build_query`. If you need more control, you
  can pass the query string in as a string.
* `GuzzleHttp\QueryParser` has been replaced with the
  `GuzzleHttp\Psr7\parse_query`.

## 5.2.0 - 2015-01-27

* Added `AppliesHeadersInterface` to make applying headers to a request based
  on the body more generic and not specific to `PostBodyInterface`.
* Reduced the number of stack frames needed to send requests.
* Nested futures are now resolved in the client rather than the RequestFsm
* Finishing state transitions is now handled in the RequestFsm rather than the
  RingBridge.
* Added a guard in the Pool class to not use recursion for request retries.

## 5.1.0 - 2014-12-19

* Pool class no longer uses recursion when a request is intercepted.
* The size of a Pool can now be dynamically adjusted using a callback.
  See https://github.com/guzzle/guzzle/pull/943.
* Setting a request option to `null` when creating a request with a client will
  ensure that the option is not set. This allows you to overwrite default
  request options on a per-request basis.
  See https://github.com/guzzle/guzzle/pull/937.
* Added the ability to limit which protocols are allowed for redirects by
  specifying a `protocols` array in the `allow_redirects` request option.
* Nested futures due to retries are now resolved when waiting for synchronous
  responses. See https://github.com/guzzle/guzzle/pull/947.
* `"0"` is now an allowed URI path. See
  https://github.com/guzzle/guzzle/pull/935.
* `Query` no longer typehints on the `$query` argument in the constructor,
  allowing for strings and arrays.
* Exceptions thrown in the `end` event are now correctly wrapped with Guzzle
  specific exceptions if necessary.

## 5.0.3 - 2014-11-03

This change updates query strings so that they are treated as un-encoded values
by default where the value represents an un-encoded value to send over the
wire. A Query object then encodes the value before sending over the wire. This
means that even value query string values (e.g., ":") are url encoded. This
makes the Query class match PHP's http_build_query function. However, if you
want to send requests over the wire using valid query string characters that do
not need to be encoded, then you can provide a string to Url::setQuery() and
pass true as the second argument to specify that the query string is a raw
string that should not be parsed or encoded (unless a call to getQuery() is
subsequently made, forcing the query-string to be converted into a Query
object).

## 5.0.2 - 2014-10-30

* Added a trailing `\r\n` to multipart/form-data payloads. See
  https://github.com/guzzle/guzzle/pull/871
* Added a `GuzzleHttp\Pool::send()` convenience method to match the docs.
* Status codes are now returned as integers. See
  https://github.com/guzzle/guzzle/issues/881
* No longer overwriting an existing `application/x-www-form-urlencoded` header
  when sending POST requests, allowing for customized headers. See
  https://github.com/guzzle/guzzle/issues/877
* Improved path URL serialization.

  * No longer double percent-encoding characters in the path or query string if
    they are already encoded.
  * Now properly encoding the supplied path to a URL object, instead of only
    encoding ' ' and '?'.
  * Note: This has been changed in 5.0.3 to now encode query string values by
    default unless the `rawString` argument is provided when setting the query
    string on a URL: Now allowing many more characters to be present in the
    query string without being percent encoded. See https://tools.ietf.org/html/rfc3986#appendix-A

## 5.0.1 - 2014-10-16

Bugfix release.

* Fixed an issue where connection errors still returned response object in
  error and end events event though the response is unusable. This has been
  corrected so that a response is not returned in the `getResponse` method of
  these events if the response did not complete. https://github.com/guzzle/guzzle/issues/867
* Fixed an issue where transfer statistics were not being populated in the
  RingBridge. https://github.com/guzzle/guzzle/issues/866

## 5.0.0 - 2014-10-12

Adding support for non-blocking responses and some minor API cleanup.

### New Features

* Added support for non-blocking responses based on `guzzlehttp/guzzle-ring`.
* Added a public API for creating a default HTTP adapter.
* Updated the redirect plugin to be non-blocking so that redirects are sent
  concurrently. Other plugins like this can now be updated to be non-blocking.
* Added a "progress" event so that you can get upload and download progress
  events.
* Added `GuzzleHttp\Pool` which implements FutureInterface and transfers
  requests concurrently using a capped pool size as efficiently as possible.
* Added `hasListeners()` to EmitterInterface.
* Removed `GuzzleHttp\ClientInterface::sendAll` and marked
  `GuzzleHttp\Client::sendAll` as deprecated (it's still there, just not the
  recommended way).

### Breaking changes

The breaking changes in this release are relatively minor. The biggest thing to
look out for is that request and response objects no longer implement fluent
interfaces.

* Removed the fluent interfaces (i.e., `return $this`) from requests,
  responses, `GuzzleHttp\Collection`, `GuzzleHttp\Url`,
  `GuzzleHttp\Query`, `GuzzleHttp\Post\PostBody`, and
  `GuzzleHttp\Cookie\SetCookie`. This blog post provides a good outline of
  why I did this: https://ocramius.github.io/blog/fluent-interfaces-are-evil/.
  This also makes the Guzzle message interfaces compatible with the current
  PSR-7 message proposal.
* Removed "functions.php", so that Guzzle is truly PSR-4 compliant. Except
  for the HTTP request functions from function.php, these functions are now
  implemented in `GuzzleHttp\Utils` using camelCase. `GuzzleHttp\json_decode`
  moved to `GuzzleHttp\Utils::jsonDecode`. `GuzzleHttp\get_path` moved to
  `GuzzleHttp\Utils::getPath`. `GuzzleHttp\set_path` moved to
  `GuzzleHttp\Utils::setPath`. `GuzzleHttp\batch` should now be
  `GuzzleHttp\Pool::batch`, which returns an `objectStorage`. Using functions.php
  caused problems for many users: they aren't PSR-4 compliant, require an
  explicit include, and needed an if-guard to ensure that the functions are not
  declared multiple times.
* Rewrote adapter layer.
    * Removing all classes from `GuzzleHttp\Adapter`, these are now
      implemented as callables that are stored in `GuzzleHttp\Ring\Client`.
    * Removed the concept of "parallel adapters". Sending requests serially or
      concurrently is now handled using a single adapter.
    * Moved `GuzzleHttp\Adapter\Transaction` to `GuzzleHttp\Transaction`. The
      Transaction object now exposes the request, response, and client as public
      properties. The getters and setters have been removed.
* Removed the "headers" event. This event was only useful for changing the
  body a response once the headers of the response were known. You can implement
  a similar behavior in a number of ways. One example might be to use a
  FnStream that has access to the transaction being sent. For example, when the
  first byte is written, you could check if the response headers match your
  expectations, and if so, change the actual stream body that is being
  written to.
* Removed the `asArray` parameter from
  `GuzzleHttp\Message\MessageInterface::getHeader`. If you want to get a header
  value as an array, then use the newly added `getHeaderAsArray()` method of
  `MessageInterface`. This change makes the Guzzle interfaces compatible with
  the PSR-7 interfaces.
* `GuzzleHttp\Message\MessageFactory` no longer allows subclasses to add
  custom request options using double-dispatch (this was an implementation
  detail). Instead, you should now provide an associative array to the
  constructor which is a mapping of the request option name mapping to a
  function that applies the option value to a request.
* Removed the concept of "throwImmediately" from exceptions and error events.
  This control mechanism was used to stop a transfer of concurrent requests
  from completing. This can now be handled by throwing the exception or by
  cancelling a pool of requests or each outstanding future request individually.
* Updated to "GuzzleHttp\Streams" 3.0.
    * `GuzzleHttp\Stream\StreamInterface::getContents()` no longer accepts a
      `maxLen` parameter. This update makes the Guzzle streams project
      compatible with the current PSR-7 proposal.
    * `GuzzleHttp\Stream\Stream::__construct`,
      `GuzzleHttp\Stream\Stream::factory`, and
      `GuzzleHttp\Stream\Utils::create` no longer accept a size in the second
      argument. They now accept an associative array of options, including the
      "size" key and "metadata" key which can be used to provide custom metadata.

## 4.2.2 - 2014-09-08

* Fixed a memory leak in the CurlAdapter when reusing cURL handles.
* No longer using `request_fulluri` in stream adapter proxies.
* Relative redirects are now based on the last response, not the first response.

## 4.2.1 - 2014-08-19

* Ensuring that the StreamAdapter does not always add a Content-Type header
* Adding automated github releases with a phar and zip

## 4.2.0 - 2014-08-17

* Now merging in default options using a case-insensitive comparison.
  Closes https://github.com/guzzle/guzzle/issues/767
* Added the ability to automatically decode `Content-Encoding` response bodies
  using the `decode_content` request option. This is set to `true` by default
  to decode the response body if it comes over the wire with a
  `Content-Encoding`. Set this value to `false` to disable decoding the
  response content, and pass a string to provide a request `Accept-Encoding`
  header and turn on automatic response decoding. This feature now allows you
  to pass an `Accept-Encoding` header in the headers of a request but still
  disable automatic response decoding.
  Closes https://github.com/guzzle/guzzle/issues/764
* Added the ability to throw an exception immediately when transferring
  requests in parallel. Closes https://github.com/guzzle/guzzle/issues/760
* Updating guzzlehttp/streams dependency to ~2.1
* No longer utilizing the now deprecated namespaced methods from the stream
  package.

## 4.1.8 - 2014-08-14

* Fixed an issue in the CurlFactory that caused setting the `stream=false`
  request option to throw an exception.
  See: https://github.com/guzzle/guzzle/issues/769
* TransactionIterator now calls rewind on the inner iterator.
  See: https://github.com/guzzle/guzzle/pull/765
* You can now set the `Content-Type` header to `multipart/form-data`
  when creating POST requests to force multipart bodies.
  See https://github.com/guzzle/guzzle/issues/768

## 4.1.7 - 2014-08-07

* Fixed an error in the HistoryPlugin that caused the same request and response
  to be logged multiple times when an HTTP protocol error occurs.
* Ensuring that cURL does not add a default Content-Type when no Content-Type
  has been supplied by the user. This prevents the adapter layer from modifying
  the request that is sent over the wire after any listeners may have already
  put the request in a desired state (e.g., signed the request).
* Throwing an exception when you attempt to send requests that have the
  "stream" set to true in parallel using the MultiAdapter.
* Only calling curl_multi_select when there are active cURL handles. This was
  previously changed and caused performance problems on some systems due to PHP
  always selecting until the maximum select timeout.
* Fixed a bug where multipart/form-data POST fields were not correctly
  aggregated (e.g., values with "&").

## 4.1.6 - 2014-08-03

* Added helper methods to make it easier to represent messages as strings,
  including getting the start line and getting headers as a string.

## 4.1.5 - 2014-08-02

* Automatically retrying cURL "Connection died, retrying a fresh connect"
  errors when possible.
* cURL implementation cleanup
* Allowing multiple event subscriber listeners to be registered per event by
  passing an array of arrays of listener configuration.

## 4.1.4 - 2014-07-22

* Fixed a bug that caused multi-part POST requests with more than one field to
  serialize incorrectly.
* Paths can now be set to "0"
* `ResponseInterface::xml` now accepts a `libxml_options` option and added a
  missing default argument that was required when parsing XML response bodies.
* A `save_to` stream is now created lazily, which means that files are not
  created on disk unless a request succeeds.

## 4.1.3 - 2014-07-15

* Various fixes to multipart/form-data POST uploads
* Wrapping function.php in an if-statement to ensure Guzzle can be used
  globally and in a Composer install
* Fixed an issue with generating and merging in events to an event array
* POST headers are only applied before sending a request to allow you to change
  the query aggregator used before uploading
* Added much more robust query string parsing
* Fixed various parsing and normalization issues with URLs
* Fixing an issue where multi-valued headers were not being utilized correctly
  in the StreamAdapter

## 4.1.2 - 2014-06-18

* Added support for sending payloads with GET requests

## 4.1.1 - 2014-06-08

* Fixed an issue related to using custom message factory options in subclasses
* Fixed an issue with nested form fields in a multi-part POST
* Fixed an issue with using the `json` request option for POST requests
* Added `ToArrayInterface` to `GuzzleHttp\Cookie\CookieJar`

## 4.1.0 - 2014-05-27

* Added a `json` request option to easily serialize JSON payloads.
* Added a `GuzzleHttp\json_decode()` wrapper to safely parse JSON.
* Added `setPort()` and `getPort()` to `GuzzleHttp\Message\RequestInterface`.
* Added the ability to provide an emitter to a client in the client constructor.
* Added the ability to persist a cookie session using $_SESSION.
* Added a trait that can be used to add event listeners to an iterator.
* Removed request method constants from RequestInterface.
* Fixed warning when invalid request start-lines are received.
* Updated MessageFactory to work with custom request option methods.
* Updated cacert bundle to latest build.

4.0.2 (2014-04-16)
------------------

* Proxy requests using the StreamAdapter now properly use request_fulluri (#632)
* Added the ability to set scalars as POST fields (#628)

## 4.0.1 - 2014-04-04

* The HTTP status code of a response is now set as the exception code of
  RequestException objects.
* 303 redirects will now correctly switch from POST to GET requests.
* The default parallel adapter of a client now correctly uses the MultiAdapter.
* HasDataTrait now initializes the internal data array as an empty array so
  that the toArray() method always returns an array.

## 4.0.0 - 2014-03-29

* For information on changes and upgrading, see:
  https://github.com/guzzle/guzzle/blob/master/UPGRADING.md#3x-to-40
* Added `GuzzleHttp\batch()` as a convenience function for sending requests in
  parallel without needing to write asynchronous code.
* Restructured how events are added to `GuzzleHttp\ClientInterface::sendAll()`.
  You can now pass a callable or an array of associative arrays where each
  associative array contains the "fn", "priority", and "once" keys.

## 4.0.0.rc-2 - 2014-03-25

* Removed `getConfig()` and `setConfig()` from clients to avoid confusion
  around whether things like base_url, message_factory, etc. should be able to
  be retrieved or modified.
* Added `getDefaultOption()` and `setDefaultOption()` to ClientInterface
* functions.php functions were renamed using snake_case to match PHP idioms
* Added support for `HTTP_PROXY`, `HTTPS_PROXY`, and
  `GUZZLE_CURL_SELECT_TIMEOUT` environment variables
* Added the ability to specify custom `sendAll()` event priorities
* Added the ability to specify custom stream context options to the stream
  adapter.
* Added a functions.php function for `get_path()` and `set_path()`
* CurlAdapter and MultiAdapter now use a callable to generate curl resources
* MockAdapter now properly reads a body and emits a `headers` event
* Updated Url class to check if a scheme and host are set before adding ":"
  and "//". This allows empty Url (e.g., "") to be serialized as "".
* Parsing invalid XML no longer emits warnings
* Curl classes now properly throw AdapterExceptions
* Various performance optimizations
* Streams are created with the faster `Stream\create()` function
* Marked deprecation_proxy() as internal
* Test server is now a collection of static methods on a class

## 4.0.0-rc.1 - 2014-03-15

* See https://github.com/guzzle/guzzle/blob/master/UPGRADING.md#3x-to-40

## 3.8.1 - 2014-01-28

* Bug: Always using GET requests when redirecting from a 303 response
* Bug: CURLOPT_SSL_VERIFYHOST is now correctly set to false when setting `$certificateAuthority` to false in
  `Guzzle\Http\ClientInterface::setSslVerification()`
* Bug: RedirectPlugin now uses strict RFC 3986 compliance when combining a base URL with a relative URL
* Bug: The body of a request can now be set to `"0"`
* Sending PHP stream requests no longer forces `HTTP/1.0`
* Adding more information to ExceptionCollection exceptions so that users have more context, including a stack trace of
  each sub-exception
* Updated the `$ref` attribute in service descriptions to merge over any existing parameters of a schema (rather than
  clobbering everything).
* Merging URLs will now use the query string object from the relative URL (thus allowing custom query aggregators)
* Query strings are now parsed in a way that they do no convert empty keys with no value to have a dangling `=`.
  For example `foo&bar=baz` is now correctly parsed and recognized as `foo&bar=baz` rather than `foo=&bar=baz`.
* Now properly escaping the regular expression delimiter when matching Cookie domains.
* Network access is now disabled when loading XML documents

## 3.8.0 - 2013-12-05

* Added the ability to define a POST name for a file
* JSON response parsing now properly walks additionalProperties
* cURL error code 18 is now retried automatically in the BackoffPlugin
* Fixed a cURL error when URLs contain fragments
* Fixed an issue in the BackoffPlugin retry event where it was trying to access all exceptions as if they were
  CurlExceptions
* CURLOPT_PROGRESS function fix for PHP 5.5 (69fcc1e)
* Added the ability for Guzzle to work with older versions of cURL that do not support `CURLOPT_TIMEOUT_MS`
* Fixed a bug that was encountered when parsing empty header parameters
* UriTemplate now has a `setRegex()` method to match the docs
* The `debug` request parameter now checks if it is truthy rather than if it exists
* Setting the `debug` request parameter to true shows verbose cURL output instead of using the LogPlugin
* Added the ability to combine URLs using strict RFC 3986 compliance
* Command objects can now return the validation errors encountered by the command
* Various fixes to cache revalidation (#437 and 29797e5)
* Various fixes to the AsyncPlugin
* Cleaned up build scripts

## 3.7.4 - 2013-10-02

* Bug fix: 0 is now an allowed value in a description parameter that has a default value (#430)
* Bug fix: SchemaFormatter now returns an integer when formatting to a Unix timestamp
  (see https://github.com/aws/aws-sdk-php/issues/147)
* Bug fix: Cleaned up and fixed URL dot segment removal to properly resolve internal dots
* Minimum PHP version is now properly specified as 5.3.3 (up from 5.3.2) (#420)
* Updated the bundled cacert.pem (#419)
* OauthPlugin now supports adding authentication to headers or query string (#425)

## 3.7.3 - 2013-09-08

* Added the ability to get the exception associated with a request/command when using `MultiTransferException` and
  `CommandTransferException`.
* Setting `additionalParameters` of a response to false is now honored when parsing responses with a service description
* Schemas are only injected into response models when explicitly configured.
* No longer guessing Content-Type based on the path of a request. Content-Type is now only guessed based on the path of
  an EntityBody.
* Bug fix: ChunkedIterator can now properly chunk a \Traversable as well as an \Iterator.
* Bug fix: FilterIterator now relies on `\Iterator` instead of `\Traversable`.
* Bug fix: Gracefully handling malformed responses in RequestMediator::writeResponseBody()
* Bug fix: Replaced call to canCache with canCacheRequest in the CallbackCanCacheStrategy of the CachePlugin
* Bug fix: Visiting XML attributes first before visiting XML children when serializing requests
* Bug fix: Properly parsing headers that contain commas contained in quotes
* Bug fix: mimetype guessing based on a filename is now case-insensitive

## 3.7.2 - 2013-08-02

* Bug fix: Properly URL encoding paths when using the PHP-only version of the UriTemplate expander
  See https://github.com/guzzle/guzzle/issues/371
* Bug fix: Cookie domains are now matched correctly according to RFC 6265
  See https://github.com/guzzle/guzzle/issues/377
* Bug fix: GET parameters are now used when calculating an OAuth signature
* Bug fix: Fixed an issue with cache revalidation where the If-None-Match header was being double quoted
* `Guzzle\Common\AbstractHasDispatcher::dispatch()` now returns the event that was dispatched
* `Guzzle\Http\QueryString::factory()` now guesses the most appropriate query aggregator to used based on the input.
  See https://github.com/guzzle/guzzle/issues/379
* Added a way to add custom domain objects to service description parsing using the `operation.parse_class` event. See
  https://github.com/guzzle/guzzle/pull/380
* cURL multi cleanup and optimizations

## 3.7.1 - 2013-07-05

* Bug fix: Setting default options on a client now works
* Bug fix: Setting options on HEAD requests now works. See #352
* Bug fix: Moving stream factory before send event to before building the stream. See #353
* Bug fix: Cookies no longer match on IP addresses per RFC 6265
* Bug fix: Correctly parsing header parameters that are in `<>` and quotes
* Added `cert` and `ssl_key` as request options
* `Host` header can now diverge from the host part of a URL if the header is set manually
* `Guzzle\Service\Command\LocationVisitor\Request\XmlVisitor` was rewritten to change from using SimpleXML to XMLWriter
* OAuth parameters are only added via the plugin if they aren't already set
* Exceptions are now thrown when a URL cannot be parsed
* Returning `false` if `Guzzle\Http\EntityBody::getContentMd5()` fails
* Not setting a `Content-MD5` on a command if calculating the Content-MD5 fails via the CommandContentMd5Plugin

## 3.7.0 - 2013-06-10

* See UPGRADING.md for more information on how to upgrade.
* Requests now support the ability to specify an array of $options when creating a request to more easily modify a
  request. You can pass a 'request.options' configuration setting to a client to apply default request options to
  every request created by a client (e.g. default query string variables, headers, curl options, etc.).
* Added a static facade class that allows you to use Guzzle with static methods and mount the class to `\Guzzle`.
  See `Guzzle\Http\StaticClient::mount`.
* Added `command.request_options` to `Guzzle\Service\Command\AbstractCommand` to pass request options to requests
      created by a command (e.g. custom headers, query string variables, timeout settings, etc.).
* Stream size in `Guzzle\Stream\PhpStreamRequestFactory` will now be set if Content-Length is returned in the
  headers of a response
* Added `Guzzle\Common\Collection::setPath($path, $value)` to set a value into an array using a nested key
  (e.g. `$collection->setPath('foo/baz/bar', 'test'); echo $collection['foo']['bar']['bar'];`)
* ServiceBuilders now support storing and retrieving arbitrary data
* CachePlugin can now purge all resources for a given URI
* CachePlugin can automatically purge matching cached items when a non-idempotent request is sent to a resource
* CachePlugin now uses the Vary header to determine if a resource is a cache hit
* `Guzzle\Http\Message\Response` now implements `\Serializable`
* Added `Guzzle\Cache\CacheAdapterFactory::fromCache()` to more easily create cache adapters
* `Guzzle\Service\ClientInterface::execute()` now accepts an array, single command, or Traversable
* Fixed a bug in `Guzzle\Http\Message\Header\Link::addLink()`
* Better handling of calculating the size of a stream in `Guzzle\Stream\Stream` using fstat() and caching the size
* `Guzzle\Common\Exception\ExceptionCollection` now creates a more readable exception message
* Fixing BC break: Added back the MonologLogAdapter implementation rather than extending from PsrLog so that older
  Symfony users can still use the old version of Monolog.
* Fixing BC break: Added the implementation back in for `Guzzle\Http\Message\AbstractMessage::getTokenizedHeader()`.
  Now triggering an E_USER_DEPRECATED warning when used. Use `$message->getHeader()->parseParams()`.
* Several performance improvements to `Guzzle\Common\Collection`
* Added an `$options` argument to the end of the following methods of `Guzzle\Http\ClientInterface`:
  createRequest, head, delete, put, patch, post, options, prepareRequest
* Added an `$options` argument to the end of `Guzzle\Http\Message\Request\RequestFactoryInterface::createRequest()`
* Added an `applyOptions()` method to `Guzzle\Http\Message\Request\RequestFactoryInterface`
* Changed `Guzzle\Http\ClientInterface::get($uri = null, $headers = null, $body = null)` to
  `Guzzle\Http\ClientInterface::get($uri = null, $headers = null, $options = array())`. You can still pass in a
  resource, string, or EntityBody into the $options parameter to specify the download location of the response.
* Changed `Guzzle\Common\Collection::__construct($data)` to no longer accepts a null value for `$data` but a
  default `array()`
* Added `Guzzle\Stream\StreamInterface::isRepeatable`
* Removed `Guzzle\Http\ClientInterface::setDefaultHeaders(). Use
  $client->getConfig()->setPath('request.options/headers/{header_name}', 'value')`. or
  $client->getConfig()->setPath('request.options/headers', array('header_name' => 'value'))`.
* Removed `Guzzle\Http\ClientInterface::getDefaultHeaders(). Use $client->getConfig()->getPath('request.options/headers')`.
* Removed `Guzzle\Http\ClientInterface::expandTemplate()`
* Removed `Guzzle\Http\ClientInterface::setRequestFactory()`
* Removed `Guzzle\Http\ClientInterface::getCurlMulti()`
* Removed `Guzzle\Http\Message\RequestInterface::canCache`
* Removed `Guzzle\Http\Message\RequestInterface::setIsRedirect`
* Removed `Guzzle\Http\Message\RequestInterface::isRedirect`
* Made `Guzzle\Http\Client::expandTemplate` and `getUriTemplate` protected methods.
* You can now enable E_USER_DEPRECATED warnings to see if you are using a deprecated method by setting
  `Guzzle\Common\Version::$emitWarnings` to true.
* Marked `Guzzle\Http\Message\Request::isResponseBodyRepeatable()` as deprecated. Use
      `$request->getResponseBody()->isRepeatable()` instead.
* Marked `Guzzle\Http\Message\Request::canCache()` as deprecated. Use
  `Guzzle\Plugin\Cache\DefaultCanCacheStrategy->canCacheRequest()` instead.
* Marked `Guzzle\Http\Message\Request::canCache()` as deprecated. Use
  `Guzzle\Plugin\Cache\DefaultCanCacheStrategy->canCacheRequest()` instead.
* Marked `Guzzle\Http\Message\Request::setIsRedirect()` as deprecated. Use the HistoryPlugin instead.
* Marked `Guzzle\Http\Message\Request::isRedirect()` as deprecated. Use the HistoryPlugin instead.
* Marked `Guzzle\Cache\CacheAdapterFactory::factory()` as deprecated
* Marked 'command.headers', 'command.response_body' and 'command.on_complete' as deprecated for AbstractCommand.
  These will work through Guzzle 4.0
* Marked 'request.params' for `Guzzle\Http\Client` as deprecated. Use [request.options][params].
* Marked `Guzzle\Service\Client::enableMagicMethods()` as deprecated. Magic methods can no longer be disabled on a Guzzle\Service\Client.
* Marked `Guzzle\Service\Client::getDefaultHeaders()` as deprecated. Use $client->getConfig()->getPath('request.options/headers')`.
* Marked `Guzzle\Service\Client::setDefaultHeaders()` as deprecated. Use $client->getConfig()->setPath('request.options/headers/{header_name}', 'value')`.
* Marked `Guzzle\Parser\Url\UrlParser` as deprecated. Just use PHP's `parse_url()` and percent encode your UTF-8.
* Marked `Guzzle\Common\Collection::inject()` as deprecated.
* Marked `Guzzle\Plugin\CurlAuth\CurlAuthPlugin` as deprecated. Use `$client->getConfig()->setPath('request.options/auth', array('user', 'pass', 'Basic|Digest');`
* CacheKeyProviderInterface and DefaultCacheKeyProvider are no longer used. All of this logic is handled in a
  CacheStorageInterface. These two objects and interface will be removed in a future version.
* Always setting X-cache headers on cached responses
* Default cache TTLs are now handled by the CacheStorageInterface of a CachePlugin
* `CacheStorageInterface::cache($key, Response $response, $ttl = null)` has changed to `cache(RequestInterface
  $request, Response $response);`
* `CacheStorageInterface::fetch($key)` has changed to `fetch(RequestInterface $request);`
* `CacheStorageInterface::delete($key)` has changed to `delete(RequestInterface $request);`
* Added `CacheStorageInterface::purge($url)`
* `DefaultRevalidation::__construct(CacheKeyProviderInterface $cacheKey, CacheStorageInterface $cache, CachePlugin
  $plugin)` has changed to `DefaultRevalidation::__construct(CacheStorageInterface $cache,
  CanCacheStrategyInterface $canCache = null)`
* Added `RevalidationInterface::shouldRevalidate(RequestInterface $request, Response $response)`

## 3.6.0 - 2013-05-29

* ServiceDescription now implements ToArrayInterface
* Added command.hidden_params to blacklist certain headers from being treated as additionalParameters
* Guzzle can now correctly parse incomplete URLs
* Mixed casing of headers are now forced to be a single consistent casing across all values for that header.
* Messages internally use a HeaderCollection object to delegate handling case-insensitive header resolution
* Removed the whole changedHeader() function system of messages because all header changes now go through addHeader().
* Specific header implementations can be created for complex headers. When a message creates a header, it uses a
  HeaderFactory which can map specific headers to specific header classes. There is now a Link header and
  CacheControl header implementation.
* Removed from interface: Guzzle\Http\ClientInterface::setUriTemplate
* Removed from interface: Guzzle\Http\ClientInterface::setCurlMulti()
* Removed Guzzle\Http\Message\Request::receivedRequestHeader() and implemented this functionality in
  Guzzle\Http\Curl\RequestMediator
* Removed the optional $asString parameter from MessageInterface::getHeader(). Just cast the header to a string.
* Removed the optional $tryChunkedTransfer option from Guzzle\Http\Message\EntityEnclosingRequestInterface
* Removed the $asObjects argument from Guzzle\Http\Message\MessageInterface::getHeaders()
* Removed Guzzle\Parser\ParserRegister::get(). Use getParser()
* Removed Guzzle\Parser\ParserRegister::set(). Use registerParser().
* All response header helper functions return a string rather than mixing Header objects and strings inconsistently
* Removed cURL blacklist support. This is no longer necessary now that Expect, Accept, etc. are managed by Guzzle
  directly via interfaces
* Removed the injecting of a request object onto a response object. The methods to get and set a request still exist
  but are a no-op until removed.
* Most classes that used to require a `Guzzle\Service\Command\CommandInterface` typehint now request a
  `Guzzle\Service\Command\ArrayCommandInterface`.
* Added `Guzzle\Http\Message\RequestInterface::startResponse()` to the RequestInterface to handle injecting a response
  on a request while the request is still being transferred
* The ability to case-insensitively search for header values
* Guzzle\Http\Message\Header::hasExactHeader
* Guzzle\Http\Message\Header::raw. Use getAll()
* Deprecated cache control specific methods on Guzzle\Http\Message\AbstractMessage. Use the CacheControl header object
  instead.
* `Guzzle\Service\Command\CommandInterface` now extends from ToArrayInterface and ArrayAccess
* Added the ability to cast Model objects to a string to view debug information.

## 3.5.0 - 2013-05-13

* Bug: Fixed a regression so that request responses are parsed only once per oncomplete event rather than multiple times
* Bug: Better cleanup of one-time events across the board (when an event is meant to fire once, it will now remove
  itself from the EventDispatcher)
* Bug: `Guzzle\Log\MessageFormatter` now properly writes "total_time" and "connect_time" values
* Bug: Cloning an EntityEnclosingRequest now clones the EntityBody too
* Bug: Fixed an undefined index error when parsing nested JSON responses with a sentAs parameter that reference a
  non-existent key
* Bug: All __call() method arguments are now required (helps with mocking frameworks)
* Deprecating Response::getRequest() and now using a shallow clone of a request object to remove a circular reference
  to help with refcount based garbage collection of resources created by sending a request
* Deprecating ZF1 cache and log adapters. These will be removed in the next major version.
* Deprecating `Response::getPreviousResponse()` (method signature still exists, but it's deprecated). Use the
  HistoryPlugin for a history.
* Added a `responseBody` alias for the `response_body` location
* Refactored internals to no longer rely on Response::getRequest()
* HistoryPlugin can now be cast to a string
* HistoryPlugin now logs transactions rather than requests and responses to more accurately keep track of the requests
  and responses that are sent over the wire
* Added `getEffectiveUrl()` and `getRedirectCount()` to Response objects

## 3.4.3 - 2013-04-30

* Bug fix: Fixing bug introduced in 3.4.2 where redirect responses are duplicated on the final redirected response
* Added a check to re-extract the temp cacert bundle from the phar before sending each request

## 3.4.2 - 2013-04-29

* Bug fix: Stream objects now work correctly with "a" and "a+" modes
* Bug fix: Removing `Transfer-Encoding: chunked` header when a Content-Length is present
* Bug fix: AsyncPlugin no longer forces HEAD requests
* Bug fix: DateTime timezones are now properly handled when using the service description schema formatter
* Bug fix: CachePlugin now properly handles stale-if-error directives when a request to the origin server fails
* Setting a response on a request will write to the custom request body from the response body if one is specified
* LogPlugin now writes to php://output when STDERR is undefined
* Added the ability to set multiple POST files for the same key in a single call
* application/x-www-form-urlencoded POSTs now use the utf-8 charset by default
* Added the ability to queue CurlExceptions to the MockPlugin
* Cleaned up how manual responses are queued on requests (removed "queued_response" and now using request.before_send)
* Configuration loading now allows remote files

## 3.4.1 - 2013-04-16

* Large refactoring to how CurlMulti handles work. There is now a proxy that sits in front of a pool of CurlMulti
  handles. This greatly simplifies the implementation, fixes a couple bugs, and provides a small performance boost.
* Exceptions are now properly grouped when sending requests in parallel
* Redirects are now properly aggregated when a multi transaction fails
* Redirects now set the response on the original object even in the event of a failure
* Bug fix: Model names are now properly set even when using $refs
* Added support for PHP 5.5's CurlFile to prevent warnings with the deprecated @ syntax
* Added support for oauth_callback in OAuth signatures
* Added support for oauth_verifier in OAuth signatures
* Added support to attempt to retrieve a command first literally, then ucfirst, the with inflection

## 3.4.0 - 2013-04-11

* Bug fix: URLs are now resolved correctly based on https://tools.ietf.org/html/rfc3986#section-5.2. #289
* Bug fix: Absolute URLs with a path in a service description will now properly override the base URL. #289
* Bug fix: Parsing a query string with a single PHP array value will now result in an array. #263
* Bug fix: Better normalization of the User-Agent header to prevent duplicate headers. #264.
* Bug fix: Added `number` type to service descriptions.
* Bug fix: empty parameters are removed from an OAuth signature
* Bug fix: Revalidating a cache entry prefers the Last-Modified over the Date header
* Bug fix: Fixed "array to string" error when validating a union of types in a service description
* Bug fix: Removed code that attempted to determine the size of a stream when data is written to the stream
* Bug fix: Not including an `oauth_token` if the value is null in the OauthPlugin.
* Bug fix: Now correctly aggregating successful requests and failed requests in CurlMulti when a redirect occurs.
* The new default CURLOPT_TIMEOUT setting has been increased to 150 seconds so that Guzzle works on poor connections.
* Added a feature to EntityEnclosingRequest::setBody() that will automatically set the Content-Type of the request if
  the Content-Type can be determined based on the entity body or the path of the request.
* Added the ability to overwrite configuration settings in a client when grabbing a throwaway client from a builder.
* Added support for a PSR-3 LogAdapter.
* Added a `command.after_prepare` event
* Added `oauth_callback` parameter to the OauthPlugin
* Added the ability to create a custom stream class when using a stream factory
* Added a CachingEntityBody decorator
* Added support for `additionalParameters` in service descriptions to define how custom parameters are serialized.
* The bundled SSL certificate is now provided in the phar file and extracted when running Guzzle from a phar.
* You can now send any EntityEnclosingRequest with POST fields or POST files and cURL will handle creating bodies
* POST requests using a custom entity body are now treated exactly like PUT requests but with a custom cURL method. This
  means that the redirect behavior of POST requests with custom bodies will not be the same as POST requests that use
  POST fields or files (the latter is only used when emulating a form POST in the browser).
* Lots of cleanup to CurlHandle::factory and RequestFactory::createRequest

## 3.3.1 - 2013-03-10

* Added the ability to create PHP streaming responses from HTTP requests
* Bug fix: Running any filters when parsing response headers with service descriptions
* Bug fix: OauthPlugin fixes to allow for multi-dimensional array signing, and sorting parameters before signing
* Bug fix: Removed the adding of default empty arrays and false Booleans to responses in order to be consistent across
  response location visitors.
* Bug fix: Removed the possibility of creating configuration files with circular dependencies
* RequestFactory::create() now uses the key of a POST file when setting the POST file name
* Added xmlAllowEmpty to serialize an XML body even if no XML specific parameters are set

## 3.3.0 - 2013-03-03

* A large number of performance optimizations have been made
* Bug fix: Added 'wb' as a valid write mode for streams
* Bug fix: `Guzzle\Http\Message\Response::json()` now allows scalar values to be returned
* Bug fix: Fixed bug in `Guzzle\Http\Message\Response` where wrapping quotes were stripped from `getEtag()`
* BC: Removed `Guzzle\Http\Utils` class
* BC: Setting a service description on a client will no longer modify the client's command factories.
* BC: Emitting IO events from a RequestMediator is now a parameter that must be set in a request's curl options using
  the 'emit_io' key. This was previously set under a request's parameters using 'curl.emit_io'
* BC: `Guzzle\Stream\Stream::getWrapper()` and `Guzzle\Stream\Stream::getSteamType()` are no longer converted to
  lowercase
* Operation parameter objects are now lazy loaded internally
* Added ErrorResponsePlugin that can throw errors for responses defined in service description operations' errorResponses
* Added support for instantiating responseType=class responseClass classes. Classes must implement
  `Guzzle\Service\Command\ResponseClassInterface`
* Added support for additionalProperties for top-level parameters in responseType=model responseClasses. These
  additional properties also support locations and can be used to parse JSON responses where the outermost part of the
  JSON is an array
* Added support for nested renaming of JSON models (rename sentAs to name)
* CachePlugin
    * Added support for stale-if-error so that the CachePlugin can now serve stale content from the cache on error
    * Debug headers can now added to cached response in the CachePlugin

## 3.2.0 - 2013-02-14

* CurlMulti is no longer reused globally. A new multi object is created per-client. This helps to isolate clients.
* URLs with no path no longer contain a "/" by default
* Guzzle\Http\QueryString does no longer manages the leading "?". This is now handled in Guzzle\Http\Url.
* BadResponseException no longer includes the full request and response message
* Adding setData() to Guzzle\Service\Description\ServiceDescriptionInterface
* Adding getResponseBody() to Guzzle\Http\Message\RequestInterface
* Various updates to classes to use ServiceDescriptionInterface type hints rather than ServiceDescription
* Header values can now be normalized into distinct values when multiple headers are combined with a comma separated list
* xmlEncoding can now be customized for the XML declaration of a XML service description operation
* Guzzle\Http\QueryString now uses Guzzle\Http\QueryAggregator\QueryAggregatorInterface objects to add custom value
  aggregation and no longer uses callbacks
* The URL encoding implementation of Guzzle\Http\QueryString can now be customized
* Bug fix: Filters were not always invoked for array service description parameters
* Bug fix: Redirects now use a target response body rather than a temporary response body
* Bug fix: The default exponential backoff BackoffPlugin was not giving when the request threshold was exceeded
* Bug fix: Guzzle now takes the first found value when grabbing Cache-Control directives

## 3.1.2 - 2013-01-27

* Refactored how operation responses are parsed. Visitors now include a before() method responsible for parsing the
  response body. For example, the XmlVisitor now parses the XML response into an array in the before() method.
* Fixed an issue where cURL would not automatically decompress responses when the Accept-Encoding header was sent
* CURLOPT_SSL_VERIFYHOST is never set to 1 because it is deprecated (see 5e0ff2ef20f839e19d1eeb298f90ba3598784444)
* Fixed a bug where redirect responses were not chained correctly using getPreviousResponse()
* Setting default headers on a client after setting the user-agent will not erase the user-agent setting

## 3.1.1 - 2013-01-20

* Adding wildcard support to Guzzle\Common\Collection::getPath()
* Adding alias support to ServiceBuilder configs
* Adding Guzzle\Service\Resource\CompositeResourceIteratorFactory and cleaning up factory interface

## 3.1.0 - 2013-01-12

* BC: CurlException now extends from RequestException rather than BadResponseException
* BC: Renamed Guzzle\Plugin\Cache\CanCacheStrategyInterface::canCache() to canCacheRequest() and added CanCacheResponse()
* Added getData to ServiceDescriptionInterface
* Added context array to RequestInterface::setState()
* Bug: Removing hard dependency on the BackoffPlugin from Guzzle\Http
* Bug: Adding required content-type when JSON request visitor adds JSON to a command
* Bug: Fixing the serialization of a service description with custom data
* Made it easier to deal with exceptions thrown when transferring commands or requests in parallel by providing
  an array of successful and failed responses
* Moved getPath from Guzzle\Service\Resource\Model to Guzzle\Common\Collection
* Added Guzzle\Http\IoEmittingEntityBody
* Moved command filtration from validators to location visitors
* Added `extends` attributes to service description parameters
* Added getModels to ServiceDescriptionInterface

## 3.0.7 - 2012-12-19

* Fixing phar detection when forcing a cacert to system if null or true
* Allowing filename to be passed to `Guzzle\Http\Message\Request::setResponseBody()`
* Cleaning up `Guzzle\Common\Collection::inject` method
* Adding a response_body location to service descriptions

## 3.0.6 - 2012-12-09

* CurlMulti performance improvements
* Adding setErrorResponses() to Operation
* composer.json tweaks

## 3.0.5 - 2012-11-18

* Bug: Fixing an infinite recursion bug caused from revalidating with the CachePlugin
* Bug: Response body can now be a string containing "0"
* Bug: Using Guzzle inside of a phar uses system by default but now allows for a custom cacert
* Bug: QueryString::fromString now properly parses query string parameters that contain equal signs
* Added support for XML attributes in service description responses
* DefaultRequestSerializer now supports array URI parameter values for URI template expansion
* Added better mimetype guessing to requests and post files

## 3.0.4 - 2012-11-11

* Bug: Fixed a bug when adding multiple cookies to a request to use the correct glue value
* Bug: Cookies can now be added that have a name, domain, or value set to "0"
* Bug: Using the system cacert bundle when using the Phar
* Added json and xml methods to Response to make it easier to parse JSON and XML response data into data structures
* Enhanced cookie jar de-duplication
* Added the ability to enable strict cookie jars that throw exceptions when invalid cookies are added
* Added setStream to StreamInterface to actually make it possible to implement custom rewind behavior for entity bodies
* Added the ability to create any sort of hash for a stream rather than just an MD5 hash

## 3.0.3 - 2012-11-04

* Implementing redirects in PHP rather than cURL
* Added PECL URI template extension and using as default parser if available
* Bug: Fixed Content-Length parsing of Response factory
* Adding rewind() method to entity bodies and streams. Allows for custom rewinding of non-repeatable streams.
* Adding ToArrayInterface throughout library
* Fixing OauthPlugin to create unique nonce values per request

## 3.0.2 - 2012-10-25

* Magic methods are enabled by default on clients
* Magic methods return the result of a command
* Service clients no longer require a base_url option in the factory
* Bug: Fixed an issue with URI templates where null template variables were being expanded

## 3.0.1 - 2012-10-22

* Models can now be used like regular collection objects by calling filter, map, etc.
* Models no longer require a Parameter structure or initial data in the constructor
* Added a custom AppendIterator to get around a PHP bug with the `\AppendIterator`

## 3.0.0 - 2012-10-15

* Rewrote service description format to be based on Swagger
    * Now based on JSON schema
    * Added nested input structures and nested response models
    * Support for JSON and XML input and output models
    * Renamed `commands` to `operations`
    * Removed dot class notation
    * Removed custom types
* Broke the project into smaller top-level namespaces to be more component friendly
* Removed support for XML configs and descriptions. Use arrays or JSON files.
* Removed the Validation component and Inspector
* Moved all cookie code to Guzzle\Plugin\Cookie
* Magic methods on a Guzzle\Service\Client now return the command un-executed.
* Calling getResult() or getResponse() on a command will lazily execute the command if needed.
* Now shipping with cURL's CA certs and using it by default
* Added previousResponse() method to response objects
* No longer sending Accept and Accept-Encoding headers on every request
* Only sending an Expect header by default when a payload is greater than 1MB
* Added/moved client options:
    * curl.blacklist to curl.option.blacklist
    * Added ssl.certificate_authority
* Added a Guzzle\Iterator component
* Moved plugins from Guzzle\Http\Plugin to Guzzle\Plugin
* Added a more robust backoff retry strategy (replaced the ExponentialBackoffPlugin)
* Added a more robust caching plugin
* Added setBody to response objects
* Updating LogPlugin to use a more flexible MessageFormatter
* Added a completely revamped build process
* Cleaning up Collection class and removing default values from the get method
* Fixed ZF2 cache adapters

## 2.8.8 - 2012-10-15

* Bug: Fixed a cookie issue that caused dot prefixed domains to not match where popular browsers did

## 2.8.7 - 2012-09-30

* Bug: Fixed config file aliases for JSON includes
* Bug: Fixed cookie bug on a request object by using CookieParser to parse cookies on requests
* Bug: Removing the path to a file when sending a Content-Disposition header on a POST upload
* Bug: Hardening request and response parsing to account for missing parts
* Bug: Fixed PEAR packaging
* Bug: Fixed Request::getInfo
* Bug: Fixed cases where CURLM_CALL_MULTI_PERFORM return codes were causing curl transactions to fail
* Adding the ability for the namespace Iterator factory to look in multiple directories
* Added more getters/setters/removers from service descriptions
* Added the ability to remove POST fields from OAuth signatures
* OAuth plugin now supports 2-legged OAuth

## 2.8.6 - 2012-09-05

* Added the ability to modify and build service descriptions
* Added the use of visitors to apply parameters to locations in service descriptions using the dynamic command
* Added a `json` parameter location
* Now allowing dot notation for classes in the CacheAdapterFactory
* Using the union of two arrays rather than an array_merge when extending service builder services and service params
* Ensuring that a service is a string before doing strpos() checks on it when substituting services for references
  in service builder config files.
* Services defined in two different config files that include one another will by default replace the previously
  defined service, but you can now create services that extend themselves and merge their settings over the previous
* The JsonLoader now supports aliasing filenames with different filenames. This allows you to alias something like
  '_default' with a default JSON configuration file.

## 2.8.5 - 2012-08-29

* Bug: Suppressed empty arrays from URI templates
* Bug: Added the missing $options argument from ServiceDescription::factory to enable caching
* Added support for HTTP responses that do not contain a reason phrase in the start-line
* AbstractCommand commands are now invokable
* Added a way to get the data used when signing an Oauth request before a request is sent

## 2.8.4 - 2012-08-15

* Bug: Custom delay time calculations are no longer ignored in the ExponentialBackoffPlugin
* Added the ability to transfer entity bodies as a string rather than streamed. This gets around curl error 65. Set `body_as_string` in a request's curl options to enable.
* Added a StreamInterface, EntityBodyInterface, and added ftell() to Guzzle\Common\Stream
* Added an AbstractEntityBodyDecorator and a ReadLimitEntityBody decorator to transfer only a subset of a decorated stream
* Stream and EntityBody objects will now return the file position to the previous position after a read required operation (e.g. getContentMd5())
* Added additional response status codes
* Removed SSL information from the default User-Agent header
* DELETE requests can now send an entity body
* Added an EventDispatcher to the ExponentialBackoffPlugin and added an ExponentialBackoffLogger to log backoff retries
* Added the ability of the MockPlugin to consume mocked request bodies
* LogPlugin now exposes request and response objects in the extras array

## 2.8.3 - 2012-07-30

* Bug: Fixed a case where empty POST requests were sent as GET requests
* Bug: Fixed a bug in ExponentialBackoffPlugin that caused fatal errors when retrying an EntityEnclosingRequest that does not have a body
* Bug: Setting the response body of a request to null after completing a request, not when setting the state of a request to new
* Added multiple inheritance to service description commands
* Added an ApiCommandInterface and added `getParamNames()` and `hasParam()`
* Removed the default 2mb size cutoff from the Md5ValidatorPlugin so that it now defaults to validating everything
* Changed CurlMulti::perform to pass a smaller timeout to CurlMulti::executeHandles

## 2.8.2 - 2012-07-24

* Bug: Query string values set to 0 are no longer dropped from the query string
* Bug: A Collection object is no longer created each time a call is made to `Guzzle\Service\Command\AbstractCommand::getRequestHeaders()`
* Bug: `+` is now treated as an encoded space when parsing query strings
* QueryString and Collection performance improvements
* Allowing dot notation for class paths in filters attribute of a service descriptions

## 2.8.1 - 2012-07-16

* Loosening Event Dispatcher dependency
* POST redirects can now be customized using CURLOPT_POSTREDIR

## 2.8.0 - 2012-07-15

* BC: Guzzle\Http\Query
    * Query strings with empty variables will always show an equal sign unless the variable is set to QueryString::BLANK (e.g. ?acl= vs ?acl)
    * Changed isEncodingValues() and isEncodingFields() to isUrlEncoding()
    * Changed setEncodeValues(bool) and setEncodeFields(bool) to useUrlEncoding(bool)
    * Changed the aggregation functions of QueryString to be static methods
    * Can now use fromString() with querystrings that have a leading ?
* cURL configuration values can be specified in service descriptions using `curl.` prefixed parameters
* Content-Length is set to 0 before emitting the request.before_send event when sending an empty request body
* Cookies are no longer URL decoded by default
* Bug: URI template variables set to null are no longer expanded

## 2.7.2 - 2012-07-02

* BC: Moving things to get ready for subtree splits. Moving Inflection into Common. Moving Guzzle\Http\Parser to Guzzle\Parser.
* BC: Removing Guzzle\Common\Batch\Batch::count() and replacing it with isEmpty()
* CachePlugin now allows for a custom request parameter function to check if a request can be cached
* Bug fix: CachePlugin now only caches GET and HEAD requests by default
* Bug fix: Using header glue when transferring headers over the wire
* Allowing deeply nested arrays for composite variables in URI templates
* Batch divisors can now return iterators or arrays

## 2.7.1 - 2012-06-26

* Minor patch to update version number in UA string
* Updating build process

## 2.7.0 - 2012-06-25

* BC: Inflection classes moved to Guzzle\Inflection. No longer static methods. Can now inject custom inflectors into classes.
* BC: Removed magic setX methods from commands
* BC: Magic methods mapped to service description commands are now inflected in the command factory rather than the client __call() method
* Verbose cURL options are no longer enabled by default. Set curl.debug to true on a client to enable.
* Bug: Now allowing colons in a response start-line (e.g. HTTP/1.1 503 Service Unavailable: Back-end server is at capacity)
* Guzzle\Service\Resource\ResourceIteratorApplyBatched now internally uses the Guzzle\Common\Batch namespace
* Added Guzzle\Service\Plugin namespace and a PluginCollectionPlugin
* Added the ability to set POST fields and files in a service description
* Guzzle\Http\EntityBody::factory() now accepts objects with a __toString() method
* Adding a command.before_prepare event to clients
* Added BatchClosureTransfer and BatchClosureDivisor
* BatchTransferException now includes references to the batch divisor and transfer strategies
* Fixed some tests so that they pass more reliably
* Added Guzzle\Common\Log\ArrayLogAdapter

## 2.6.6 - 2012-06-10

* BC: Removing Guzzle\Http\Plugin\BatchQueuePlugin
* BC: Removing Guzzle\Service\Command\CommandSet
* Adding generic batching system (replaces the batch queue plugin and command set)
* Updating ZF cache and log adapters and now using ZF's composer repository
* Bug: Setting the name of each ApiParam when creating through an ApiCommand
* Adding result_type, result_doc, deprecated, and doc_url to service descriptions
* Bug: Changed the default cookie header casing back to 'Cookie'

## 2.6.5 - 2012-06-03

* BC: Renaming Guzzle\Http\Message\RequestInterface::getResourceUri() to getResource()
* BC: Removing unused AUTH_BASIC and AUTH_DIGEST constants from
* BC: Guzzle\Http\Cookie is now used to manage Set-Cookie data, not Cookie data
* BC: Renaming methods in the CookieJarInterface
* Moving almost all cookie logic out of the CookiePlugin and into the Cookie or CookieJar implementations
* Making the default glue for HTTP headers ';' instead of ','
* Adding a removeValue to Guzzle\Http\Message\Header
* Adding getCookies() to request interface.
* Making it easier to add event subscribers to HasDispatcherInterface classes. Can now directly call addSubscriber()

## 2.6.4 - 2012-05-30

* BC: Cleaning up how POST files are stored in EntityEnclosingRequest objects. Adding PostFile class.
* BC: Moving ApiCommand specific functionality from the Inspector and on to the ApiCommand
* Bug: Fixing magic method command calls on clients
* Bug: Email constraint only validates strings
* Bug: Aggregate POST fields when POST files are present in curl handle
* Bug: Fixing default User-Agent header
* Bug: Only appending or prepending parameters in commands if they are specified
* Bug: Not requiring response reason phrases or status codes to match a predefined list of codes
* Allowing the use of dot notation for class namespaces when using instance_of constraint
* Added any_match validation constraint
* Added an AsyncPlugin
* Passing request object to the calculateWait method of the ExponentialBackoffPlugin
* Allowing the result of a command object to be changed
* Parsing location and type sub values when instantiating a service description rather than over and over at runtime

## 2.6.3 - 2012-05-23

* [BC] Guzzle\Common\FromConfigInterface no longer requires any config options.
* [BC] Refactoring how POST files are stored on an EntityEnclosingRequest. They are now separate from POST fields.
* You can now use an array of data when creating PUT request bodies in the request factory.
* Removing the requirement that HTTPS requests needed a Cache-Control: public directive to be cacheable.
* [Http] Adding support for Content-Type in multipart POST uploads per upload
* [Http] Added support for uploading multiple files using the same name (foo[0], foo[1])
* Adding more POST data operations for easier manipulation of POST data.
* You can now set empty POST fields.
* The body of a request is only shown on EntityEnclosingRequest objects that do not use POST files.
* Split the Guzzle\Service\Inspector::validateConfig method into two methods. One to initialize when a command is created, and one to validate.
* CS updates

## 2.6.2 - 2012-05-19

* [Http] Better handling of nested scope requests in CurlMulti.  Requests are now always prepares in the send() method rather than the addRequest() method.

## 2.6.1 - 2012-05-19

* [BC] Removing 'path' support in service descriptions.  Use 'uri'.
* [BC] Guzzle\Service\Inspector::parseDocBlock is now protected. Adding getApiParamsForClass() with cache.
* [BC] Removing Guzzle\Common\NullObject.  Use https://github.com/mtdowling/NullObject if you need it.
* [BC] Removing Guzzle\Common\XmlElement.
* All commands, both dynamic and concrete, have ApiCommand objects.
* Adding a fix for CurlMulti so that if all of the connections encounter some sort of curl error, then the loop exits.
* Adding checks to EntityEnclosingRequest so that empty POST files and fields are ignored.
* Making the method signature of Guzzle\Service\Builder\ServiceBuilder::factory more flexible.

## 2.6.0 - 2012-05-15

* [BC] Moving Guzzle\Service\Builder to Guzzle\Service\Builder\ServiceBuilder
* [BC] Executing a Command returns the result of the command rather than the command
* [BC] Moving all HTTP parsing logic to Guzzle\Http\Parsers. Allows for faster C implementations if needed.
* [BC] Changing the Guzzle\Http\Message\Response::setProtocol() method to accept a protocol and version in separate args.
* [BC] Moving ResourceIterator* to Guzzle\Service\Resource
* [BC] Completely refactored ResourceIterators to iterate over a cloned command object
* [BC] Moved Guzzle\Http\UriTemplate to Guzzle\Http\Parser\UriTemplate\UriTemplate
* [BC] Guzzle\Guzzle is now deprecated
* Moving Guzzle\Common\Guzzle::inject to Guzzle\Common\Collection::inject
* Adding Guzzle\Version class to give version information about Guzzle
* Adding Guzzle\Http\Utils class to provide getDefaultUserAgent() and getHttpDate()
* Adding Guzzle\Curl\CurlVersion to manage caching curl_version() data
* ServiceDescription and ServiceBuilder are now cacheable using similar configs
* Changing the format of XML and JSON service builder configs.  Backwards compatible.
* Cleaned up Cookie parsing
* Trimming the default Guzzle User-Agent header
* Adding a setOnComplete() method to Commands that is called when a command completes
* Keeping track of requests that were mocked in the MockPlugin
* Fixed a caching bug in the CacheAdapterFactory
* Inspector objects can be injected into a Command object
* Refactoring a lot of code and tests to be case insensitive when dealing with headers
* Adding Guzzle\Http\Message\HeaderComparison for easy comparison of HTTP headers using a DSL
* Adding the ability to set global option overrides to service builder configs
* Adding the ability to include other service builder config files from within XML and JSON files
* Moving the parseQuery method out of Url and on to QueryString::fromString() as a static factory method.

## 2.5.0 - 2012-05-08

* Major performance improvements
* [BC] Simplifying Guzzle\Common\Collection.  Please check to see if you are using features that are now deprecated.
* [BC] Using a custom validation system that allows a flyweight implementation for much faster validation. No longer using Symfony2 Validation component.
* [BC] No longer supporting "{{ }}" for injecting into command or UriTemplates.  Use "{}"
* Added the ability to passed parameters to all requests created by a client
* Added callback functionality to the ExponentialBackoffPlugin
* Using microtime in ExponentialBackoffPlugin to allow more granular backoff strategies.
* Rewinding request stream bodies when retrying requests
* Exception is thrown when JSON response body cannot be decoded
* Added configurable magic method calls to clients and commands.  This is off by default.
* Fixed a defect that added a hash to every parsed URL part
* Fixed duplicate none generation for OauthPlugin.
* Emitting an event each time a client is generated by a ServiceBuilder
* Using an ApiParams object instead of a Collection for parameters of an ApiCommand
* cache.* request parameters should be renamed to params.cache.*
* Added the ability to set arbitrary curl options on requests (disable_wire, progress, etc.). See CurlHandle.
* Added the ability to disable type validation of service descriptions
* ServiceDescriptions and ServiceBuilders are now Serializable


Archivo: onzauth/vendor/guzzlehttp/guzzle/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/README.md
Tipo de archivo: text/markdown

Contenido:
![Guzzle](.github/logo.png?raw=true)

# Guzzle, PHP HTTP client

[![Latest Version](https://img.shields.io/github/release/guzzle/guzzle.svg?style=flat-square)](https://github.com/guzzle/guzzle/releases)
[![Build Status](https://img.shields.io/github/workflow/status/guzzle/guzzle/CI?label=ci%20build&style=flat-square)](https://github.com/guzzle/guzzle/actions?query=workflow%3ACI)
[![Total Downloads](https://img.shields.io/packagist/dt/guzzlehttp/guzzle.svg?style=flat-square)](https://packagist.org/packages/guzzlehttp/guzzle)

Guzzle is a PHP HTTP client that makes it easy to send HTTP requests and
trivial to integrate with web services.

- Simple interface for building query strings, POST requests, streaming large
  uploads, streaming large downloads, using HTTP cookies, uploading JSON data,
  etc...
- Can send both synchronous and asynchronous requests using the same interface.
- Uses PSR-7 interfaces for requests, responses, and streams. This allows you
  to utilize other PSR-7 compatible libraries with Guzzle.
- Supports PSR-18 allowing interoperability between other PSR-18 HTTP Clients.
- Abstracts away the underlying HTTP transport, allowing you to write
  environment and transport agnostic code; i.e., no hard dependency on cURL,
  PHP streams, sockets, or non-blocking event loops.
- Middleware system allows you to augment and compose client behavior.

```php
$client = new \GuzzleHttp\Client();
$response = $client->request('GET', 'https://api.github.com/repos/guzzle/guzzle');

echo $response->getStatusCode(); // 200
echo $response->getHeaderLine('content-type'); // 'application/json; charset=utf8'
echo $response->getBody(); // '{"id": 1420053, "name": "guzzle", ...}'

// Send an asynchronous request.
$request = new \GuzzleHttp\Psr7\Request('GET', 'http://httpbin.org');
$promise = $client->sendAsync($request)->then(function ($response) {
    echo 'I completed! ' . $response->getBody();
});

$promise->wait();
```

## Help and docs

We use GitHub issues only to discuss bugs and new features. For support please refer to:

- [Documentation](https://docs.guzzlephp.org)
- [Stack Overflow](https://stackoverflow.com/questions/tagged/guzzle)
- [#guzzle](https://app.slack.com/client/T0D2S9JCT/CE6UAAKL4) channel on [PHP-HTTP Slack](https://slack.httplug.io/)
- [Gitter](https://gitter.im/guzzle/guzzle)


## Installing Guzzle

The recommended way to install Guzzle is through
[Composer](https://getcomposer.org/).

```bash
composer require guzzlehttp/guzzle
```


## Version Guidance

| Version | Status         | Packagist           | Namespace    | Repo                | Docs                | PSR-7 | PHP Version  |
|---------|----------------|---------------------|--------------|---------------------|---------------------|-------|--------------|
| 3.x     | EOL            | `guzzle/guzzle`     | `Guzzle`     | [v3][guzzle-3-repo] | [v3][guzzle-3-docs] | No    | >=5.3.3,<7.0 |
| 4.x     | EOL            | `guzzlehttp/guzzle` | `GuzzleHttp` | [v4][guzzle-4-repo] | N/A                 | No    | >=5.4,<7.0   |
| 5.x     | EOL            | `guzzlehttp/guzzle` | `GuzzleHttp` | [v5][guzzle-5-repo] | [v5][guzzle-5-docs] | No    | >=5.4,<7.4   |
| 6.x     | Security fixes | `guzzlehttp/guzzle` | `GuzzleHttp` | [v6][guzzle-6-repo] | [v6][guzzle-6-docs] | Yes   | >=5.5,<8.0   |
| 7.x     | Latest         | `guzzlehttp/guzzle` | `GuzzleHttp` | [v7][guzzle-7-repo] | [v7][guzzle-7-docs] | Yes   | >=7.2.5,<8.3 |

[guzzle-3-repo]: https://github.com/guzzle/guzzle3
[guzzle-4-repo]: https://github.com/guzzle/guzzle/tree/4.x
[guzzle-5-repo]: https://github.com/guzzle/guzzle/tree/5.3
[guzzle-6-repo]: https://github.com/guzzle/guzzle/tree/6.5
[guzzle-7-repo]: https://github.com/guzzle/guzzle
[guzzle-3-docs]: https://guzzle3.readthedocs.io/
[guzzle-5-docs]: https://docs.guzzlephp.org/en/5.3/
[guzzle-6-docs]: https://docs.guzzlephp.org/en/6.5/
[guzzle-7-docs]: https://docs.guzzlephp.org/en/latest/


## Security

If you discover a security vulnerability within this package, please send an email to security@tidelift.com. All security vulnerabilities will be promptly addressed. Please do not disclose security-related issues publicly until a fix has been announced. Please see [Security Policy](https://github.com/guzzle/guzzle/security/policy) for more information.

## License

Guzzle is made available under the MIT License (MIT). Please see [License File](LICENSE) for more information.

## For Enterprise

Available as part of the Tidelift Subscription

The maintainers of Guzzle and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/packagist-guzzlehttp-guzzle?utm_source=packagist-guzzlehttp-guzzle&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)


Carpeta: onzauth/vendor/guzzlehttp/guzzle/src/

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/BodySummarizerInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/BodySummarizer.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/ClientInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Client.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/ClientTrait.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/guzzlehttp/guzzle/src/Cookie/

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Cookie/CookieJarInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Cookie/CookieJar.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Cookie/FileCookieJar.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Cookie/SessionCookieJar.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Cookie/SetCookie.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/guzzlehttp/guzzle/src/Exception/

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/BadResponseException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/ClientException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/ConnectException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/GuzzleException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/InvalidArgumentException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/RequestException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/ServerException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/TooManyRedirectsException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Exception/TransferException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/functions_include.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/functions.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/guzzlehttp/guzzle/src/Handler/

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/CurlFactoryInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/CurlFactory.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/CurlHandler.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/CurlMultiHandler.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/EasyHandle.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/HeaderProcessor.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/MockHandler.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/Proxy.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/HandlerStack.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Handler/StreamHandler.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/MessageFormatterInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/MessageFormatter.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Middleware.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Pool.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/PrepareBodyMiddleware.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/RedirectMiddleware.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/RequestOptions.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/RetryMiddleware.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/TransferStats.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/src/Utils.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/guzzle/UPGRADING.md
Tipo de archivo: text/markdown

Contenido:
Guzzle Upgrade Guide
====================

6.0 to 7.0
----------

In order to take advantage of the new features of PHP, Guzzle dropped the support
of PHP 5. The minimum supported PHP version is now PHP 7.2. Type hints and return
types for functions and methods have been added wherever possible. 

Please make sure:
- You are calling a function or a method with the correct type.
- If you extend a class of Guzzle; update all signatures on methods you override.

#### Other backwards compatibility breaking changes

- Class `GuzzleHttp\UriTemplate` is removed.
- Class `GuzzleHttp\Exception\SeekException` is removed.
- Classes `GuzzleHttp\Exception\BadResponseException`, `GuzzleHttp\Exception\ClientException`, 
  `GuzzleHttp\Exception\ServerException` can no longer be initialized with an empty
  Response as argument.
- Class `GuzzleHttp\Exception\ConnectException` now extends `GuzzleHttp\Exception\TransferException`
  instead of `GuzzleHttp\Exception\RequestException`.
- Function `GuzzleHttp\Exception\ConnectException::getResponse()` is removed.
- Function `GuzzleHttp\Exception\ConnectException::hasResponse()` is removed.
- Constant `GuzzleHttp\ClientInterface::VERSION` is removed. Added `GuzzleHttp\ClientInterface::MAJOR_VERSION` instead.
- Function `GuzzleHttp\Exception\RequestException::getResponseBodySummary` is removed.
  Use `\GuzzleHttp\Psr7\get_message_body_summary` as an alternative.
- Function `GuzzleHttp\Cookie\CookieJar::getCookieValue` is removed.
- Request option `exception` is removed. Please use `http_errors`.
- Request option `save_to` is removed. Please use `sink`.
- Pool option `pool_size` is removed. Please use `concurrency`.
- We now look for environment variables in the `$_SERVER` super global, due to thread safety issues with `getenv`. We continue to fallback to `getenv` in CLI environments, for maximum compatibility.
- The `get`, `head`, `put`, `post`, `patch`, `delete`, `getAsync`, `headAsync`, `putAsync`, `postAsync`, `patchAsync`, and `deleteAsync` methods are now implemented as genuine methods on `GuzzleHttp\Client`, with strong typing. The original `__call` implementation remains unchanged for now, for maximum backwards compatibility, but won't be invoked under normal operation.
- The `log` middleware will log the errors with level `error` instead of `notice` 
- Support for international domain names (IDN) is now disabled by default, and enabling it requires installing ext-intl, linked against a modern version of the C library (ICU 4.6 or higher).

#### Native functions calls

All internal native functions calls of Guzzle are now prefixed with a slash. This
change makes it impossible for method overloading by other libraries or applications.
Example:

```php
// Before:
curl_version();

// After:
\curl_version();
```

For the full diff you can check [here](https://github.com/guzzle/guzzle/compare/6.5.4..master).

5.0 to 6.0
----------

Guzzle now uses [PSR-7](https://www.php-fig.org/psr/psr-7/) for HTTP messages.
Due to the fact that these messages are immutable, this prompted a refactoring
of Guzzle to use a middleware based system rather than an event system. Any
HTTP message interaction (e.g., `GuzzleHttp\Message\Request`) need to be
updated to work with the new immutable PSR-7 request and response objects. Any
event listeners or subscribers need to be updated to become middleware
functions that wrap handlers (or are injected into a
`GuzzleHttp\HandlerStack`).

- Removed `GuzzleHttp\BatchResults`
- Removed `GuzzleHttp\Collection`
- Removed `GuzzleHttp\HasDataTrait`
- Removed `GuzzleHttp\ToArrayInterface`
- The `guzzlehttp/streams` dependency has been removed. Stream functionality
  is now present in the `GuzzleHttp\Psr7` namespace provided by the
  `guzzlehttp/psr7` package.
- Guzzle no longer uses ReactPHP promises and now uses the
  `guzzlehttp/promises` library. We use a custom promise library for three
  significant reasons:
  1. React promises (at the time of writing this) are recursive. Promise
     chaining and promise resolution will eventually blow the stack. Guzzle
     promises are not recursive as they use a sort of trampolining technique.
     Note: there has been movement in the React project to modify promises to
     no longer utilize recursion.
  2. Guzzle needs to have the ability to synchronously block on a promise to
     wait for a result. Guzzle promises allows this functionality (and does
     not require the use of recursion).
  3. Because we need to be able to wait on a result, doing so using React
     promises requires wrapping react promises with RingPHP futures. This
     overhead is no longer needed, reducing stack sizes, reducing complexity,
     and improving performance.
- `GuzzleHttp\Mimetypes` has been moved to a function in
  `GuzzleHttp\Psr7\mimetype_from_extension` and
  `GuzzleHttp\Psr7\mimetype_from_filename`.
- `GuzzleHttp\Query` and `GuzzleHttp\QueryParser` have been removed. Query
  strings must now be passed into request objects as strings, or provided to
  the `query` request option when creating requests with clients. The `query`
  option uses PHP's `http_build_query` to convert an array to a string. If you
  need a different serialization technique, you will need to pass the query
  string in as a string. There are a couple helper functions that will make
  working with query strings easier: `GuzzleHttp\Psr7\parse_query` and
  `GuzzleHttp\Psr7\build_query`.
- Guzzle no longer has a dependency on RingPHP. Due to the use of a middleware
  system based on PSR-7, using RingPHP and it's middleware system as well adds
  more complexity than the benefits it provides. All HTTP handlers that were
  present in RingPHP have been modified to work directly with PSR-7 messages
  and placed in the `GuzzleHttp\Handler` namespace. This significantly reduces
  complexity in Guzzle, removes a dependency, and improves performance. RingPHP
  will be maintained for Guzzle 5 support, but will no longer be a part of
  Guzzle 6.
- As Guzzle now uses a middleware based systems the event system and RingPHP
  integration has been removed. Note: while the event system has been removed,
  it is possible to add your own type of event system that is powered by the
  middleware system.
  - Removed the `Event` namespace.
  - Removed the `Subscriber` namespace.
  - Removed `Transaction` class
  - Removed `RequestFsm`
  - Removed `RingBridge`
  - `GuzzleHttp\Subscriber\Cookie` is now provided by
    `GuzzleHttp\Middleware::cookies`
  - `GuzzleHttp\Subscriber\HttpError` is now provided by
    `GuzzleHttp\Middleware::httpError`
  - `GuzzleHttp\Subscriber\History` is now provided by
    `GuzzleHttp\Middleware::history`
  - `GuzzleHttp\Subscriber\Mock` is now provided by
    `GuzzleHttp\Handler\MockHandler`
  - `GuzzleHttp\Subscriber\Prepare` is now provided by
    `GuzzleHttp\PrepareBodyMiddleware`
  - `GuzzleHttp\Subscriber\Redirect` is now provided by
    `GuzzleHttp\RedirectMiddleware`
- Guzzle now uses `Psr\Http\Message\UriInterface` (implements in
  `GuzzleHttp\Psr7\Uri`) for URI support. `GuzzleHttp\Url` is now gone.
- Static functions in `GuzzleHttp\Utils` have been moved to namespaced
  functions under the `GuzzleHttp` namespace. This requires either a Composer
  based autoloader or you to include functions.php.
- `GuzzleHttp\ClientInterface::getDefaultOption` has been renamed to
  `GuzzleHttp\ClientInterface::getConfig`.
- `GuzzleHttp\ClientInterface::setDefaultOption` has been removed.
- The `json` and `xml` methods of response objects has been removed. With the
  migration to strictly adhering to PSR-7 as the interface for Guzzle messages,
  adding methods to message interfaces would actually require Guzzle messages
  to extend from PSR-7 messages rather then work with them directly.

## Migrating to middleware

The change to PSR-7 unfortunately required significant refactoring to Guzzle
due to the fact that PSR-7 messages are immutable. Guzzle 5 relied on an event
system from plugins. The event system relied on mutability of HTTP messages and
side effects in order to work. With immutable messages, you have to change your
workflow to become more about either returning a value (e.g., functional
middlewares) or setting a value on an object. Guzzle v6 has chosen the
functional middleware approach.

Instead of using the event system to listen for things like the `before` event,
you now create a stack based middleware function that intercepts a request on
the way in and the promise of the response on the way out. This is a much
simpler and more predictable approach than the event system and works nicely
with PSR-7 middleware. Due to the use of promises, the middleware system is
also asynchronous.

v5:

```php
use GuzzleHttp\Event\BeforeEvent;
$client = new GuzzleHttp\Client();
// Get the emitter and listen to the before event.
$client->getEmitter()->on('before', function (BeforeEvent $e) {
    // Guzzle v5 events relied on mutation
    $e->getRequest()->setHeader('X-Foo', 'Bar');
});
```

v6:

In v6, you can modify the request before it is sent using the `mapRequest`
middleware. The idiomatic way in v6 to modify the request/response lifecycle is
to setup a handler middleware stack up front and inject the handler into a
client.

```php
use GuzzleHttp\Middleware;
// Create a handler stack that has all of the default middlewares attached
$handler = GuzzleHttp\HandlerStack::create();
// Push the handler onto the handler stack
$handler->push(Middleware::mapRequest(function (RequestInterface $request) {
    // Notice that we have to return a request object
    return $request->withHeader('X-Foo', 'Bar');
}));
// Inject the handler into the client
$client = new GuzzleHttp\Client(['handler' => $handler]);
```

## POST Requests

This version added the [`form_params`](http://guzzle.readthedocs.org/en/latest/request-options.html#form_params)
and `multipart` request options. `form_params` is an associative array of
strings or array of strings and is used to serialize an
`application/x-www-form-urlencoded` POST request. The
[`multipart`](http://guzzle.readthedocs.org/en/latest/request-options.html#multipart)
option is now used to send a multipart/form-data POST request.

`GuzzleHttp\Post\PostFile` has been removed. Use the `multipart` option to add
POST files to a multipart/form-data request.

The `body` option no longer accepts an array to send POST requests. Please use
`multipart` or `form_params` instead.

The `base_url` option has been renamed to `base_uri`.

4.x to 5.0
----------

## Rewritten Adapter Layer

Guzzle now uses [RingPHP](http://ringphp.readthedocs.org/en/latest) to send
HTTP requests. The `adapter` option in a `GuzzleHttp\Client` constructor
is still supported, but it has now been renamed to `handler`. Instead of
passing a `GuzzleHttp\Adapter\AdapterInterface`, you must now pass a PHP
`callable` that follows the RingPHP specification.

## Removed Fluent Interfaces

[Fluent interfaces were removed](https://ocramius.github.io/blog/fluent-interfaces-are-evil/)
from the following classes:

- `GuzzleHttp\Collection`
- `GuzzleHttp\Url`
- `GuzzleHttp\Query`
- `GuzzleHttp\Post\PostBody`
- `GuzzleHttp\Cookie\SetCookie`

## Removed functions.php

Removed "functions.php", so that Guzzle is truly PSR-4 compliant. The following
functions can be used as replacements.

- `GuzzleHttp\json_decode` -> `GuzzleHttp\Utils::jsonDecode`
- `GuzzleHttp\get_path` -> `GuzzleHttp\Utils::getPath`
- `GuzzleHttp\Utils::setPath` -> `GuzzleHttp\set_path`
- `GuzzleHttp\Pool::batch` -> `GuzzleHttp\batch`. This function is, however,
  deprecated in favor of using `GuzzleHttp\Pool::batch()`.

The "procedural" global client has been removed with no replacement (e.g.,
`GuzzleHttp\get()`, `GuzzleHttp\post()`, etc.). Use a `GuzzleHttp\Client`
object as a replacement.

## `throwImmediately` has been removed

The concept of "throwImmediately" has been removed from exceptions and error
events. This control mechanism was used to stop a transfer of concurrent
requests from completing. This can now be handled by throwing the exception or
by cancelling a pool of requests or each outstanding future request
individually.

## headers event has been removed

Removed the "headers" event. This event was only useful for changing the
body a response once the headers of the response were known. You can implement
a similar behavior in a number of ways. One example might be to use a
FnStream that has access to the transaction being sent. For example, when the
first byte is written, you could check if the response headers match your
expectations, and if so, change the actual stream body that is being
written to.

## Updates to HTTP Messages

Removed the `asArray` parameter from
`GuzzleHttp\Message\MessageInterface::getHeader`. If you want to get a header
value as an array, then use the newly added `getHeaderAsArray()` method of
`MessageInterface`. This change makes the Guzzle interfaces compatible with
the PSR-7 interfaces.

3.x to 4.0
----------

## Overarching changes:

- Now requires PHP 5.4 or greater.
- No longer requires cURL to send requests.
- Guzzle no longer wraps every exception it throws. Only exceptions that are
  recoverable are now wrapped by Guzzle.
- Various namespaces have been removed or renamed.
- No longer requiring the Symfony EventDispatcher. A custom event dispatcher
  based on the Symfony EventDispatcher is
  now utilized in `GuzzleHttp\Event\EmitterInterface` (resulting in significant
  speed and functionality improvements).

Changes per Guzzle 3.x namespace are described below.

## Batch

The `Guzzle\Batch` namespace has been removed. This is best left to
third-parties to implement on top of Guzzle's core HTTP library.

## Cache

The `Guzzle\Cache` namespace has been removed. (Todo: No suitable replacement
has been implemented yet, but hoping to utilize a PSR cache interface).

## Common

- Removed all of the wrapped exceptions. It's better to use the standard PHP
  library for unrecoverable exceptions.
- `FromConfigInterface` has been removed.
- `Guzzle\Common\Version` has been removed. The VERSION constant can be found
  at `GuzzleHttp\ClientInterface::VERSION`.

### Collection

- `getAll` has been removed. Use `toArray` to convert a collection to an array.
- `inject` has been removed.
- `keySearch` has been removed.
- `getPath` no longer supports wildcard expressions. Use something better like
  JMESPath for this.
- `setPath` now supports appending to an existing array via the `[]` notation.

### Events

Guzzle no longer requires Symfony's EventDispatcher component. Guzzle now uses
`GuzzleHttp\Event\Emitter`.

- `Symfony\Component\EventDispatcher\EventDispatcherInterface` is replaced by
  `GuzzleHttp\Event\EmitterInterface`.
- `Symfony\Component\EventDispatcher\EventDispatcher` is replaced by
  `GuzzleHttp\Event\Emitter`.
- `Symfony\Component\EventDispatcher\Event` is replaced by
  `GuzzleHttp\Event\Event`, and Guzzle now has an EventInterface in
  `GuzzleHttp\Event\EventInterface`.
- `AbstractHasDispatcher` has moved to a trait, `HasEmitterTrait`, and
  `HasDispatcherInterface` has moved to `HasEmitterInterface`. Retrieving the
  event emitter of a request, client, etc. now uses the `getEmitter` method
  rather than the `getDispatcher` method.

#### Emitter

- Use the `once()` method to add a listener that automatically removes itself
  the first time it is invoked.
- Use the `listeners()` method to retrieve a list of event listeners rather than
  the `getListeners()` method.
- Use `emit()` instead of `dispatch()` to emit an event from an emitter.
- Use `attach()` instead of `addSubscriber()` and `detach()` instead of
  `removeSubscriber()`.

```php
$mock = new Mock();
// 3.x
$request->getEventDispatcher()->addSubscriber($mock);
$request->getEventDispatcher()->removeSubscriber($mock);
// 4.x
$request->getEmitter()->attach($mock);
$request->getEmitter()->detach($mock);
```

Use the `on()` method to add a listener rather than the `addListener()` method.

```php
// 3.x
$request->getEventDispatcher()->addListener('foo', function (Event $event) { /* ... */ } );
// 4.x
$request->getEmitter()->on('foo', function (Event $event, $name) { /* ... */ } );
```

## Http

### General changes

- The cacert.pem certificate has been moved to `src/cacert.pem`.
- Added the concept of adapters that are used to transfer requests over the
  wire.
- Simplified the event system.
- Sending requests in parallel is still possible, but batching is no longer a
  concept of the HTTP layer. Instead, you must use the `complete` and `error`
  events to asynchronously manage parallel request transfers.
- `Guzzle\Http\Url` has moved to `GuzzleHttp\Url`.
- `Guzzle\Http\QueryString` has moved to `GuzzleHttp\Query`.
- QueryAggregators have been rewritten so that they are simply callable
  functions.
- `GuzzleHttp\StaticClient` has been removed. Use the functions provided in
  `functions.php` for an easy to use static client instance.
- Exceptions in `GuzzleHttp\Exception` have been updated to all extend from
  `GuzzleHttp\Exception\TransferException`.

### Client

Calling methods like `get()`, `post()`, `head()`, etc. no longer create and
return a request, but rather creates a request, sends the request, and returns
the response.

```php
// 3.0
$request = $client->get('/');
$response = $request->send();

// 4.0
$response = $client->get('/');

// or, to mirror the previous behavior
$request = $client->createRequest('GET', '/');
$response = $client->send($request);
```

`GuzzleHttp\ClientInterface` has changed.

- The `send` method no longer accepts more than one request. Use `sendAll` to
  send multiple requests in parallel.
- `setUserAgent()` has been removed. Use a default request option instead. You
  could, for example, do something like:
  `$client->setConfig('defaults/headers/User-Agent', 'Foo/Bar ' . $client::getDefaultUserAgent())`.
- `setSslVerification()` has been removed. Use default request options instead,
  like `$client->setConfig('defaults/verify', true)`.

`GuzzleHttp\Client` has changed.

- The constructor now accepts only an associative array. You can include a
  `base_url` string or array to use a URI template as the base URL of a client.
  You can also specify a `defaults` key that is an associative array of default
  request options. You can pass an `adapter` to use a custom adapter,
  `batch_adapter` to use a custom adapter for sending requests in parallel, or
  a `message_factory` to change the factory used to create HTTP requests and
  responses.
- The client no longer emits a `client.create_request` event.
- Creating requests with a client no longer automatically utilize a URI
  template. You must pass an array into a creational method (e.g.,
  `createRequest`, `get`, `put`, etc.) in order to expand a URI template.

### Messages

Messages no longer have references to their counterparts (i.e., a request no
longer has a reference to it's response, and a response no loger has a
reference to its request). This association is now managed through a
`GuzzleHttp\Adapter\TransactionInterface` object. You can get references to
these transaction objects using request events that are emitted over the
lifecycle of a request.

#### Requests with a body

- `GuzzleHttp\Message\EntityEnclosingRequest` and
  `GuzzleHttp\Message\EntityEnclosingRequestInterface` have been removed. The
  separation between requests that contain a body and requests that do not
  contain a body has been removed, and now `GuzzleHttp\Message\RequestInterface`
  handles both use cases.
- Any method that previously accepts a `GuzzleHttp\Response` object now accept a
  `GuzzleHttp\Message\ResponseInterface`.
- `GuzzleHttp\Message\RequestFactoryInterface` has been renamed to
  `GuzzleHttp\Message\MessageFactoryInterface`. This interface is used to create
  both requests and responses and is implemented in
  `GuzzleHttp\Message\MessageFactory`.
- POST field and file methods have been removed from the request object. You
  must now use the methods made available to `GuzzleHttp\Post\PostBodyInterface`
  to control the format of a POST body. Requests that are created using a
  standard `GuzzleHttp\Message\MessageFactoryInterface` will automatically use
  a `GuzzleHttp\Post\PostBody` body if the body was passed as an array or if
  the method is POST and no body is provided.

```php
$request = $client->createRequest('POST', '/');
$request->getBody()->setField('foo', 'bar');
$request->getBody()->addFile(new PostFile('file_key', fopen('/path/to/content', 'r')));
```

#### Headers

- `GuzzleHttp\Message\Header` has been removed. Header values are now simply
  represented by an array of values or as a string. Header values are returned
  as a string by default when retrieving a header value from a message. You can
  pass an optional argument of `true` to retrieve a header value as an array
  of strings instead of a single concatenated string.
- `GuzzleHttp\PostFile` and `GuzzleHttp\PostFileInterface` have been moved to
  `GuzzleHttp\Post`. This interface has been simplified and now allows the
  addition of arbitrary headers.
- Custom headers like `GuzzleHttp\Message\Header\Link` have been removed. Most
  of the custom headers are now handled separately in specific
  subscribers/plugins, and `GuzzleHttp\Message\HeaderValues::parseParams()` has
  been updated to properly handle headers that contain parameters (like the
  `Link` header).

#### Responses

- `GuzzleHttp\Message\Response::getInfo()` and
  `GuzzleHttp\Message\Response::setInfo()` have been removed. Use the event
  system to retrieve this type of information.
- `GuzzleHttp\Message\Response::getRawHeaders()` has been removed.
- `GuzzleHttp\Message\Response::getMessage()` has been removed.
- `GuzzleHttp\Message\Response::calculateAge()` and other cache specific
  methods have moved to the CacheSubscriber.
- Header specific helper functions like `getContentMd5()` have been removed.
  Just use `getHeader('Content-MD5')` instead.
- `GuzzleHttp\Message\Response::setRequest()` and
  `GuzzleHttp\Message\Response::getRequest()` have been removed. Use the event
  system to work with request and response objects as a transaction.
- `GuzzleHttp\Message\Response::getRedirectCount()` has been removed. Use the
  Redirect subscriber instead.
- `GuzzleHttp\Message\Response::isSuccessful()` and other related methods have
  been removed. Use `getStatusCode()` instead.

#### Streaming responses

Streaming requests can now be created by a client directly, returning a
`GuzzleHttp\Message\ResponseInterface` object that contains a body stream
referencing an open PHP HTTP stream.

```php
// 3.0
use Guzzle\Stream\PhpStreamRequestFactory;
$request = $client->get('/');
$factory = new PhpStreamRequestFactory();
$stream = $factory->fromRequest($request);
$data = $stream->read(1024);

// 4.0
$response = $client->get('/', ['stream' => true]);
// Read some data off of the stream in the response body
$data = $response->getBody()->read(1024);
```

#### Redirects

The `configureRedirects()` method has been removed in favor of a
`allow_redirects` request option.

```php
// Standard redirects with a default of a max of 5 redirects
$request = $client->createRequest('GET', '/', ['allow_redirects' => true]);

// Strict redirects with a custom number of redirects
$request = $client->createRequest('GET', '/', [
    'allow_redirects' => ['max' => 5, 'strict' => true]
]);
```

#### EntityBody

EntityBody interfaces and classes have been removed or moved to
`GuzzleHttp\Stream`. All classes and interfaces that once required
`GuzzleHttp\EntityBodyInterface` now require
`GuzzleHttp\Stream\StreamInterface`. Creating a new body for a request no
longer uses `GuzzleHttp\EntityBody::factory` but now uses
`GuzzleHttp\Stream\Stream::factory` or even better:
`GuzzleHttp\Stream\create()`.

- `Guzzle\Http\EntityBodyInterface` is now `GuzzleHttp\Stream\StreamInterface`
- `Guzzle\Http\EntityBody` is now `GuzzleHttp\Stream\Stream`
- `Guzzle\Http\CachingEntityBody` is now `GuzzleHttp\Stream\CachingStream`
- `Guzzle\Http\ReadLimitEntityBody` is now `GuzzleHttp\Stream\LimitStream`
- `Guzzle\Http\IoEmittyinEntityBody` has been removed.

#### Request lifecycle events

Requests previously submitted a large number of requests. The number of events
emitted over the lifecycle of a request has been significantly reduced to make
it easier to understand how to extend the behavior of a request. All events
emitted during the lifecycle of a request now emit a custom
`GuzzleHttp\Event\EventInterface` object that contains context providing
methods and a way in which to modify the transaction at that specific point in
time (e.g., intercept the request and set a response on the transaction).

- `request.before_send` has been renamed to `before` and now emits a
  `GuzzleHttp\Event\BeforeEvent`
- `request.complete` has been renamed to `complete` and now emits a
  `GuzzleHttp\Event\CompleteEvent`.
- `request.sent` has been removed. Use `complete`.
- `request.success` has been removed. Use `complete`.
- `error` is now an event that emits a `GuzzleHttp\Event\ErrorEvent`.
- `request.exception` has been removed. Use `error`.
- `request.receive.status_line` has been removed.
- `curl.callback.progress` has been removed. Use a custom `StreamInterface` to
  maintain a status update.
- `curl.callback.write` has been removed. Use a custom `StreamInterface` to
  intercept writes.
- `curl.callback.read` has been removed. Use a custom `StreamInterface` to
  intercept reads.

`headers` is a new event that is emitted after the response headers of a
request have been received before the body of the response is downloaded. This
event emits a `GuzzleHttp\Event\HeadersEvent`.

You can intercept a request and inject a response using the `intercept()` event
of a `GuzzleHttp\Event\BeforeEvent`, `GuzzleHttp\Event\CompleteEvent`, and
`GuzzleHttp\Event\ErrorEvent` event.

See: http://docs.guzzlephp.org/en/latest/events.html

## Inflection

The `Guzzle\Inflection` namespace has been removed. This is not a core concern
of Guzzle.

## Iterator

The `Guzzle\Iterator` namespace has been removed.

- `Guzzle\Iterator\AppendIterator`, `Guzzle\Iterator\ChunkedIterator`, and
  `Guzzle\Iterator\MethodProxyIterator` are nice, but not a core requirement of
  Guzzle itself.
- `Guzzle\Iterator\FilterIterator` is no longer needed because an equivalent
  class is shipped with PHP 5.4.
- `Guzzle\Iterator\MapIterator` is not really needed when using PHP 5.5 because
  it's easier to just wrap an iterator in a generator that maps values.

For a replacement of these iterators, see https://github.com/nikic/iter

## Log

The LogPlugin has moved to https://github.com/guzzle/log-subscriber. The
`Guzzle\Log` namespace has been removed. Guzzle now relies on
`Psr\Log\LoggerInterface` for all logging. The MessageFormatter class has been
moved to `GuzzleHttp\Subscriber\Log\Formatter`.

## Parser

The `Guzzle\Parser` namespace has been removed. This was previously used to
make it possible to plug in custom parsers for cookies, messages, URI
templates, and URLs; however, this level of complexity is not needed in Guzzle
so it has been removed.

- Cookie: Cookie parsing logic has been moved to
  `GuzzleHttp\Cookie\SetCookie::fromString`.
- Message: Message parsing logic for both requests and responses has been moved
  to `GuzzleHttp\Message\MessageFactory::fromMessage`. Message parsing is only
  used in debugging or deserializing messages, so it doesn't make sense for
  Guzzle as a library to add this level of complexity to parsing messages.
- UriTemplate: URI template parsing has been moved to
  `GuzzleHttp\UriTemplate`. The Guzzle library will automatically use the PECL
  URI template library if it is installed.
- Url: URL parsing is now performed in `GuzzleHttp\Url::fromString` (previously
  it was `Guzzle\Http\Url::factory()`). If custom URL parsing is necessary,
  then developers are free to subclass `GuzzleHttp\Url`.

## Plugin

The `Guzzle\Plugin` namespace has been renamed to `GuzzleHttp\Subscriber`.
Several plugins are shipping with the core Guzzle library under this namespace.

- `GuzzleHttp\Subscriber\Cookie`: Replaces the old CookiePlugin. Cookie jar
  code has moved to `GuzzleHttp\Cookie`.
- `GuzzleHttp\Subscriber\History`: Replaces the old HistoryPlugin.
- `GuzzleHttp\Subscriber\HttpError`: Throws errors when a bad HTTP response is
  received.
- `GuzzleHttp\Subscriber\Mock`: Replaces the old MockPlugin.
- `GuzzleHttp\Subscriber\Prepare`: Prepares the body of a request just before
  sending. This subscriber is attached to all requests by default.
- `GuzzleHttp\Subscriber\Redirect`: Replaces the RedirectPlugin.

The following plugins have been removed (third-parties are free to re-implement
these if needed):

- `GuzzleHttp\Plugin\Async` has been removed.
- `GuzzleHttp\Plugin\CurlAuth` has been removed.
- `GuzzleHttp\Plugin\ErrorResponse\ErrorResponsePlugin` has been removed. This
  functionality should instead be implemented with event listeners that occur
  after normal response parsing occurs in the guzzle/command package.

The following plugins are not part of the core Guzzle package, but are provided
in separate repositories:

- `Guzzle\Http\Plugin\BackoffPlugin` has been rewritten to be much simpler
  to build custom retry policies using simple functions rather than various
  chained classes. See: https://github.com/guzzle/retry-subscriber
- `Guzzle\Http\Plugin\Cache\CachePlugin` has moved to
  https://github.com/guzzle/cache-subscriber
- `Guzzle\Http\Plugin\Log\LogPlugin` has moved to
  https://github.com/guzzle/log-subscriber
- `Guzzle\Http\Plugin\Md5\Md5Plugin` has moved to
  https://github.com/guzzle/message-integrity-subscriber
- `Guzzle\Http\Plugin\Mock\MockPlugin` has moved to
  `GuzzleHttp\Subscriber\MockSubscriber`.
- `Guzzle\Http\Plugin\Oauth\OauthPlugin` has moved to
  https://github.com/guzzle/oauth-subscriber

## Service

The service description layer of Guzzle has moved into two separate packages:

- http://github.com/guzzle/command Provides a high level abstraction over web
  services by representing web service operations using commands.
- http://github.com/guzzle/guzzle-services Provides an implementation of
  guzzle/command that provides request serialization and response parsing using
  Guzzle service descriptions.

## Stream

Stream have moved to a separate package available at
https://github.com/guzzle/streams.

`Guzzle\Stream\StreamInterface` has been given a large update to cleanly take
on the responsibilities of `Guzzle\Http\EntityBody` and
`Guzzle\Http\EntityBodyInterface` now that they have been removed. The number
of methods implemented by the `StreamInterface` has been drastically reduced to
allow developers to more easily extend and decorate stream behavior.

## Removed methods from StreamInterface

- `getStream` and `setStream` have been removed to better encapsulate streams.
- `getMetadata` and `setMetadata` have been removed in favor of
  `GuzzleHttp\Stream\MetadataStreamInterface`.
- `getWrapper`, `getWrapperData`, `getStreamType`, and `getUri` have all been
  removed. This data is accessible when
  using streams that implement `GuzzleHttp\Stream\MetadataStreamInterface`.
- `rewind` has been removed. Use `seek(0)` for a similar behavior.

## Renamed methods

- `detachStream` has been renamed to `detach`.
- `feof` has been renamed to `eof`.
- `ftell` has been renamed to `tell`.
- `readLine` has moved from an instance method to a static class method of
  `GuzzleHttp\Stream\Stream`.

## Metadata streams

`GuzzleHttp\Stream\MetadataStreamInterface` has been added to denote streams
that contain additional metadata accessible via `getMetadata()`.
`GuzzleHttp\Stream\StreamInterface::getMetadata` and
`GuzzleHttp\Stream\StreamInterface::setMetadata` have been removed.

## StreamRequestFactory

The entire concept of the StreamRequestFactory has been removed. The way this
was used in Guzzle 3 broke the actual interface of sending streaming requests
(instead of getting back a Response, you got a StreamInterface). Streaming
PHP requests are now implemented through the `GuzzleHttp\Adapter\StreamAdapter`.

3.6 to 3.7
----------

### Deprecations

- You can now enable E_USER_DEPRECATED warnings to see if you are using any deprecated methods.:

```php
\Guzzle\Common\Version::$emitWarnings = true;
```

The following APIs and options have been marked as deprecated:

- Marked `Guzzle\Http\Message\Request::isResponseBodyRepeatable()` as deprecated. Use `$request->getResponseBody()->isRepeatable()` instead.
- Marked `Guzzle\Http\Message\Request::canCache()` as deprecated. Use `Guzzle\Plugin\Cache\DefaultCanCacheStrategy->canCacheRequest()` instead.
- Marked `Guzzle\Http\Message\Request::canCache()` as deprecated. Use `Guzzle\Plugin\Cache\DefaultCanCacheStrategy->canCacheRequest()` instead.
- Marked `Guzzle\Http\Message\Request::setIsRedirect()` as deprecated. Use the HistoryPlugin instead.
- Marked `Guzzle\Http\Message\Request::isRedirect()` as deprecated. Use the HistoryPlugin instead.
- Marked `Guzzle\Cache\CacheAdapterFactory::factory()` as deprecated
- Marked `Guzzle\Service\Client::enableMagicMethods()` as deprecated. Magic methods can no longer be disabled on a Guzzle\Service\Client.
- Marked `Guzzle\Parser\Url\UrlParser` as deprecated. Just use PHP's `parse_url()` and percent encode your UTF-8.
- Marked `Guzzle\Common\Collection::inject()` as deprecated.
- Marked `Guzzle\Plugin\CurlAuth\CurlAuthPlugin` as deprecated. Use
  `$client->getConfig()->setPath('request.options/auth', array('user', 'pass', 'Basic|Digest|NTLM|Any'));` or
  `$client->setDefaultOption('auth', array('user', 'pass', 'Basic|Digest|NTLM|Any'));`

3.7 introduces `request.options` as a parameter for a client configuration and as an optional argument to all creational
request methods. When paired with a client's configuration settings, these options allow you to specify default settings
for various aspects of a request. Because these options make other previous configuration options redundant, several
configuration options and methods of a client and AbstractCommand have been deprecated.

- Marked `Guzzle\Service\Client::getDefaultHeaders()` as deprecated. Use `$client->getDefaultOption('headers')`.
- Marked `Guzzle\Service\Client::setDefaultHeaders()` as deprecated. Use `$client->setDefaultOption('headers/{header_name}', 'value')`.
- Marked 'request.params' for `Guzzle\Http\Client` as deprecated. Use `$client->setDefaultOption('params/{param_name}', 'value')`
- Marked 'command.headers', 'command.response_body' and 'command.on_complete' as deprecated for AbstractCommand. These will work through Guzzle 4.0

        $command = $client->getCommand('foo', array(
            'command.headers' => array('Test' => '123'),
            'command.response_body' => '/path/to/file'
        ));

        // Should be changed to:

        $command = $client->getCommand('foo', array(
            'command.request_options' => array(
                'headers' => array('Test' => '123'),
                'save_as' => '/path/to/file'
            )
        ));

### Interface changes

Additions and changes (you will need to update any implementations or subclasses you may have created):

- Added an `$options` argument to the end of the following methods of `Guzzle\Http\ClientInterface`:
  createRequest, head, delete, put, patch, post, options, prepareRequest
- Added an `$options` argument to the end of `Guzzle\Http\Message\Request\RequestFactoryInterface::createRequest()`
- Added an `applyOptions()` method to `Guzzle\Http\Message\Request\RequestFactoryInterface`
- Changed `Guzzle\Http\ClientInterface::get($uri = null, $headers = null, $body = null)` to
  `Guzzle\Http\ClientInterface::get($uri = null, $headers = null, $options = array())`. You can still pass in a
  resource, string, or EntityBody into the $options parameter to specify the download location of the response.
- Changed `Guzzle\Common\Collection::__construct($data)` to no longer accepts a null value for `$data` but a
  default `array()`
- Added `Guzzle\Stream\StreamInterface::isRepeatable`
- Made `Guzzle\Http\Client::expandTemplate` and `getUriTemplate` protected methods.

The following methods were removed from interfaces. All of these methods are still available in the concrete classes
that implement them, but you should update your code to use alternative methods:

- Removed `Guzzle\Http\ClientInterface::setDefaultHeaders(). Use
  `$client->getConfig()->setPath('request.options/headers/{header_name}', 'value')`. or
  `$client->getConfig()->setPath('request.options/headers', array('header_name' => 'value'))` or
  `$client->setDefaultOption('headers/{header_name}', 'value')`. or
  `$client->setDefaultOption('headers', array('header_name' => 'value'))`.
- Removed `Guzzle\Http\ClientInterface::getDefaultHeaders(). Use `$client->getConfig()->getPath('request.options/headers')`.
- Removed `Guzzle\Http\ClientInterface::expandTemplate()`. This is an implementation detail.
- Removed `Guzzle\Http\ClientInterface::setRequestFactory()`. This is an implementation detail.
- Removed `Guzzle\Http\ClientInterface::getCurlMulti()`. This is a very specific implementation detail.
- Removed `Guzzle\Http\Message\RequestInterface::canCache`. Use the CachePlugin.
- Removed `Guzzle\Http\Message\RequestInterface::setIsRedirect`. Use the HistoryPlugin.
- Removed `Guzzle\Http\Message\RequestInterface::isRedirect`. Use the HistoryPlugin.

### Cache plugin breaking changes

- CacheKeyProviderInterface and DefaultCacheKeyProvider are no longer used. All of this logic is handled in a
  CacheStorageInterface. These two objects and interface will be removed in a future version.
- Always setting X-cache headers on cached responses
- Default cache TTLs are now handled by the CacheStorageInterface of a CachePlugin
- `CacheStorageInterface::cache($key, Response $response, $ttl = null)` has changed to `cache(RequestInterface
  $request, Response $response);`
- `CacheStorageInterface::fetch($key)` has changed to `fetch(RequestInterface $request);`
- `CacheStorageInterface::delete($key)` has changed to `delete(RequestInterface $request);`
- Added `CacheStorageInterface::purge($url)`
- `DefaultRevalidation::__construct(CacheKeyProviderInterface $cacheKey, CacheStorageInterface $cache, CachePlugin
  $plugin)` has changed to `DefaultRevalidation::__construct(CacheStorageInterface $cache,
  CanCacheStrategyInterface $canCache = null)`
- Added `RevalidationInterface::shouldRevalidate(RequestInterface $request, Response $response)`

3.5 to 3.6
----------

* Mixed casing of headers are now forced to be a single consistent casing across all values for that header.
* Messages internally use a HeaderCollection object to delegate handling case-insensitive header resolution
* Removed the whole changedHeader() function system of messages because all header changes now go through addHeader().
  For example, setHeader() first removes the header using unset on a HeaderCollection and then calls addHeader().
  Keeping the Host header and URL host in sync is now handled by overriding the addHeader method in Request.
* Specific header implementations can be created for complex headers. When a message creates a header, it uses a
  HeaderFactory which can map specific headers to specific header classes. There is now a Link header and
  CacheControl header implementation.
* Moved getLinks() from Response to just be used on a Link header object.

If you previously relied on Guzzle\Http\Message\Header::raw(), then you will need to update your code to use the
HeaderInterface (e.g. toArray(), getAll(), etc.).

### Interface changes

* Removed from interface: Guzzle\Http\ClientInterface::setUriTemplate
* Removed from interface: Guzzle\Http\ClientInterface::setCurlMulti()
* Removed Guzzle\Http\Message\Request::receivedRequestHeader() and implemented this functionality in
  Guzzle\Http\Curl\RequestMediator
* Removed the optional $asString parameter from MessageInterface::getHeader(). Just cast the header to a string.
* Removed the optional $tryChunkedTransfer option from Guzzle\Http\Message\EntityEnclosingRequestInterface
* Removed the $asObjects argument from Guzzle\Http\Message\MessageInterface::getHeaders()

### Removed deprecated functions

* Removed Guzzle\Parser\ParserRegister::get(). Use getParser()
* Removed Guzzle\Parser\ParserRegister::set(). Use registerParser().

### Deprecations

* The ability to case-insensitively search for header values
* Guzzle\Http\Message\Header::hasExactHeader
* Guzzle\Http\Message\Header::raw. Use getAll()
* Deprecated cache control specific methods on Guzzle\Http\Message\AbstractMessage. Use the CacheControl header object
  instead.

### Other changes

* All response header helper functions return a string rather than mixing Header objects and strings inconsistently
* Removed cURL blacklist support. This is no longer necessary now that Expect, Accept, etc. are managed by Guzzle
  directly via interfaces
* Removed the injecting of a request object onto a response object. The methods to get and set a request still exist
  but are a no-op until removed.
* Most classes that used to require a `Guzzle\Service\Command\CommandInterface` typehint now request a
  `Guzzle\Service\Command\ArrayCommandInterface`.
* Added `Guzzle\Http\Message\RequestInterface::startResponse()` to the RequestInterface to handle injecting a response
  on a request while the request is still being transferred
* `Guzzle\Service\Command\CommandInterface` now extends from ToArrayInterface and ArrayAccess

3.3 to 3.4
----------

Base URLs of a client now follow the rules of https://tools.ietf.org/html/rfc3986#section-5.2.2 when merging URLs.

3.2 to 3.3
----------

### Response::getEtag() quote stripping removed

`Guzzle\Http\Message\Response::getEtag()` no longer strips quotes around the ETag response header

### Removed `Guzzle\Http\Utils`

The `Guzzle\Http\Utils` class was removed. This class was only used for testing.

### Stream wrapper and type

`Guzzle\Stream\Stream::getWrapper()` and `Guzzle\Stream\Stream::getStreamType()` are no longer converted to lowercase.

### curl.emit_io became emit_io

Emitting IO events from a RequestMediator is now a parameter that must be set in a request's curl options using the
'emit_io' key. This was previously set under a request's parameters using 'curl.emit_io'

3.1 to 3.2
----------

### CurlMulti is no longer reused globally

Before 3.2, the same CurlMulti object was reused globally for each client. This can cause issue where plugins added
to a single client can pollute requests dispatched from other clients.

If you still wish to reuse the same CurlMulti object with each client, then you can add a listener to the
ServiceBuilder's `service_builder.create_client` event to inject a custom CurlMulti object into each client as it is
created.

```php
$multi = new Guzzle\Http\Curl\CurlMulti();
$builder = Guzzle\Service\Builder\ServiceBuilder::factory('/path/to/config.json');
$builder->addListener('service_builder.create_client', function ($event) use ($multi) {
    $event['client']->setCurlMulti($multi);
}
});
```

### No default path

URLs no longer have a default path value of '/' if no path was specified.

Before:

```php
$request = $client->get('http://www.foo.com');
echo $request->getUrl();
// >> http://www.foo.com/
```

After:

```php
$request = $client->get('http://www.foo.com');
echo $request->getUrl();
// >> http://www.foo.com
```

### Less verbose BadResponseException

The exception message for `Guzzle\Http\Exception\BadResponseException` no longer contains the full HTTP request and
response information. You can, however, get access to the request and response object by calling `getRequest()` or
`getResponse()` on the exception object.

### Query parameter aggregation

Multi-valued query parameters are no longer aggregated using a callback function. `Guzzle\Http\Query` now has a
setAggregator() method that accepts a `Guzzle\Http\QueryAggregator\QueryAggregatorInterface` object. This object is
responsible for handling the aggregation of multi-valued query string variables into a flattened hash.

2.8 to 3.x
----------

### Guzzle\Service\Inspector

Change `\Guzzle\Service\Inspector::fromConfig` to `\Guzzle\Common\Collection::fromConfig`

**Before**

```php
use Guzzle\Service\Inspector;

class YourClient extends \Guzzle\Service\Client
{
    public static function factory($config = array())
    {
        $default = array();
        $required = array('base_url', 'username', 'api_key');
        $config = Inspector::fromConfig($config, $default, $required);

        $client = new self(
            $config->get('base_url'),
            $config->get('username'),
            $config->get('api_key')
        );
        $client->setConfig($config);

        $client->setDescription(ServiceDescription::factory(__DIR__ . DIRECTORY_SEPARATOR . 'client.json'));

        return $client;
    }
```

**After**

```php
use Guzzle\Common\Collection;

class YourClient extends \Guzzle\Service\Client
{
    public static function factory($config = array())
    {
        $default = array();
        $required = array('base_url', 'username', 'api_key');
        $config = Collection::fromConfig($config, $default, $required);

        $client = new self(
            $config->get('base_url'),
            $config->get('username'),
            $config->get('api_key')
        );
        $client->setConfig($config);

        $client->setDescription(ServiceDescription::factory(__DIR__ . DIRECTORY_SEPARATOR . 'client.json'));

        return $client;
    }
```

### Convert XML Service Descriptions to JSON

**Before**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<client>
    <commands>
        <!-- Groups -->
        <command name="list_groups" method="GET" uri="groups.json">
            <doc>Get a list of groups</doc>
        </command>
        <command name="search_groups" method="GET" uri='search.json?query="{{query}} type:group"'>
            <doc>Uses a search query to get a list of groups</doc>
            <param name="query" type="string" required="true" />
        </command>
        <command name="create_group" method="POST" uri="groups.json">
            <doc>Create a group</doc>
            <param name="data" type="array" location="body" filters="json_encode" doc="Group JSON"/>
            <param name="Content-Type" location="header" static="application/json"/>
        </command>
        <command name="delete_group" method="DELETE" uri="groups/{{id}}.json">
            <doc>Delete a group by ID</doc>
            <param name="id" type="integer" required="true"/>
        </command>
        <command name="get_group" method="GET" uri="groups/{{id}}.json">
            <param name="id" type="integer" required="true"/>
        </command>
        <command name="update_group" method="PUT" uri="groups/{{id}}.json">
            <doc>Update a group</doc>
            <param name="id" type="integer" required="true"/>
            <param name="data" type="array" location="body" filters="json_encode" doc="Group JSON"/>
            <param name="Content-Type" location="header" static="application/json"/>
        </command>
    </commands>
</client>
```

**After**

```json
{
    "name":       "Zendesk REST API v2",
    "apiVersion": "2012-12-31",
    "description":"Provides access to Zendesk views, groups, tickets, ticket fields, and users",
    "operations": {
        "list_groups":  {
            "httpMethod":"GET",
            "uri":       "groups.json",
            "summary":   "Get a list of groups"
        },
        "search_groups":{
            "httpMethod":"GET",
            "uri":       "search.json?query=\"{query} type:group\"",
            "summary":   "Uses a search query to get a list of groups",
            "parameters":{
                "query":{
                    "location":   "uri",
                    "description":"Zendesk Search Query",
                    "type":       "string",
                    "required":   true
                }
            }
        },
        "create_group": {
            "httpMethod":"POST",
            "uri":       "groups.json",
            "summary":   "Create a group",
            "parameters":{
                "data":        {
                    "type":       "array",
                    "location":   "body",
                    "description":"Group JSON",
                    "filters":    "json_encode",
                    "required":   true
                },
                "Content-Type":{
                    "type":    "string",
                    "location":"header",
                    "static":  "application/json"
                }
            }
        },
        "delete_group": {
            "httpMethod":"DELETE",
            "uri":       "groups/{id}.json",
            "summary":   "Delete a group",
            "parameters":{
                "id":{
                    "location":   "uri",
                    "description":"Group to delete by ID",
                    "type":       "integer",
                    "required":   true
                }
            }
        },
        "get_group":    {
            "httpMethod":"GET",
            "uri":       "groups/{id}.json",
            "summary":   "Get a ticket",
            "parameters":{
                "id":{
                    "location":   "uri",
                    "description":"Group to get by ID",
                    "type":       "integer",
                    "required":   true
                }
            }
        },
        "update_group": {
            "httpMethod":"PUT",
            "uri":       "groups/{id}.json",
            "summary":   "Update a group",
            "parameters":{
                "id":          {
                    "location":   "uri",
                    "description":"Group to update by ID",
                    "type":       "integer",
                    "required":   true
                },
                "data":        {
                    "type":       "array",
                    "location":   "body",
                    "description":"Group JSON",
                    "filters":    "json_encode",
                    "required":   true
                },
                "Content-Type":{
                    "type":    "string",
                    "location":"header",
                    "static":  "application/json"
                }
            }
        }
}
```

### Guzzle\Service\Description\ServiceDescription

Commands are now called Operations

**Before**

```php
use Guzzle\Service\Description\ServiceDescription;

$sd = new ServiceDescription();
$sd->getCommands();     // @returns ApiCommandInterface[]
$sd->hasCommand($name);
$sd->getCommand($name); // @returns ApiCommandInterface|null
$sd->addCommand($command); // @param ApiCommandInterface $command
```

**After**

```php
use Guzzle\Service\Description\ServiceDescription;

$sd = new ServiceDescription();
$sd->getOperations();           // @returns OperationInterface[]
$sd->hasOperation($name);
$sd->getOperation($name);       // @returns OperationInterface|null
$sd->addOperation($operation);  // @param OperationInterface $operation
```

### Guzzle\Common\Inflection\Inflector

Namespace is now `Guzzle\Inflection\Inflector`

### Guzzle\Http\Plugin

Namespace is now `Guzzle\Plugin`. Many other changes occur within this namespace and are detailed in their own sections below.

### Guzzle\Http\Plugin\LogPlugin and Guzzle\Common\Log

Now `Guzzle\Plugin\Log\LogPlugin` and `Guzzle\Log` respectively.

**Before**

```php
use Guzzle\Common\Log\ClosureLogAdapter;
use Guzzle\Http\Plugin\LogPlugin;

/** @var \Guzzle\Http\Client */
$client;

// $verbosity is an integer indicating desired message verbosity level
$client->addSubscriber(new LogPlugin(new ClosureLogAdapter(function($m) { echo $m; }, $verbosity = LogPlugin::LOG_VERBOSE);
```

**After**

```php
use Guzzle\Log\ClosureLogAdapter;
use Guzzle\Log\MessageFormatter;
use Guzzle\Plugin\Log\LogPlugin;

/** @var \Guzzle\Http\Client */
$client;

// $format is a string indicating desired message format -- @see MessageFormatter
$client->addSubscriber(new LogPlugin(new ClosureLogAdapter(function($m) { echo $m; }, $format = MessageFormatter::DEBUG_FORMAT);
```

### Guzzle\Http\Plugin\CurlAuthPlugin

Now `Guzzle\Plugin\CurlAuth\CurlAuthPlugin`.

### Guzzle\Http\Plugin\ExponentialBackoffPlugin

Now `Guzzle\Plugin\Backoff\BackoffPlugin`, and other changes.

**Before**

```php
use Guzzle\Http\Plugin\ExponentialBackoffPlugin;

$backoffPlugin = new ExponentialBackoffPlugin($maxRetries, array_merge(
        ExponentialBackoffPlugin::getDefaultFailureCodes(), array(429)
    ));

$client->addSubscriber($backoffPlugin);
```

**After**

```php
use Guzzle\Plugin\Backoff\BackoffPlugin;
use Guzzle\Plugin\Backoff\HttpBackoffStrategy;

// Use convenient factory method instead -- see implementation for ideas of what
// you can do with chaining backoff strategies
$backoffPlugin = BackoffPlugin::getExponentialBackoff($maxRetries, array_merge(
        HttpBackoffStrategy::getDefaultFailureCodes(), array(429)
    ));
$client->addSubscriber($backoffPlugin);
```

### Known Issues

#### [BUG] Accept-Encoding header behavior changed unintentionally.

(See #217) (Fixed in 09daeb8c666fb44499a0646d655a8ae36456575e)

In version 2.8 setting the `Accept-Encoding` header would set the CURLOPT_ENCODING option, which permitted cURL to
properly handle gzip/deflate compressed responses from the server. In versions affected by this bug this does not happen.
See issue #217 for a workaround, or use a version containing the fix.


Carpeta: onzauth/vendor/guzzlehttp/promises/

Archivo: onzauth/vendor/guzzlehttp/promises/CHANGELOG.md
Tipo de archivo: text/markdown

Contenido:
# CHANGELOG

## 1.5.2 - 2022-08-07

### Changed

- Officially support PHP 8.2

## 1.5.1 - 2021-10-22

### Fixed

- Revert "Call handler when waiting on fulfilled/rejected Promise"
- Fix pool memory leak when empty array of promises provided

## 1.5.0 - 2021-10-07

### Changed

- Call handler when waiting on fulfilled/rejected Promise
- Officially support PHP 8.1

### Fixed

- Fix manually settle promises generated with `Utils::task`

## 1.4.1 - 2021-02-18

### Fixed

- Fixed `each_limit` skipping promises and failing

## 1.4.0 - 2020-09-30

### Added

- Support for PHP 8
- Optional `$recursive` flag to `all`
- Replaced functions by static methods

### Fixed

- Fix empty `each` processing
- Fix promise handling for Iterators of non-unique keys
- Fixed `method_exists` crashes on PHP 8
- Memory leak on exceptions


## 1.3.1 - 2016-12-20

### Fixed

- `wait()` foreign promise compatibility


## 1.3.0 - 2016-11-18

### Added

- Adds support for custom task queues.

### Fixed

- Fixed coroutine promise memory leak.


## 1.2.0 - 2016-05-18

### Changed

- Update to now catch `\Throwable` on PHP 7+


## 1.1.0 - 2016-03-07

### Changed

- Update EachPromise to prevent recurring on a iterator when advancing, as this
  could trigger fatal generator errors.
- Update Promise to allow recursive waiting without unwrapping exceptions.


## 1.0.3 - 2015-10-15

### Changed

- Update EachPromise to immediately resolve when the underlying promise iterator
  is empty. Previously, such a promise would throw an exception when its `wait`
  function was called.


## 1.0.2 - 2015-05-15

### Changed

- Conditionally require functions.php.


## 1.0.1 - 2015-06-24

### Changed

- Updating EachPromise to call next on the underlying promise iterator as late
  as possible to ensure that generators that generate new requests based on
  callbacks are not iterated until after callbacks are invoked.


## 1.0.0 - 2015-05-12

- Initial release


Archivo: onzauth/vendor/guzzlehttp/promises/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/README.md
Tipo de archivo: text/markdown

Contenido:
# Guzzle Promises

[Promises/A+](https://promisesaplus.com/) implementation that handles promise
chaining and resolution iteratively, allowing for "infinite" promise chaining
while keeping the stack size constant. Read [this blog post](https://blog.domenic.me/youre-missing-the-point-of-promises/)
for a general introduction to promises.

- [Features](#features)
- [Quick start](#quick-start)
- [Synchronous wait](#synchronous-wait)
- [Cancellation](#cancellation)
- [API](#api)
  - [Promise](#promise)
  - [FulfilledPromise](#fulfilledpromise)
  - [RejectedPromise](#rejectedpromise)
- [Promise interop](#promise-interop)
- [Implementation notes](#implementation-notes)


## Features

- [Promises/A+](https://promisesaplus.com/) implementation.
- Promise resolution and chaining is handled iteratively, allowing for
  "infinite" promise chaining.
- Promises have a synchronous `wait` method.
- Promises can be cancelled.
- Works with any object that has a `then` function.
- C# style async/await coroutine promises using
  `GuzzleHttp\Promise\Coroutine::of()`.


## Quick Start

A *promise* represents the eventual result of an asynchronous operation. The
primary way of interacting with a promise is through its `then` method, which
registers callbacks to receive either a promise's eventual value or the reason
why the promise cannot be fulfilled.

### Callbacks

Callbacks are registered with the `then` method by providing an optional 
`$onFulfilled` followed by an optional `$onRejected` function.


```php
use GuzzleHttp\Promise\Promise;

$promise = new Promise();
$promise->then(
    // $onFulfilled
    function ($value) {
        echo 'The promise was fulfilled.';
    },
    // $onRejected
    function ($reason) {
        echo 'The promise was rejected.';
    }
);
```

*Resolving* a promise means that you either fulfill a promise with a *value* or
reject a promise with a *reason*. Resolving a promise triggers callbacks
registered with the promise's `then` method. These callbacks are triggered
only once and in the order in which they were added.

### Resolving a Promise

Promises are fulfilled using the `resolve($value)` method. Resolving a promise
with any value other than a `GuzzleHttp\Promise\RejectedPromise` will trigger
all of the onFulfilled callbacks (resolving a promise with a rejected promise
will reject the promise and trigger the `$onRejected` callbacks).

```php
use GuzzleHttp\Promise\Promise;

$promise = new Promise();
$promise
    ->then(function ($value) {
        // Return a value and don't break the chain
        return "Hello, " . $value;
    })
    // This then is executed after the first then and receives the value
    // returned from the first then.
    ->then(function ($value) {
        echo $value;
    });

// Resolving the promise triggers the $onFulfilled callbacks and outputs
// "Hello, reader."
$promise->resolve('reader.');
```

### Promise Forwarding

Promises can be chained one after the other. Each then in the chain is a new
promise. The return value of a promise is what's forwarded to the next
promise in the chain. Returning a promise in a `then` callback will cause the
subsequent promises in the chain to only be fulfilled when the returned promise
has been fulfilled. The next promise in the chain will be invoked with the
resolved value of the promise.

```php
use GuzzleHttp\Promise\Promise;

$promise = new Promise();
$nextPromise = new Promise();

$promise
    ->then(function ($value) use ($nextPromise) {
        echo $value;
        return $nextPromise;
    })
    ->then(function ($value) {
        echo $value;
    });

// Triggers the first callback and outputs "A"
$promise->resolve('A');
// Triggers the second callback and outputs "B"
$nextPromise->resolve('B');
```

### Promise Rejection

When a promise is rejected, the `$onRejected` callbacks are invoked with the
rejection reason.

```php
use GuzzleHttp\Promise\Promise;

$promise = new Promise();
$promise->then(null, function ($reason) {
    echo $reason;
});

$promise->reject('Error!');
// Outputs "Error!"
```

### Rejection Forwarding

If an exception is thrown in an `$onRejected` callback, subsequent
`$onRejected` callbacks are invoked with the thrown exception as the reason.

```php
use GuzzleHttp\Promise\Promise;

$promise = new Promise();
$promise->then(null, function ($reason) {
    throw new Exception($reason);
})->then(null, function ($reason) {
    assert($reason->getMessage() === 'Error!');
});

$promise->reject('Error!');
```

You can also forward a rejection down the promise chain by returning a
`GuzzleHttp\Promise\RejectedPromise` in either an `$onFulfilled` or
`$onRejected` callback.

```php
use GuzzleHttp\Promise\Promise;
use GuzzleHttp\Promise\RejectedPromise;

$promise = new Promise();
$promise->then(null, function ($reason) {
    return new RejectedPromise($reason);
})->then(null, function ($reason) {
    assert($reason === 'Error!');
});

$promise->reject('Error!');
```

If an exception is not thrown in a `$onRejected` callback and the callback
does not return a rejected promise, downstream `$onFulfilled` callbacks are
invoked using the value returned from the `$onRejected` callback.

```php
use GuzzleHttp\Promise\Promise;

$promise = new Promise();
$promise
    ->then(null, function ($reason) {
        return "It's ok";
    })
    ->then(function ($value) {
        assert($value === "It's ok");
    });

$promise->reject('Error!');
```


## Synchronous Wait

You can synchronously force promises to complete using a promise's `wait`
method. When creating a promise, you can provide a wait function that is used
to synchronously force a promise to complete. When a wait function is invoked
it is expected to deliver a value to the promise or reject the promise. If the
wait function does not deliver a value, then an exception is thrown. The wait
function provided to a promise constructor is invoked when the `wait` function
of the promise is called.

```php
$promise = new Promise(function () use (&$promise) {
    $promise->resolve('foo');
});

// Calling wait will return the value of the promise.
echo $promise->wait(); // outputs "foo"
```

If an exception is encountered while invoking the wait function of a promise,
the promise is rejected with the exception and the exception is thrown.

```php
$promise = new Promise(function () use (&$promise) {
    throw new Exception('foo');
});

$promise->wait(); // throws the exception.
```

Calling `wait` on a promise that has been fulfilled will not trigger the wait
function. It will simply return the previously resolved value.

```php
$promise = new Promise(function () { die('this is not called!'); });
$promise->resolve('foo');
echo $promise->wait(); // outputs "foo"
```

Calling `wait` on a promise that has been rejected will throw an exception. If
the rejection reason is an instance of `\Exception` the reason is thrown.
Otherwise, a `GuzzleHttp\Promise\RejectionException` is thrown and the reason
can be obtained by calling the `getReason` method of the exception.

```php
$promise = new Promise();
$promise->reject('foo');
$promise->wait();
```

> PHP Fatal error:  Uncaught exception 'GuzzleHttp\Promise\RejectionException' with message 'The promise was rejected with value: foo'

### Unwrapping a Promise

When synchronously waiting on a promise, you are joining the state of the
promise into the current state of execution (i.e., return the value of the
promise if it was fulfilled or throw an exception if it was rejected). This is
called "unwrapping" the promise. Waiting on a promise will by default unwrap
the promise state.

You can force a promise to resolve and *not* unwrap the state of the promise
by passing `false` to the first argument of the `wait` function:

```php
$promise = new Promise();
$promise->reject('foo');
// This will not throw an exception. It simply ensures the promise has
// been resolved.
$promise->wait(false);
```

When unwrapping a promise, the resolved value of the promise will be waited
upon until the unwrapped value is not a promise. This means that if you resolve
promise A with a promise B and unwrap promise A, the value returned by the
wait function will be the value delivered to promise B.

**Note**: when you do not unwrap the promise, no value is returned.


## Cancellation

You can cancel a promise that has not yet been fulfilled using the `cancel()`
method of a promise. When creating a promise you can provide an optional
cancel function that when invoked cancels the action of computing a resolution
of the promise.


## API

### Promise

When creating a promise object, you can provide an optional `$waitFn` and
`$cancelFn`. `$waitFn` is a function that is invoked with no arguments and is
expected to resolve the promise. `$cancelFn` is a function with no arguments
that is expected to cancel the computation of a promise. It is invoked when the
`cancel()` method of a promise is called.

```php
use GuzzleHttp\Promise\Promise;

$promise = new Promise(
    function () use (&$promise) {
        $promise->resolve('waited');
    },
    function () {
        // do something that will cancel the promise computation (e.g., close
        // a socket, cancel a database query, etc...)
    }
);

assert('waited' === $promise->wait());
```

A promise has the following methods:

- `then(callable $onFulfilled, callable $onRejected) : PromiseInterface`
  
  Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler.

- `otherwise(callable $onRejected) : PromiseInterface`
  
  Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.

- `wait($unwrap = true) : mixed`

  Synchronously waits on the promise to complete.
  
  `$unwrap` controls whether or not the value of the promise is returned for a
  fulfilled promise or if an exception is thrown if the promise is rejected.
  This is set to `true` by default.

- `cancel()`

  Attempts to cancel the promise if possible. The promise being cancelled and
  the parent most ancestor that has not yet been resolved will also be
  cancelled. Any promises waiting on the cancelled promise to resolve will also
  be cancelled.

- `getState() : string`

  Returns the state of the promise. One of `pending`, `fulfilled`, or
  `rejected`.

- `resolve($value)`

  Fulfills the promise with the given `$value`.

- `reject($reason)`

  Rejects the promise with the given `$reason`.


### FulfilledPromise

A fulfilled promise can be created to represent a promise that has been
fulfilled.

```php
use GuzzleHttp\Promise\FulfilledPromise;

$promise = new FulfilledPromise('value');

// Fulfilled callbacks are immediately invoked.
$promise->then(function ($value) {
    echo $value;
});
```


### RejectedPromise

A rejected promise can be created to represent a promise that has been
rejected.

```php
use GuzzleHttp\Promise\RejectedPromise;

$promise = new RejectedPromise('Error');

// Rejected callbacks are immediately invoked.
$promise->then(null, function ($reason) {
    echo $reason;
});
```


## Promise Interoperability

This library works with foreign promises that have a `then` method. This means
you can use Guzzle promises with [React promises](https://github.com/reactphp/promise)
for example. When a foreign promise is returned inside of a then method
callback, promise resolution will occur recursively.

```php
// Create a React promise
$deferred = new React\Promise\Deferred();
$reactPromise = $deferred->promise();

// Create a Guzzle promise that is fulfilled with a React promise.
$guzzlePromise = new GuzzleHttp\Promise\Promise();
$guzzlePromise->then(function ($value) use ($reactPromise) {
    // Do something something with the value...
    // Return the React promise
    return $reactPromise;
});
```

Please note that wait and cancel chaining is no longer possible when forwarding
a foreign promise. You will need to wrap a third-party promise with a Guzzle
promise in order to utilize wait and cancel functions with foreign promises.


### Event Loop Integration

In order to keep the stack size constant, Guzzle promises are resolved
asynchronously using a task queue. When waiting on promises synchronously, the
task queue will be automatically run to ensure that the blocking promise and
any forwarded promises are resolved. When using promises asynchronously in an
event loop, you will need to run the task queue on each tick of the loop. If
you do not run the task queue, then promises will not be resolved.

You can run the task queue using the `run()` method of the global task queue
instance.

```php
// Get the global task queue
$queue = GuzzleHttp\Promise\Utils::queue();
$queue->run();
```

For example, you could use Guzzle promises with React using a periodic timer:

```php
$loop = React\EventLoop\Factory::create();
$loop->addPeriodicTimer(0, [$queue, 'run']);
```

*TODO*: Perhaps adding a `futureTick()` on each tick would be faster?


## Implementation Notes

### Promise Resolution and Chaining is Handled Iteratively

By shuffling pending handlers from one owner to another, promises are
resolved iteratively, allowing for "infinite" then chaining.

```php
<?php
require 'vendor/autoload.php';

use GuzzleHttp\Promise\Promise;

$parent = new Promise();
$p = $parent;

for ($i = 0; $i < 1000; $i++) {
    $p = $p->then(function ($v) {
        // The stack size remains constant (a good thing)
        echo xdebug_get_stack_depth() . ', ';
        return $v + 1;
    });
}

$parent->resolve(0);
var_dump($p->wait()); // int(1000)

```

When a promise is fulfilled or rejected with a non-promise value, the promise
then takes ownership of the handlers of each child promise and delivers values
down the chain without using recursion.

When a promise is resolved with another promise, the original promise transfers
all of its pending handlers to the new promise. When the new promise is
eventually resolved, all of the pending handlers are delivered the forwarded
value.

### A Promise is the Deferred

Some promise libraries implement promises using a deferred object to represent
a computation and a promise object to represent the delivery of the result of
the computation. This is a nice separation of computation and delivery because
consumers of the promise cannot modify the value that will be eventually
delivered.

One side effect of being able to implement promise resolution and chaining
iteratively is that you need to be able for one promise to reach into the state
of another promise to shuffle around ownership of handlers. In order to achieve
this without making the handlers of a promise publicly mutable, a promise is
also the deferred value, allowing promises of the same parent class to reach
into and modify the private properties of promises of the same type. While this
does allow consumers of the value to modify the resolution or rejection of the
deferred, it is a small price to pay for keeping the stack size constant.

```php
$promise = new Promise();
$promise->then(function ($value) { echo $value; });
// The promise is the deferred value, so you can deliver a value to it.
$promise->resolve('foo');
// prints "foo"
```


## Upgrading from Function API

A static API was first introduced in 1.4.0, in order to mitigate problems with
functions conflicting between global and local copies of the package. The
function API will be removed in 2.0.0. A migration table has been provided here
for your convenience:

| Original Function | Replacement Method |
|----------------|----------------|
| `queue` | `Utils::queue` |
| `task` | `Utils::task` |
| `promise_for` | `Create::promiseFor` |
| `rejection_for` | `Create::rejectionFor` |
| `exception_for` | `Create::exceptionFor` |
| `iter_for` | `Create::iterFor` |
| `inspect` | `Utils::inspect` |
| `inspect_all` | `Utils::inspectAll` |
| `unwrap` | `Utils::unwrap` |
| `all` | `Utils::all` |
| `some` | `Utils::some` |
| `any` | `Utils::any` |
| `settle` | `Utils::settle` |
| `each` | `Each::of` |
| `each_limit` | `Each::ofLimit` |
| `each_limit_all` | `Each::ofLimitAll` |
| `!is_fulfilled` | `Is::pending` |
| `is_fulfilled` | `Is::fulfilled` |
| `is_rejected` | `Is::rejected` |
| `is_settled` | `Is::settled` |
| `coroutine` | `Coroutine::of` |


## Security

If you discover a security vulnerability within this package, please send an email to security@tidelift.com. All security vulnerabilities will be promptly addressed. Please do not disclose security-related issues publicly until a fix has been announced. Please see [Security Policy](https://github.com/guzzle/promises/security/policy) for more information.


## License

Guzzle is made available under the MIT License (MIT). Please see [License File](LICENSE) for more information.


## For Enterprise

Available as part of the Tidelift Subscription

The maintainers of Guzzle and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/packagist-guzzlehttp-promises?utm_source=packagist-guzzlehttp-promises&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)


Carpeta: onzauth/vendor/guzzlehttp/promises/src/

Archivo: onzauth/vendor/guzzlehttp/promises/src/AggregateException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/CancellationException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/Coroutine.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/Create.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/Each.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/EachPromise.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/FulfilledPromise.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/functions_include.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/functions.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/Is.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/PromiseInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/Promise.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/PromisorInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/RejectedPromise.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/RejectionException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/TaskQueueInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/TaskQueue.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/promises/src/Utils.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/guzzlehttp/psr7/

Archivo: onzauth/vendor/guzzlehttp/psr7/CHANGELOG.md
Tipo de archivo: text/markdown

Contenido:
# Change Log

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## Unreleased

## 2.4.1 - 2022-08-28

### Fixed

- Rewind body before reading in `Message::bodySummary`

## 2.4.0 - 2022-06-20

### Added

- Added provisional PHP 8.2 support
- Added `UriComparator::isCrossOrigin` method

## 2.3.0 - 2022-06-09

### Fixed

- Added `Header::splitList` method
- Added `Utils::tryGetContents` method
- Improved `Stream::getContents` method
- Updated mimetype mappings

## 2.2.2 - 2022-06-08

### Fixed

- Fix `Message::parseRequestUri` for numeric headers
- Re-wrap exceptions thrown in `fread` into runtime exceptions
- Throw an exception when multipart options is misformatted

## 2.2.1 - 2022-03-20

### Fixed

- Correct header value validation

## 2.2.0 - 2022-03-20

### Added

- A more compressive list of mime types
- Add JsonSerializable to Uri
- Missing return types

### Fixed

- Bug MultipartStream no `uri` metadata
- Bug MultipartStream with filename for `data://` streams
- Fixed new line handling in MultipartStream
- Reduced RAM usage when copying streams
- Updated parsing in `Header::normalize()`

## 2.1.1 - 2022-03-20

### Fixed

- Validate header values properly

## 2.1.0 - 2021-10-06

### Changed

- Attempting to create a `Uri` object from a malformed URI will no longer throw a generic
  `InvalidArgumentException`, but rather a `MalformedUriException`, which inherits from the former
  for backwards compatibility. Callers relying on the exception being thrown to detect invalid
  URIs should catch the new exception.

### Fixed

- Return `null` in caching stream size if remote size is `null`

## 2.0.0 - 2021-06-30

Identical to the RC release.

## 2.0.0@RC-1 - 2021-04-29

### Fixed

- Handle possibly unset `url` in `stream_get_meta_data`

## 2.0.0@beta-1 - 2021-03-21

### Added

- PSR-17 factories
- Made classes final
- PHP7 type hints

### Changed

- When building a query string, booleans are represented as 1 and 0.

### Removed

- PHP < 7.2 support
- All functions in the Guzzle\Psr7 namespace

## 1.8.1 - 2021-03-21

### Fixed

- Issue parsing IPv6 URLs
- Issue modifying ServerRequest lost all its attributes

## 1.8.0 - 2021-03-21

### Added

- Locale independent URL parsing
- Most classes got a `@final` annotation to prepare for 2.0

### Fixed

- Issue when creating stream from `php://input` and curl-ext is not installed
- Broken `Utils::tryFopen()` on PHP 8

## 1.7.0 - 2020-09-30

### Added

- Replaced functions by static methods

### Fixed

- Converting a non-seekable stream to a string
- Handle multiple Set-Cookie correctly
- Ignore array keys in header values when merging
- Allow multibyte characters to be parsed in `Message:bodySummary()`

### Changed

- Restored partial HHVM 3 support


## [1.6.1] - 2019-07-02

### Fixed

- Accept null and bool header values again


## [1.6.0] - 2019-06-30

### Added

- Allowed version `^3.0` of `ralouphie/getallheaders` dependency (#244)
- Added MIME type for WEBP image format (#246)
- Added more validation of values according to PSR-7 and RFC standards, e.g. status code range (#250, #272)

### Changed

- Tests don't pass with HHVM 4.0, so HHVM support got dropped. Other libraries like composer have done the same. (#262)
- Accept port number 0 to be valid (#270)

### Fixed

- Fixed subsequent reads from `php://input` in ServerRequest (#247)
- Fixed readable/writable detection for certain stream modes (#248)
- Fixed encoding of special characters in the `userInfo` component of an URI (#253)


## [1.5.2] - 2018-12-04

### Fixed

- Check body size when getting the message summary


## [1.5.1] - 2018-12-04

### Fixed

- Get the summary of a body only if it is readable


## [1.5.0] - 2018-12-03

### Added

- Response first-line to response string exception (fixes #145)
- A test for #129 behavior
- `get_message_body_summary` function in order to get the message summary
- `3gp` and `mkv` mime types

### Changed

- Clarify exception message when stream is detached

### Deprecated

- Deprecated parsing folded header lines as per RFC 7230

### Fixed

- Fix `AppendStream::detach` to not close streams
- `InflateStream` preserves `isSeekable` attribute of the underlying stream
- `ServerRequest::getUriFromGlobals` to support URLs in query parameters


Several other fixes and improvements.


## [1.4.2] - 2017-03-20

### Fixed

- Reverted BC break to `Uri::resolve` and `Uri::removeDotSegments` by removing
  calls to `trigger_error` when deprecated methods are invoked.


## [1.4.1] - 2017-02-27

### Added

- Rriggering of silenced deprecation warnings.

### Fixed

- Reverted BC break by reintroducing behavior to automagically fix a URI with a
  relative path and an authority by adding a leading slash to the path. It's only
  deprecated now.


## [1.4.0] - 2017-02-21

### Added

- Added common URI utility methods based on RFC 3986 (see documentation in the readme):
  - `Uri::isDefaultPort`
  - `Uri::isAbsolute`
  - `Uri::isNetworkPathReference`
  - `Uri::isAbsolutePathReference`
  - `Uri::isRelativePathReference`
  - `Uri::isSameDocumentReference`
  - `Uri::composeComponents`
  - `UriNormalizer::normalize`
  - `UriNormalizer::isEquivalent`
  - `UriResolver::relativize`

### Changed

- Ensure `ServerRequest::getUriFromGlobals` returns a URI in absolute form.
- Allow `parse_response` to parse a response without delimiting space and reason.
- Ensure each URI modification results in a valid URI according to PSR-7 discussions.
  Invalid modifications will throw an exception instead of returning a wrong URI or
  doing some magic.
  - `(new Uri)->withPath('foo')->withHost('example.com')` will throw an exception
    because the path of a URI with an authority must start with a slash "/" or be empty
  - `(new Uri())->withScheme('http')` will return `'http://localhost'`

### Deprecated

- `Uri::resolve` in favor of `UriResolver::resolve`
- `Uri::removeDotSegments` in favor of `UriResolver::removeDotSegments`

### Fixed

- `Stream::read` when length parameter <= 0.
- `copy_to_stream` reads bytes in chunks instead of `maxLen` into memory.
- `ServerRequest::getUriFromGlobals` when `Host` header contains port.
- Compatibility of URIs with `file` scheme and empty host.


## [1.3.1] - 2016-06-25

### Fixed

- `Uri::__toString` for network path references, e.g. `//example.org`.
- Missing lowercase normalization for host.
- Handling of URI components in case they are `'0'` in a lot of places,
  e.g. as a user info password.
- `Uri::withAddedHeader` to correctly merge headers with different case.
- Trimming of header values in `Uri::withAddedHeader`. Header values may
  be surrounded by whitespace which should be ignored according to RFC 7230
  Section 3.2.4. This does not apply to header names.
- `Uri::withAddedHeader` with an array of header values.
- `Uri::resolve` when base path has no slash and handling of fragment.
- Handling of encoding in `Uri::with(out)QueryValue` so one can pass the
  key/value both in encoded as well as decoded form to those methods. This is
  consistent with withPath, withQuery etc.
- `ServerRequest::withoutAttribute` when attribute value is null.


## [1.3.0] - 2016-04-13

### Added

- Remaining interfaces needed for full PSR7 compatibility
  (ServerRequestInterface, UploadedFileInterface, etc.).
- Support for stream_for from scalars.

### Changed

- Can now extend Uri.

### Fixed
- A bug in validating request methods by making it more permissive.


## [1.2.3] - 2016-02-18

### Fixed

- Support in `GuzzleHttp\Psr7\CachingStream` for seeking forward on remote
  streams, which can sometimes return fewer bytes than requested with `fread`.
- Handling of gzipped responses with FNAME headers.


## [1.2.2] - 2016-01-22

### Added

- Support for URIs without any authority.
- Support for HTTP 451 'Unavailable For Legal Reasons.'
- Support for using '0' as a filename.
- Support for including non-standard ports in Host headers.


## [1.2.1] - 2015-11-02

### Changes

- Now supporting negative offsets when seeking to SEEK_END.


## [1.2.0] - 2015-08-15

### Changed

- Body as `"0"` is now properly added to a response.
- Now allowing forward seeking in CachingStream.
- Now properly parsing HTTP requests that contain proxy targets in
  `parse_request`.
- functions.php is now conditionally required.
- user-info is no longer dropped when resolving URIs.


## [1.1.0] - 2015-06-24

### Changed

- URIs can now be relative.
- `multipart/form-data` headers are now overridden case-insensitively.
- URI paths no longer encode the following characters because they are allowed
  in URIs: "(", ")", "*", "!", "'"
- A port is no longer added to a URI when the scheme is missing and no port is
  present.


## 1.0.0 - 2015-05-19

Initial release.

Currently unsupported:

- `Psr\Http\Message\ServerRequestInterface`
- `Psr\Http\Message\UploadedFileInterface`



[1.6.0]: https://github.com/guzzle/psr7/compare/1.5.2...1.6.0
[1.5.2]: https://github.com/guzzle/psr7/compare/1.5.1...1.5.2
[1.5.1]: https://github.com/guzzle/psr7/compare/1.5.0...1.5.1
[1.5.0]: https://github.com/guzzle/psr7/compare/1.4.2...1.5.0
[1.4.2]: https://github.com/guzzle/psr7/compare/1.4.1...1.4.2
[1.4.1]: https://github.com/guzzle/psr7/compare/1.4.0...1.4.1
[1.4.0]: https://github.com/guzzle/psr7/compare/1.3.1...1.4.0
[1.3.1]: https://github.com/guzzle/psr7/compare/1.3.0...1.3.1
[1.3.0]: https://github.com/guzzle/psr7/compare/1.2.3...1.3.0
[1.2.3]: https://github.com/guzzle/psr7/compare/1.2.2...1.2.3
[1.2.2]: https://github.com/guzzle/psr7/compare/1.2.1...1.2.2
[1.2.1]: https://github.com/guzzle/psr7/compare/1.2.0...1.2.1
[1.2.0]: https://github.com/guzzle/psr7/compare/1.1.0...1.2.0
[1.1.0]: https://github.com/guzzle/psr7/compare/1.0.0...1.1.0


Archivo: onzauth/vendor/guzzlehttp/psr7/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/README.md
Tipo de archivo: text/markdown

Contenido:
# PSR-7 Message Implementation

This repository contains a full [PSR-7](https://www.php-fig.org/psr/psr-7/)
message implementation, several stream decorators, and some helpful
functionality like query string parsing.

![CI](https://github.com/guzzle/psr7/workflows/CI/badge.svg)
![Static analysis](https://github.com/guzzle/psr7/workflows/Static%20analysis/badge.svg)


# Stream implementation

This package comes with a number of stream implementations and stream
decorators.


## AppendStream

`GuzzleHttp\Psr7\AppendStream`

Reads from multiple streams, one after the other.

```php
use GuzzleHttp\Psr7;

$a = Psr7\Utils::streamFor('abc, ');
$b = Psr7\Utils::streamFor('123.');
$composed = new Psr7\AppendStream([$a, $b]);

$composed->addStream(Psr7\Utils::streamFor(' Above all listen to me'));

echo $composed; // abc, 123. Above all listen to me.
```


## BufferStream

`GuzzleHttp\Psr7\BufferStream`

Provides a buffer stream that can be written to fill a buffer, and read
from to remove bytes from the buffer.

This stream returns a "hwm" metadata value that tells upstream consumers
what the configured high water mark of the stream is, or the maximum
preferred size of the buffer.

```php
use GuzzleHttp\Psr7;

// When more than 1024 bytes are in the buffer, it will begin returning
// false to writes. This is an indication that writers should slow down.
$buffer = new Psr7\BufferStream(1024);
```


## CachingStream

The CachingStream is used to allow seeking over previously read bytes on
non-seekable streams. This can be useful when transferring a non-seekable
entity body fails due to needing to rewind the stream (for example, resulting
from a redirect). Data that is read from the remote stream will be buffered in
a PHP temp stream so that previously read bytes are cached first in memory,
then on disk.

```php
use GuzzleHttp\Psr7;

$original = Psr7\Utils::streamFor(fopen('http://www.google.com', 'r'));
$stream = new Psr7\CachingStream($original);

$stream->read(1024);
echo $stream->tell();
// 1024

$stream->seek(0);
echo $stream->tell();
// 0
```


## DroppingStream

`GuzzleHttp\Psr7\DroppingStream`

Stream decorator that begins dropping data once the size of the underlying
stream becomes too full.

```php
use GuzzleHttp\Psr7;

// Create an empty stream
$stream = Psr7\Utils::streamFor();

// Start dropping data when the stream has more than 10 bytes
$dropping = new Psr7\DroppingStream($stream, 10);

$dropping->write('01234567890123456789');
echo $stream; // 0123456789
```


## FnStream

`GuzzleHttp\Psr7\FnStream`

Compose stream implementations based on a hash of functions.

Allows for easy testing and extension of a provided stream without needing
to create a concrete class for a simple extension point.

```php

use GuzzleHttp\Psr7;

$stream = Psr7\Utils::streamFor('hi');
$fnStream = Psr7\FnStream::decorate($stream, [
    'rewind' => function () use ($stream) {
        echo 'About to rewind - ';
        $stream->rewind();
        echo 'rewound!';
    }
]);

$fnStream->rewind();
// Outputs: About to rewind - rewound!
```


## InflateStream

`GuzzleHttp\Psr7\InflateStream`

Uses PHP's zlib.inflate filter to inflate zlib (HTTP deflate, RFC1950) or gzipped (RFC1952) content.

This stream decorator converts the provided stream to a PHP stream resource,
then appends the zlib.inflate filter. The stream is then converted back
to a Guzzle stream resource to be used as a Guzzle stream.


## LazyOpenStream

`GuzzleHttp\Psr7\LazyOpenStream`

Lazily reads or writes to a file that is opened only after an IO operation
take place on the stream.

```php
use GuzzleHttp\Psr7;

$stream = new Psr7\LazyOpenStream('/path/to/file', 'r');
// The file has not yet been opened...

echo $stream->read(10);
// The file is opened and read from only when needed.
```


## LimitStream

`GuzzleHttp\Psr7\LimitStream`

LimitStream can be used to read a subset or slice of an existing stream object.
This can be useful for breaking a large file into smaller pieces to be sent in
chunks (e.g. Amazon S3's multipart upload API).

```php
use GuzzleHttp\Psr7;

$original = Psr7\Utils::streamFor(fopen('/tmp/test.txt', 'r+'));
echo $original->getSize();
// >>> 1048576

// Limit the size of the body to 1024 bytes and start reading from byte 2048
$stream = new Psr7\LimitStream($original, 1024, 2048);
echo $stream->getSize();
// >>> 1024
echo $stream->tell();
// >>> 0
```


## MultipartStream

`GuzzleHttp\Psr7\MultipartStream`

Stream that when read returns bytes for a streaming multipart or
multipart/form-data stream.


## NoSeekStream

`GuzzleHttp\Psr7\NoSeekStream`

NoSeekStream wraps a stream and does not allow seeking.

```php
use GuzzleHttp\Psr7;

$original = Psr7\Utils::streamFor('foo');
$noSeek = new Psr7\NoSeekStream($original);

echo $noSeek->read(3);
// foo
var_export($noSeek->isSeekable());
// false
$noSeek->seek(0);
var_export($noSeek->read(3));
// NULL
```


## PumpStream

`GuzzleHttp\Psr7\PumpStream`

Provides a read only stream that pumps data from a PHP callable.

When invoking the provided callable, the PumpStream will pass the amount of
data requested to read to the callable. The callable can choose to ignore
this value and return fewer or more bytes than requested. Any extra data
returned by the provided callable is buffered internally until drained using
the read() function of the PumpStream. The provided callable MUST return
false when there is no more data to read.


## Implementing stream decorators

Creating a stream decorator is very easy thanks to the
`GuzzleHttp\Psr7\StreamDecoratorTrait`. This trait provides methods that
implement `Psr\Http\Message\StreamInterface` by proxying to an underlying
stream. Just `use` the `StreamDecoratorTrait` and implement your custom
methods.

For example, let's say we wanted to call a specific function each time the last
byte is read from a stream. This could be implemented by overriding the
`read()` method.

```php
use Psr\Http\Message\StreamInterface;
use GuzzleHttp\Psr7\StreamDecoratorTrait;

class EofCallbackStream implements StreamInterface
{
    use StreamDecoratorTrait;

    private $callback;

    public function __construct(StreamInterface $stream, callable $cb)
    {
        $this->stream = $stream;
        $this->callback = $cb;
    }

    public function read($length)
    {
        $result = $this->stream->read($length);

        // Invoke the callback when EOF is hit.
        if ($this->eof()) {
            call_user_func($this->callback);
        }

        return $result;
    }
}
```

This decorator could be added to any existing stream and used like so:

```php
use GuzzleHttp\Psr7;

$original = Psr7\Utils::streamFor('foo');

$eofStream = new EofCallbackStream($original, function () {
    echo 'EOF!';
});

$eofStream->read(2);
$eofStream->read(1);
// echoes "EOF!"
$eofStream->seek(0);
$eofStream->read(3);
// echoes "EOF!"
```


## PHP StreamWrapper

You can use the `GuzzleHttp\Psr7\StreamWrapper` class if you need to use a
PSR-7 stream as a PHP stream resource.

Use the `GuzzleHttp\Psr7\StreamWrapper::getResource()` method to create a PHP
stream from a PSR-7 stream.

```php
use GuzzleHttp\Psr7\StreamWrapper;

$stream = GuzzleHttp\Psr7\Utils::streamFor('hello!');
$resource = StreamWrapper::getResource($stream);
echo fread($resource, 6); // outputs hello!
```


# Static API

There are various static methods available under the `GuzzleHttp\Psr7` namespace.


## `GuzzleHttp\Psr7\Message::toString`

`public static function toString(MessageInterface $message): string`

Returns the string representation of an HTTP message.

```php
$request = new GuzzleHttp\Psr7\Request('GET', 'http://example.com');
echo GuzzleHttp\Psr7\Message::toString($request);
```


## `GuzzleHttp\Psr7\Message::bodySummary`

`public static function bodySummary(MessageInterface $message, int $truncateAt = 120): string|null`

Get a short summary of the message body.

Will return `null` if the response is not printable.


## `GuzzleHttp\Psr7\Message::rewindBody`

`public static function rewindBody(MessageInterface $message): void`

Attempts to rewind a message body and throws an exception on failure.

The body of the message will only be rewound if a call to `tell()`
returns a value other than `0`.


## `GuzzleHttp\Psr7\Message::parseMessage`

`public static function parseMessage(string $message): array`

Parses an HTTP message into an associative array.

The array contains the "start-line" key containing the start line of
the message, "headers" key containing an associative array of header
array values, and a "body" key containing the body of the message.


## `GuzzleHttp\Psr7\Message::parseRequestUri`

`public static function parseRequestUri(string $path, array $headers): string`

Constructs a URI for an HTTP request message.


## `GuzzleHttp\Psr7\Message::parseRequest`

`public static function parseRequest(string $message): Request`

Parses a request message string into a request object.


## `GuzzleHttp\Psr7\Message::parseResponse`

`public static function parseResponse(string $message): Response`

Parses a response message string into a response object.


## `GuzzleHttp\Psr7\Header::parse`

`public static function parse(string|array $header): array`

Parse an array of header values containing ";" separated data into an
array of associative arrays representing the header key value pair data
of the header. When a parameter does not contain a value, but just
contains a key, this function will inject a key with a '' string value.


## `GuzzleHttp\Psr7\Header::normalize`

`public static function normalize(string|array $header): array`

Converts an array of header values that may contain comma separated
headers into an array of headers with no comma separated values.


## `GuzzleHttp\Psr7\Query::parse`

`public static function parse(string $str, int|bool $urlEncoding = true): array`

Parse a query string into an associative array.

If multiple values are found for the same key, the value of that key
value pair will become an array. This function does not parse nested
PHP style arrays into an associative array (e.g., `foo[a]=1&foo[b]=2`
will be parsed into `['foo[a]' => '1', 'foo[b]' => '2'])`.


## `GuzzleHttp\Psr7\Query::build`

`public static function build(array $params, int|false $encoding = PHP_QUERY_RFC3986): string`

Build a query string from an array of key value pairs.

This function can use the return value of `parse()` to build a query
string. This function does not modify the provided keys when an array is
encountered (like `http_build_query()` would).


## `GuzzleHttp\Psr7\Utils::caselessRemove`

`public static function caselessRemove(iterable<string> $keys, $keys, array $data): array`

Remove the items given by the keys, case insensitively from the data.


## `GuzzleHttp\Psr7\Utils::copyToStream`

`public static function copyToStream(StreamInterface $source, StreamInterface $dest, int $maxLen = -1): void`

Copy the contents of a stream into another stream until the given number
of bytes have been read.


## `GuzzleHttp\Psr7\Utils::copyToString`

`public static function copyToString(StreamInterface $stream, int $maxLen = -1): string`

Copy the contents of a stream into a string until the given number of
bytes have been read.


## `GuzzleHttp\Psr7\Utils::hash`

`public static function hash(StreamInterface $stream, string $algo, bool $rawOutput = false): string`

Calculate a hash of a stream.

This method reads the entire stream to calculate a rolling hash, based on
PHP's `hash_init` functions.


## `GuzzleHttp\Psr7\Utils::modifyRequest`

`public static function modifyRequest(RequestInterface $request, array $changes): RequestInterface`

Clone and modify a request with the given changes.

This method is useful for reducing the number of clones needed to mutate
a message.

- method: (string) Changes the HTTP method.
- set_headers: (array) Sets the given headers.
- remove_headers: (array) Remove the given headers.
- body: (mixed) Sets the given body.
- uri: (UriInterface) Set the URI.
- query: (string) Set the query string value of the URI.
- version: (string) Set the protocol version.


## `GuzzleHttp\Psr7\Utils::readLine`

`public static function readLine(StreamInterface $stream, int $maxLength = null): string`

Read a line from the stream up to the maximum allowed buffer length.


## `GuzzleHttp\Psr7\Utils::streamFor`

`public static function streamFor(resource|string|null|int|float|bool|StreamInterface|callable|\Iterator $resource = '', array $options = []): StreamInterface`

Create a new stream based on the input type.

Options is an associative array that can contain the following keys:

- metadata: Array of custom metadata.
- size: Size of the stream.

This method accepts the following `$resource` types:

- `Psr\Http\Message\StreamInterface`: Returns the value as-is.
- `string`: Creates a stream object that uses the given string as the contents.
- `resource`: Creates a stream object that wraps the given PHP stream resource.
- `Iterator`: If the provided value implements `Iterator`, then a read-only
  stream object will be created that wraps the given iterable. Each time the
  stream is read from, data from the iterator will fill a buffer and will be
  continuously called until the buffer is equal to the requested read size.
  Subsequent read calls will first read from the buffer and then call `next`
  on the underlying iterator until it is exhausted.
- `object` with `__toString()`: If the object has the `__toString()` method,
  the object will be cast to a string and then a stream will be returned that
  uses the string value.
- `NULL`: When `null` is passed, an empty stream object is returned.
- `callable` When a callable is passed, a read-only stream object will be
  created that invokes the given callable. The callable is invoked with the
  number of suggested bytes to read. The callable can return any number of
  bytes, but MUST return `false` when there is no more data to return. The
  stream object that wraps the callable will invoke the callable until the
  number of requested bytes are available. Any additional bytes will be
  buffered and used in subsequent reads.

```php
$stream = GuzzleHttp\Psr7\Utils::streamFor('foo');
$stream = GuzzleHttp\Psr7\Utils::streamFor(fopen('/path/to/file', 'r'));

$generator = function ($bytes) {
    for ($i = 0; $i < $bytes; $i++) {
        yield ' ';
    }
}

$stream = GuzzleHttp\Psr7\Utils::streamFor($generator(100));
```


## `GuzzleHttp\Psr7\Utils::tryFopen`

`public static function tryFopen(string $filename, string $mode): resource`

Safely opens a PHP stream resource using a filename.

When fopen fails, PHP normally raises a warning. This function adds an
error handler that checks for errors and throws an exception instead.


## `GuzzleHttp\Psr7\Utils::tryGetContents`

`public static function tryGetContents(resource $stream): string`

Safely gets the contents of a given stream.

When stream_get_contents fails, PHP normally raises a warning. This
function adds an error handler that checks for errors and throws an
exception instead.


## `GuzzleHttp\Psr7\Utils::uriFor`

`public static function uriFor(string|UriInterface $uri): UriInterface`

Returns a UriInterface for the given value.

This function accepts a string or UriInterface and returns a
UriInterface for the given value. If the value is already a
UriInterface, it is returned as-is.


## `GuzzleHttp\Psr7\MimeType::fromFilename`

`public static function fromFilename(string $filename): string|null`

Determines the mimetype of a file by looking at its extension.


## `GuzzleHttp\Psr7\MimeType::fromExtension`

`public static function fromExtension(string $extension): string|null`

Maps a file extensions to a mimetype.


## Upgrading from Function API

The static API was first introduced in 1.7.0, in order to mitigate problems with functions conflicting between global and local copies of the package. The function API was removed in 2.0.0. A migration table has been provided here for your convenience:

| Original Function | Replacement Method |
|----------------|----------------|
| `str` | `Message::toString` |
| `uri_for` | `Utils::uriFor` |
| `stream_for` | `Utils::streamFor` |
| `parse_header` | `Header::parse` |
| `normalize_header` | `Header::normalize` |
| `modify_request` | `Utils::modifyRequest` |
| `rewind_body` | `Message::rewindBody` |
| `try_fopen` | `Utils::tryFopen` |
| `copy_to_string` | `Utils::copyToString` |
| `copy_to_stream` | `Utils::copyToStream` |
| `hash` | `Utils::hash` |
| `readline` | `Utils::readLine` |
| `parse_request` | `Message::parseRequest` |
| `parse_response` | `Message::parseResponse` |
| `parse_query` | `Query::parse` |
| `build_query` | `Query::build` |
| `mimetype_from_filename` | `MimeType::fromFilename` |
| `mimetype_from_extension` | `MimeType::fromExtension` |
| `_parse_message` | `Message::parseMessage` |
| `_parse_request_uri` | `Message::parseRequestUri` |
| `get_message_body_summary` | `Message::bodySummary` |
| `_caseless_remove` | `Utils::caselessRemove` |


# Additional URI Methods

Aside from the standard `Psr\Http\Message\UriInterface` implementation in form of the `GuzzleHttp\Psr7\Uri` class,
this library also provides additional functionality when working with URIs as static methods.

## URI Types

An instance of `Psr\Http\Message\UriInterface` can either be an absolute URI or a relative reference.
An absolute URI has a scheme. A relative reference is used to express a URI relative to another URI,
the base URI. Relative references can be divided into several forms according to
[RFC 3986 Section 4.2](https://tools.ietf.org/html/rfc3986#section-4.2):

- network-path references, e.g. `//example.com/path`
- absolute-path references, e.g. `/path`
- relative-path references, e.g. `subpath`

The following methods can be used to identify the type of the URI.

### `GuzzleHttp\Psr7\Uri::isAbsolute`

`public static function isAbsolute(UriInterface $uri): bool`

Whether the URI is absolute, i.e. it has a scheme.

### `GuzzleHttp\Psr7\Uri::isNetworkPathReference`

`public static function isNetworkPathReference(UriInterface $uri): bool`

Whether the URI is a network-path reference. A relative reference that begins with two slash characters is
termed an network-path reference.

### `GuzzleHttp\Psr7\Uri::isAbsolutePathReference`

`public static function isAbsolutePathReference(UriInterface $uri): bool`

Whether the URI is a absolute-path reference. A relative reference that begins with a single slash character is
termed an absolute-path reference.

### `GuzzleHttp\Psr7\Uri::isRelativePathReference`

`public static function isRelativePathReference(UriInterface $uri): bool`

Whether the URI is a relative-path reference. A relative reference that does not begin with a slash character is
termed a relative-path reference.

### `GuzzleHttp\Psr7\Uri::isSameDocumentReference`

`public static function isSameDocumentReference(UriInterface $uri, UriInterface $base = null): bool`

Whether the URI is a same-document reference. A same-document reference refers to a URI that is, aside from its
fragment component, identical to the base URI. When no base URI is given, only an empty URI reference
(apart from its fragment) is considered a same-document reference.

## URI Components

Additional methods to work with URI components.

### `GuzzleHttp\Psr7\Uri::isDefaultPort`

`public static function isDefaultPort(UriInterface $uri): bool`

Whether the URI has the default port of the current scheme. `Psr\Http\Message\UriInterface::getPort` may return null
or the standard port. This method can be used independently of the implementation.

### `GuzzleHttp\Psr7\Uri::composeComponents`

`public static function composeComponents($scheme, $authority, $path, $query, $fragment): string`

Composes a URI reference string from its various components according to
[RFC 3986 Section 5.3](https://tools.ietf.org/html/rfc3986#section-5.3). Usually this method does not need to be called
manually but instead is used indirectly via `Psr\Http\Message\UriInterface::__toString`.

### `GuzzleHttp\Psr7\Uri::fromParts`

`public static function fromParts(array $parts): UriInterface`

Creates a URI from a hash of [`parse_url`](https://www.php.net/manual/en/function.parse-url.php) components.


### `GuzzleHttp\Psr7\Uri::withQueryValue`

`public static function withQueryValue(UriInterface $uri, $key, $value): UriInterface`

Creates a new URI with a specific query string value. Any existing query string values that exactly match the
provided key are removed and replaced with the given key value pair. A value of null will set the query string
key without a value, e.g. "key" instead of "key=value".

### `GuzzleHttp\Psr7\Uri::withQueryValues`

`public static function withQueryValues(UriInterface $uri, array $keyValueArray): UriInterface`

Creates a new URI with multiple query string values. It has the same behavior as `withQueryValue()` but for an
associative array of key => value.

### `GuzzleHttp\Psr7\Uri::withoutQueryValue`

`public static function withoutQueryValue(UriInterface $uri, $key): UriInterface`

Creates a new URI with a specific query string value removed. Any existing query string values that exactly match the
provided key are removed.

## Cross-Origin Detection

`GuzzleHttp\Psr7\UriComparator` provides methods to determine if a modified URL should be considered cross-origin.

### `GuzzleHttp\Psr7\UriComparator::isCrossOrigin`

`public static function isCrossOrigin(UriInterface $original, UriInterface $modified): bool`

Determines if a modified URL should be considered cross-origin with respect to an original URL.

## Reference Resolution

`GuzzleHttp\Psr7\UriResolver` provides methods to resolve a URI reference in the context of a base URI according
to [RFC 3986 Section 5](https://tools.ietf.org/html/rfc3986#section-5). This is for example also what web browsers
do when resolving a link in a website based on the current request URI.

### `GuzzleHttp\Psr7\UriResolver::resolve`

`public static function resolve(UriInterface $base, UriInterface $rel): UriInterface`

Converts the relative URI into a new URI that is resolved against the base URI.

### `GuzzleHttp\Psr7\UriResolver::removeDotSegments`

`public static function removeDotSegments(string $path): string`

Removes dot segments from a path and returns the new path according to
[RFC 3986 Section 5.2.4](https://tools.ietf.org/html/rfc3986#section-5.2.4).

### `GuzzleHttp\Psr7\UriResolver::relativize`

`public static function relativize(UriInterface $base, UriInterface $target): UriInterface`

Returns the target URI as a relative reference from the base URI. This method is the counterpart to resolve():

```php
(string) $target === (string) UriResolver::resolve($base, UriResolver::relativize($base, $target))
```

One use-case is to use the current request URI as base URI and then generate relative links in your documents
to reduce the document size or offer self-contained downloadable document archives.

```php
$base = new Uri('http://example.com/a/b/');
echo UriResolver::relativize($base, new Uri('http://example.com/a/b/c'));  // prints 'c'.
echo UriResolver::relativize($base, new Uri('http://example.com/a/x/y'));  // prints '../x/y'.
echo UriResolver::relativize($base, new Uri('http://example.com/a/b/?q')); // prints '?q'.
echo UriResolver::relativize($base, new Uri('http://example.org/a/b/'));   // prints '//example.org/a/b/'.
```

## Normalization and Comparison

`GuzzleHttp\Psr7\UriNormalizer` provides methods to normalize and compare URIs according to
[RFC 3986 Section 6](https://tools.ietf.org/html/rfc3986#section-6).

### `GuzzleHttp\Psr7\UriNormalizer::normalize`

`public static function normalize(UriInterface $uri, $flags = self::PRESERVING_NORMALIZATIONS): UriInterface`

Returns a normalized URI. The scheme and host component are already normalized to lowercase per PSR-7 UriInterface.
This methods adds additional normalizations that can be configured with the `$flags` parameter which is a bitmask
of normalizations to apply. The following normalizations are available:

- `UriNormalizer::PRESERVING_NORMALIZATIONS`

    Default normalizations which only include the ones that preserve semantics.

- `UriNormalizer::CAPITALIZE_PERCENT_ENCODING`

    All letters within a percent-encoding triplet (e.g., "%3A") are case-insensitive, and should be capitalized.

    Example: `http://example.org/a%c2%b1b` → `http://example.org/a%C2%B1b`

- `UriNormalizer::DECODE_UNRESERVED_CHARACTERS`

    Decodes percent-encoded octets of unreserved characters. For consistency, percent-encoded octets in the ranges of
    ALPHA (%41–%5A and %61–%7A), DIGIT (%30–%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E) should
    not be created by URI producers and, when found in a URI, should be decoded to their corresponding unreserved
    characters by URI normalizers.

    Example: `http://example.org/%7Eusern%61me/` → `http://example.org/~username/`

- `UriNormalizer::CONVERT_EMPTY_PATH`

    Converts the empty path to "/" for http and https URIs.

    Example: `http://example.org` → `http://example.org/`

- `UriNormalizer::REMOVE_DEFAULT_HOST`

    Removes the default host of the given URI scheme from the URI. Only the "file" scheme defines the default host
    "localhost". All of `file:/myfile`, `file:///myfile`, and `file://localhost/myfile` are equivalent according to
    RFC 3986.

    Example: `file://localhost/myfile` → `file:///myfile`

- `UriNormalizer::REMOVE_DEFAULT_PORT`

    Removes the default port of the given URI scheme from the URI.

    Example: `http://example.org:80/` → `http://example.org/`

- `UriNormalizer::REMOVE_DOT_SEGMENTS`

    Removes unnecessary dot-segments. Dot-segments in relative-path references are not removed as it would
    change the semantics of the URI reference.

    Example: `http://example.org/../a/b/../c/./d.html` → `http://example.org/a/c/d.html`

- `UriNormalizer::REMOVE_DUPLICATE_SLASHES`

    Paths which include two or more adjacent slashes are converted to one. Webservers usually ignore duplicate slashes
    and treat those URIs equivalent. But in theory those URIs do not need to be equivalent. So this normalization
    may change the semantics. Encoded slashes (%2F) are not removed.

    Example: `http://example.org//foo///bar.html` → `http://example.org/foo/bar.html`

- `UriNormalizer::SORT_QUERY_PARAMETERS`

    Sort query parameters with their values in alphabetical order. However, the order of parameters in a URI may be
    significant (this is not defined by the standard). So this normalization is not safe and may change the semantics
    of the URI.

    Example: `?lang=en&article=fred` → `?article=fred&lang=en`

### `GuzzleHttp\Psr7\UriNormalizer::isEquivalent`

`public static function isEquivalent(UriInterface $uri1, UriInterface $uri2, $normalizations = self::PRESERVING_NORMALIZATIONS): bool`

Whether two URIs can be considered equivalent. Both URIs are normalized automatically before comparison with the given
`$normalizations` bitmask. The method also accepts relative URI references and returns true when they are equivalent.
This of course assumes they will be resolved against the same base URI. If this is not the case, determination of
equivalence or difference of relative references does not mean anything.


## Version Guidance

| Version | Status         | PHP Version      |
|---------|----------------|------------------|
| 1.x     | Security fixes | >=5.4,<8.1       |
| 2.x     | Latest         | ^7.2.5 \|\| ^8.0 |


## Security

If you discover a security vulnerability within this package, please send an email to security@tidelift.com. All security vulnerabilities will be promptly addressed. Please do not disclose security-related issues publicly until a fix has been announced. Please see [Security Policy](https://github.com/guzzle/psr7/security/policy) for more information.


## License

Guzzle is made available under the MIT License (MIT). Please see [License File](LICENSE) for more information.


## For Enterprise

Available as part of the Tidelift Subscription

The maintainers of Guzzle and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/packagist-guzzlehttp-psr7?utm_source=packagist-guzzlehttp-psr7&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)


Carpeta: onzauth/vendor/guzzlehttp/psr7/src/

Archivo: onzauth/vendor/guzzlehttp/psr7/src/AppendStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/BufferStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/CachingStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/DroppingStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/guzzlehttp/psr7/src/Exception/

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Exception/MalformedUriException.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/FnStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Header.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/HttpFactory.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/InflateStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/LazyOpenStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/LimitStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Message.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/MessageTrait.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/MimeType.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/MultipartStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/NoSeekStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/PumpStream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Query.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Request.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Response.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Rfc7230.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/ServerRequest.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/StreamDecoratorTrait.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Stream.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/StreamWrapper.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/UploadedFile.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/UriComparator.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/UriNormalizer.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Uri.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/UriResolver.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/guzzlehttp/psr7/src/Utils.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/psr/

Carpeta: onzauth/vendor/psr/http-client/

Archivo: onzauth/vendor/psr/http-client/CHANGELOG.md
Tipo de archivo: text/markdown

Contenido:
# Changelog

All notable changes to this project will be documented in this file, in reverse chronological order by release.

## 1.0.1

Allow installation with PHP 8. No code changes.

## 1.0.0

First stable release. No changes since 0.3.0.

## 0.3.0

Added Interface suffix on exceptions
 
## 0.2.0 

All exceptions are in `Psr\Http\Client` namespace

## 0.1.0

First release


Archivo: onzauth/vendor/psr/http-client/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-client/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-client/README.md
Tipo de archivo: text/markdown

Contenido:
HTTP Client
===========

This repository holds all the common code related to [PSR-18 (HTTP Client)][psr-url].

Note that this is not a HTTP Client implementation of its own. It is merely abstractions that describe the components of a HTTP Client.

The installable [package][package-url] and [implementations][implementation-url] are listed on Packagist.

[psr-url]: https://www.php-fig.org/psr/psr-18
[package-url]: https://packagist.org/packages/psr/http-client
[implementation-url]: https://packagist.org/providers/psr/http-client-implementation


Carpeta: onzauth/vendor/psr/http-client/src/

Archivo: onzauth/vendor/psr/http-client/src/ClientExceptionInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-client/src/ClientInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-client/src/NetworkExceptionInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-client/src/RequestExceptionInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/psr/http-factory/

Archivo: onzauth/vendor/psr/http-factory/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-factory/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-factory/README.md
Tipo de archivo: text/markdown

Contenido:
HTTP Factories
==============

This repository holds all interfaces related to [PSR-17 (HTTP Factories)][psr-url].

Note that this is not a HTTP Factory implementation of its own. It is merely interfaces that describe the components of a HTTP Factory.

The installable [package][package-url] and [implementations][implementation-url] are listed on Packagist.

[psr-url]: https://www.php-fig.org/psr/psr-17/
[package-url]: https://packagist.org/packages/psr/http-factory
[implementation-url]: https://packagist.org/providers/psr/http-factory-implementation


Carpeta: onzauth/vendor/psr/http-factory/src/

Archivo: onzauth/vendor/psr/http-factory/src/RequestFactoryInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-factory/src/ResponseFactoryInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-factory/src/ServerRequestFactoryInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-factory/src/StreamFactoryInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-factory/src/UploadedFileFactoryInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-factory/src/UriFactoryInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/psr/http-message/

Archivo: onzauth/vendor/psr/http-message/CHANGELOG.md
Tipo de archivo: text/markdown

Contenido:
# Changelog

All notable changes to this project will be documented in this file, in reverse chronological order by release.

## 1.0.1 - 2016-08-06

### Added

- Nothing.

### Deprecated

- Nothing.

### Removed

- Nothing.

### Fixed

- Updated all `@return self` annotation references in interfaces to use
  `@return static`, which more closelly follows the semantics of the
  specification.
- Updated the `MessageInterface::getHeaders()` return annotation to use the
  value `string[][]`, indicating the format is a nested array of strings.
- Updated the `@link` annotation for `RequestInterface::withRequestTarget()`
  to point to the correct section of RFC 7230.
- Updated the `ServerRequestInterface::withUploadedFiles()` parameter annotation
  to add the parameter name (`$uploadedFiles`).
- Updated a `@throws` annotation for the `UploadedFileInterface::moveTo()`
  method to correctly reference the method parameter (it was referencing an
  incorrect parameter name previously).

## 1.0.0 - 2016-05-18

Initial stable release; reflects accepted PSR-7 specification.


Archivo: onzauth/vendor/psr/http-message/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/psr/http-message/docs/

Archivo: onzauth/vendor/psr/http-message/docs/PSR7-Interfaces.md
Tipo de archivo: text/markdown

Contenido:
# Interfaces

The purpose of this list is to help in finding the methods when working with PSR-7. This can be considered as a cheatsheet for PSR-7 interfaces.

The interfaces defined in PSR-7 are the following:

| Class Name | Description |
|---|---|
| [Psr\Http\Message\MessageInterface](http://www.php-fig.org/psr/psr-7/#psrhttpmessagemessageinterface) | Representation of a HTTP message |
| [Psr\Http\Message\RequestInterface](http://www.php-fig.org/psr/psr-7/#psrhttpmessagerequestinterface) | Representation of an outgoing, client-side request. |
| [Psr\Http\Message\ServerRequestInterface](http://www.php-fig.org/psr/psr-7/#psrhttpmessageserverrequestinterface) | Representation of an incoming, server-side HTTP request. | 
| [Psr\Http\Message\ResponseInterface](http://www.php-fig.org/psr/psr-7/#psrhttpmessageresponseinterface) | Representation of an outgoing, server-side response. |
| [Psr\Http\Message\StreamInterface](http://www.php-fig.org/psr/psr-7/#psrhttpmessagestreaminterface) | Describes a data stream |
| [Psr\Http\Message\UriInterface](http://www.php-fig.org/psr/psr-7/#psrhttpmessageuriinterface) | Value object representing a URI. |
| [Psr\Http\Message\UploadedFileInterface](http://www.php-fig.org/psr/psr-7/#psrhttpmessageuploadedfileinterface) | Value object representing a file uploaded through an HTTP request. |

## `Psr\Http\Message\MessageInterface` Methods

| Method Name                        | Description | Notes |
|------------------------------------| ----------- | ----- |
| `getProtocolVersion()`             | Retrieve HTTP protocol version          |  1.0 or 1.1 |
| `withProtocolVersion($version)`    | Returns new message instance with given HTTP protocol version          |      |
| `getHeaders()`                     | Retrieve all HTTP Headers               | [Request Header List](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields), [Response Header List](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Response_fields)      |
| `hasHeader($name)`                 | Checks if HTTP Header with given name exists  | |
| `getHeader($name)`                 | Retrieves a array with the values for a single header | |
| `getHeaderLine($name)`             | Retrieves a comma-separated string of the values for a single header |  |
| `withHeader($name, $value)`        | Returns new message instance with given HTTP Header | if the header existed in the original instance, replaces the header value from the original message with the value provided when creating the new instance. |
| `withAddedHeader($name, $value)`   | Returns new message instance with appended value to given header | If header already exists value will be appended, if not a new header will be created |
| `withoutHeader($name)`             | Removes HTTP Header with given name| |
| `getBody()`                        | Retrieves the HTTP Message Body | Returns object implementing `StreamInterface`|
| `withBody(StreamInterface $body)`  | Returns new message instance with given HTTP Message Body | |


## `Psr\Http\Message\RequestInterface` Methods

Same methods as `Psr\Http\Message\MessageInterface`  + the following methods:

| Method Name                        | Description | Notes |
|------------------------------------| ----------- | ----- |
| `getRequestTarget()`                | Retrieves the message's request target              | origin-form, absolute-form, authority-form, asterisk-form ([RFC7230](https://www.rfc-editor.org/rfc/rfc7230.txt)) |
| `withRequestTarget($requestTarget)` | Return a new message instance with the specific request-target |      |
| `getMethod()`                       | Retrieves the HTTP method of the request.  |  GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE (defined in [RFC7231](https://tools.ietf.org/html/rfc7231)), PATCH (defined in [RFC5789](https://tools.ietf.org/html/rfc5789)) |
| `withMethod($method)`               | Returns a new message instance with the provided HTTP method  | |
| `getUri()`                 | Retrieves the URI instance | |
| `withUri(UriInterface $uri, $preserveHost = false)` | Returns a new message instance with the provided URI |  |


## `Psr\Http\Message\ServerRequestInterface` Methods

Same methods as `Psr\Http\Message\RequestInterface`  + the following methods:

| Method Name                        | Description | Notes |
|------------------------------------| ----------- | ----- |
| `getServerParams() `               | Retrieve server parameters  | Typically derived from `$_SERVER`  |
| `getCookieParams()`                | Retrieves cookies sent by the client to the server. | Typically derived from `$_COOKIES` |
| `withCookieParams(array $cookies)` |  Returns a new request instance with the specified cookies      |   | 
| `withQueryParams(array $query)` | Returns a new request instance with the specified query string arguments  |  |
| `getUploadedFiles()` | Retrieve normalized file upload data  |  |
| `withUploadedFiles(array $uploadedFiles)` | Returns a new request instance with the specified uploaded files  |  |
| `getParsedBody()` | Retrieve any parameters provided in the request body  |  |
| `withParsedBody($data)` | Returns a new request instance with the specified body parameters  |  |
| `getAttributes()` | Retrieve attributes derived from the request  |  |
| `getAttribute($name, $default = null)` | Retrieve a single derived request attribute  |  |
| `withAttribute($name, $value)` | Returns a new request instance with the specified derived request attribute  |  |
| `withoutAttribute($name)` | Returns a new request instance that without the specified derived request attribute  |  |

## `Psr\Http\Message\ResponseInterface` Methods:

Same methods as `Psr\Http\Message\MessageInterface`  + the following methods:

| Method Name                        | Description | Notes |
|------------------------------------| ----------- | ----- |
| `getStatusCode()` | Gets the response status code. | |
| `withStatus($code, $reasonPhrase = '')` | Returns a new response instance with the specified status code and, optionally, reason phrase. | |
| `getReasonPhrase()` | Gets the response reason phrase associated with the status code. | |

##  `Psr\Http\Message\StreamInterface` Methods

| Method Name                        | Description | Notes |
|------------------------------------| ----------- | ----- |
| `__toString()` | Reads all data from the stream into a string, from the beginning to end. | |
| `close()` | Closes the stream and any underlying resources. | |
| `detach()` | Separates any underlying resources from the stream. | |
| `getSize()` | Get the size of the stream if known. | |
| `eof()` | Returns true if the stream is at the end of the stream.| |
| `isSeekable()` |  Returns whether or not the stream is seekable. | |
| `seek($offset, $whence = SEEK_SET)` | Seek to a position in the stream. | |
| `rewind()` | Seek to the beginning of the stream. | |
| `isWritable()` | Returns whether or not the stream is writable. | |
| `write($string)` | Write data to the stream. | |
| `isReadable()` | Returns whether or not the stream is readable. | |
| `read($length)` | Read data from the stream. | |
| `getContents()` | Returns the remaining contents in a string | |
| `getMetadata($key = null)()` | Get stream metadata as an associative array or retrieve a specific key. | |

## `Psr\Http\Message\UriInterface` Methods

| Method Name                        | Description | Notes |
|------------------------------------| ----------- | ----- |
| `getScheme()` | Retrieve the scheme component of the URI. | |
| `getAuthority()` | Retrieve the authority component of the URI. | |
| `getUserInfo()` | Retrieve the user information component of the URI. | |
| `getHost()` | Retrieve the host component of the URI. | |
| `getPort()` | Retrieve the port component of the URI. | |
| `getPath()` | Retrieve the path component of the URI. | |
| `getQuery()` | Retrieve the query string of the URI. | |
| `getFragment()` | Retrieve the fragment component of the URI. | |
| `withScheme($scheme)` | Return an instance with the specified scheme. | |
| `withUserInfo($user, $password = null)` | Return an instance with the specified user information. | |
| `withHost($host)` | Return an instance with the specified host. | |
| `withPort($port)` | Return an instance with the specified port. | |
| `withPath($path)` | Return an instance with the specified path. | |
| `withQuery($query)` | Return an instance with the specified query string. | |
| `withFragment($fragment)` | Return an instance with the specified URI fragment. | |
| `__toString()` | Return the string representation as a URI reference. | |

## `Psr\Http\Message\UploadedFileInterface` Methods

| Method Name                        | Description | Notes |
|------------------------------------| ----------- | ----- |
| `getStream()` | Retrieve a stream representing the uploaded file. | |
| `moveTo($targetPath)` | Move the uploaded file to a new location. | |
| `getSize()` | Retrieve the file size. | |
| `getError()` | Retrieve the error associated with the uploaded file. | |
| `getClientFilename()` | Retrieve the filename sent by the client. | |
| `getClientMediaType()` | Retrieve the media type sent by the client. | |

> `RequestInterface`, `ServerRequestInterface`, `ResponseInterface` extend `MessageInterface`  because the `Request` and the `Response` are `HTTP Messages`.
> When using `ServerRequestInterface`, both `RequestInterface` and `Psr\Http\Message\MessageInterface` methods are considered.



Archivo: onzauth/vendor/psr/http-message/docs/PSR7-Usage.md
Tipo de archivo: text/markdown

Contenido:
### PSR-7 Usage

All PSR-7 applications comply with these interfaces 
They were created to establish a standard between middleware implementations.

> `RequestInterface`, `ServerRequestInterface`, `ResponseInterface` extend `MessageInterface`  because the `Request` and the `Response` are `HTTP Messages`.
> When using `ServerRequestInterface`, both `RequestInterface` and `Psr\Http\Message\MessageInterface` methods are considered.


The following examples will illustrate how basic operations are done in PSR-7.

##### Examples


For this examples to work (at least) a PSR-7 implementation package is required. (eg: zendframework/zend-diactoros, guzzlehttp/psr7, slim/slim, etc)
All PSR-7 implementations should have the same behaviour.

The following will be assumed: 
`$request` is an object of `Psr\Http\Message\RequestInterface` and

`$response` is an object implementing `Psr\Http\Message\RequestInterface`


### Working with HTTP Headers

#### Adding headers to response:

```php
$response->withHeader('My-Custom-Header', 'My Custom Message');
```

#### Appending values to headers

```php
$response->withAddedHeader('My-Custom-Header', 'The second message');
```

#### Checking if header exists:

```php
$request->hasHeader('My-Custom-Header'); // will return false
$response->hasHeader('My-Custom-Header'); // will return true
```

> Note: My-Custom-Header was only added in the Response

#### Getting comma-separated values from a header (also applies to request)

```php
// getting value from request headers
$request->getHeaderLine('Content-Type'); // will return: "text/html; charset=UTF-8"
// getting value from response headers
$response->getHeaderLine('My-Custom-Header'); // will return:  "My Custom Message; The second message"
```

#### Getting array of value from a header (also applies to request)
```php
// getting value from request headers
$request->getHeader('Content-Type'); // will return: ["text/html", "charset=UTF-8"]
// getting value from response headers
$response->getHeader('My-Custom-Header'); // will return:  ["My Custom Message",  "The second message"]
```

#### Removing headers from HTTP Messages
```php
// removing a header from Request, removing deprecated "Content-MD5" header
$request->withoutHeader('Content-MD5'); 

// removing a header from Response
// effect: the browser won't know the size of the stream
// the browser will download the stream till it ends
$response->withoutHeader('Content-Length');
```

### Working with HTTP Message Body

When working with the PSR-7 there are two methods of implementation:
#### 1. Getting the body separately

> This method makes the body handling easier to understand and is useful when repeatedly calling body methods. (You only call `getBody()` once). Using this method mistakes like `$response->write()` are also prevented.

```php
$body = $response->getBody();
// operations on body, eg. read, write, seek
// ...
// replacing the old body
$response->withBody($body); 
// this last statement is optional as we working with objects
// in this case the "new" body is same with the "old" one
// the $body variable has the same value as the one in $request, only the reference is passed
```

#### 2. Working directly on response

> This method is useful when only performing few operations as the `$request->getBody()` statement fragment is required

```php
$response->getBody()->write('hello');
```

### Getting the body contents

The following snippet gets the contents of a stream contents.
> Note: Streams must be rewinded, if content was written into streams, it will be ignored when calling `getContents()` because the stream pointer is set to the last character, which is `\0` - meaning end of stream.
```php 
$body = $response->getBody();
$body->rewind(); // or $body->seek(0);
$bodyText = $body->getContents();
```
> Note: If `$body->seek(1)` is called before `$body->getContents()`, the first character will be ommited as the starting pointer is set to `1`, not `0`. This is why using `$body->rewind()` is recommended.

### Append to body

```php
$response->getBody()->write('Hello'); // writing directly
$body = $request->getBody(); // which is a `StreamInterface`
$body->write('xxxxx');
```

### Prepend to body
Prepending is different when it comes to streams. The content must be copied before writing the content to be prepended.
The following example will explain the behaviour of streams.

```php
// assuming our response is initially empty
$body = $repsonse->getBody();
// writing the string "abcd"
$body->write('abcd');

// seeking to start of stream
$body->seek(0);
// writing 'ef'
$body->write('ef'); // at this point the stream contains "efcd"
```

#### Prepending by rewriting separately

```php
// assuming our response body stream only contains: "abcd"
$body = $response->getBody();
$body->rewind();
$contents = $body->getContents(); // abcd
// seeking the stream to beginning
$body->rewind();
$body->write('ef'); // stream contains "efcd"
$body->write($contents); // stream contains "efabcd"
```

> Note: `getContents()` seeks the stream while reading it, therefore if the second `rewind()` method call was not present the stream would have resulted in `abcdefabcd` because the `write()` method appends to stream if not preceeded by `rewind()` or `seek(0)`.

#### Prepending by using contents as a string
```php
$body = $response->getBody();
$body->rewind();
$contents = $body->getContents(); // efabcd
$contents = 'ef'.$contents;
$body->rewind();
$body->write($contents);
```


Archivo: onzauth/vendor/psr/http-message/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-message/README.md
Tipo de archivo: text/markdown

Contenido:
PSR Http Message
================

This repository holds all interfaces/classes/traits related to
[PSR-7](http://www.php-fig.org/psr/psr-7/).

Note that this is not a HTTP message implementation of its own. It is merely an
interface that describes a HTTP message. See the specification for more details.

Usage
-----

Before reading the usage guide we recommend reading the PSR-7 interfaces method list:

* [`PSR-7 Interfaces Method List`](docs/PSR7-Interfaces.md)
* [`PSR-7 Usage Guide`](docs/PSR7-Usage.md)

Carpeta: onzauth/vendor/psr/http-message/src/

Archivo: onzauth/vendor/psr/http-message/src/MessageInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-message/src/RequestInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-message/src/ResponseInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-message/src/ServerRequestInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-message/src/StreamInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-message/src/UploadedFileInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/psr/http-message/src/UriInterface.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/ralouphie/

Carpeta: onzauth/vendor/ralouphie/getallheaders/

Archivo: onzauth/vendor/ralouphie/getallheaders/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/ralouphie/getallheaders/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/ralouphie/getallheaders/README.md
Tipo de archivo: text/markdown

Contenido:
getallheaders
=============

PHP `getallheaders()` polyfill. Compatible with PHP >= 5.3.

[![Build Status](https://travis-ci.org/ralouphie/getallheaders.svg?branch=master)](https://travis-ci.org/ralouphie/getallheaders)
[![Coverage Status](https://coveralls.io/repos/ralouphie/getallheaders/badge.png?branch=master)](https://coveralls.io/r/ralouphie/getallheaders?branch=master)
[![Latest Stable Version](https://poser.pugx.org/ralouphie/getallheaders/v/stable.png)](https://packagist.org/packages/ralouphie/getallheaders)
[![Latest Unstable Version](https://poser.pugx.org/ralouphie/getallheaders/v/unstable.png)](https://packagist.org/packages/ralouphie/getallheaders)
[![License](https://poser.pugx.org/ralouphie/getallheaders/license.png)](https://packagist.org/packages/ralouphie/getallheaders)


This is a simple polyfill for [`getallheaders()`](http://www.php.net/manual/en/function.getallheaders.php).

## Install

For PHP version **`>= 5.6`**:

```
composer require ralouphie/getallheaders
```

For PHP version **`< 5.6`**:

```
composer require ralouphie/getallheaders "^2"
```


Carpeta: onzauth/vendor/ralouphie/getallheaders/src/

Archivo: onzauth/vendor/ralouphie/getallheaders/src/getallheaders.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Carpeta: onzauth/vendor/symfony/

Carpeta: onzauth/vendor/symfony/deprecation-contracts/

Archivo: onzauth/vendor/symfony/deprecation-contracts/CHANGELOG.md
Tipo de archivo: text/markdown

Contenido:
CHANGELOG
=========

The changelog is maintained for all Symfony contracts at the following URL:
https://github.com/symfony/contracts/blob/main/CHANGELOG.md


Archivo: onzauth/vendor/symfony/deprecation-contracts/composer.json
Tipo de archivo: application/json

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/symfony/deprecation-contracts/function.php
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/symfony/deprecation-contracts/.gitignore
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/symfony/deprecation-contracts/LICENSE
Tipo de archivo: None

Contenido:
El archivo no es de tipo texto. No se puede mostrar el contenido.

Archivo: onzauth/vendor/symfony/deprecation-contracts/README.md
Tipo de archivo: text/markdown

Contenido:
Symfony Deprecation Contracts
=============================

A generic function and convention to trigger deprecation notices.

This package provides a single global function named `trigger_deprecation()` that triggers silenced deprecation notices.

By using a custom PHP error handler such as the one provided by the Symfony ErrorHandler component,
the triggered deprecations can be caught and logged for later discovery, both on dev and prod environments.

The function requires at least 3 arguments:
 - the name of the Composer package that is triggering the deprecation
 - the version of the package that introduced the deprecation
 - the message of the deprecation
 - more arguments can be provided: they will be inserted in the message using `printf()` formatting

Example:
```php
trigger_deprecation('symfony/blockchain', '8.9', 'Using "%s" is deprecated, use "%s" instead.', 'bitcoin', 'fabcoin');
```

This will generate the following message:
`Since symfony/blockchain 8.9: Using "bitcoin" is deprecated, use "fabcoin" instead.`

While not necessarily recommended, the deprecation notices can be completely ignored by declaring an empty
`function trigger_deprecation() {}` in your application.

